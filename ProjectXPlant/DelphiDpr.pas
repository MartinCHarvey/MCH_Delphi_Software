unit DelphiDpr;




{==============================================================================
DelphiDpr
0.0.0.0
Date of Generation: 20/12/2024 19:00
Comment: Parses Delphi DPR files.
Author: Martin Harvey
Copyright: (c) Martin Harvey

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase;



const
maxT = 15;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EDelphiDpr = class(Exception);
  TDelphiDpr = class;

  TDelphiDprScanner = class(TCocoRScanner)
  private
    FOwner : TDelphiDpr;
function CharInIgnoreSet(const Ch : AnsiChar) : boolean;
procedure CheckLiteral(var Sym : integer);
function Equal(s : AnsiString) : boolean;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TDelphiDpr read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TDelphiDprScanner }

  TDelphiDpr = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..0] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : AnsiString;
    function GetVersionStr : AnsiString;
    procedure SetVersion(const Value : AnsiString);
    function GetVersionInfo : AnsiString;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _UseLocation;
    procedure _UseClause;
    procedure _NextDecl;
    procedure _UseClauses;
    procedure _DelphiDpr;

  private
    FLocationList: TStringList;
    FCurrentLocation: string;

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString; override;
    procedure Execute; override;
    function GetScanner : TDelphiDprScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : AnsiString read GetVersionStr;
    property VersionInfo : AnsiString read GetVersionInfo;

  public
    property LocationList: TStringList read FLocationList;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : AnsiString read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TDelphiDpr }

implementation



const

  EOFSYMB = 0;  identifierSym = 1;  stringSym = 2;  dotSym = 3;  semiSym = 4;
  commaSym = 5;  programSym = 6;  usesSym = 7;  inSym = 8;  constSym = 9;
  typeSym = 10;  varSym = 11;  beginSym = 12;  procedureSym = 13;
  functionSym = 14;  NOSYMB = 15;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
{

Copyright © 2020 Martin Harvey <martin_c_harvey@hotmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

}




{ --------------------------------------------------------------------------- }
{ ---- implementation for TDelphiDprScanner ---- }

procedure TDelphiDprScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TDelphiDprScanner.Comment : boolean;
var
  level : integer;
  StartCommentCh: AnsiChar;
  startLine : integer;
  oldLineStart : longint;
  CommentStr : AnsiString;
begin
StartCommentCh := CurrInputCh;
  level := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = AnsiChar(10)) then
begin
level := level -  1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
Result := false;
if (CurrInputCh = '(') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = ')') then
begin
level := level -  1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
Result := false;
if (CurrInputCh = '{') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = '}') then
begin
level := level -  1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end;
end;  { Comment }

function TDelphiDprScanner.CharInIgnoreSet(const Ch : AnsiChar) : boolean;
begin
Result := (Ch = ' ')    OR
((CurrInputCh >= AnsiChar(9)) AND (CurrInputCh <= AnsiChar(10)) OR
(CurrInputCh = AnsiChar(13)) OR
(CurrInputCh = ' '));
end; {CharInIgnoreSet}

function TDelphiDprScanner.Equal(s : AnsiString) : boolean;
var
  i : integer;
  q : int64;
begin
  if NextSymbol.Len <> Length(s) then
  begin
    Result := false;
    EXIT
  end;
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    if CurrentCh(q) <> s[i] then
    begin
      Result := false;
      EXIT;
    end;
    inc(i);
    inc(q);
  end;
  Result := true
end;  {Equal}

procedure TDelphiDprScanner.CheckLiteral(var Sym : integer);
begin
case CurrentCh(bpCurrToken) of
  'b': if Equal('begin') then
begin
sym := beginSym;
end;

  'c': if Equal('const') then
begin
sym := constSym;
end;

  'f': if Equal('function') then
begin
sym := functionSym;
end;

  'i': if Equal('in') then
begin
sym := inSym;
end;

  'p': if Equal('procedure') then
begin
sym := procedureSym;
end
else if Equal('program') then
begin
sym := programSym;
end;

  't': if Equal('type') then
begin
sym := typeSym;
end;

  'u': if Equal('uses') then
begin
sym := usesSym;
end;

  'v': if Equal('var') then
begin
sym := varSym;
end;

else
begin
end
end
end; {CheckLiteral}


procedure TDelphiDprScanner.Get(var sym : integer);
var
  state : integer;
  label __start_get;
 begin   {Get}
__start_get:
while CharInIgnoreSet(CurrInputCh) do
  NextCh;
if ((CurrInputCh = '/') OR (CurrInputCh = '(') OR (CurrInputCh = '{')) AND Comment then goto __start_get;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
sym := identifierSym;
CheckLiteral(sym);
exit;
end;
   2: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 3; 
end
else if NOT ((CurrInputCh = AnsiChar(39))) then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
   3: begin
sym := stringSym;
exit;
end;
   4: begin
sym := dotSym;
exit;
end;
   5: begin
sym := semiSym;
exit;
end;
   6: begin
sym := commaSym;
exit;
end;
   7: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TDelphiDprScanner.Create;
begin
  inherited;
CurrentCh := CharAt;
fStartState[  0] :=  7; fStartState[  1] :=  8; fStartState[  2] :=  8; fStartState[  3] :=  8; 
fStartState[  4] :=  8; fStartState[  5] :=  8; fStartState[  6] :=  8; fStartState[  7] :=  8; 
fStartState[  8] :=  8; fStartState[  9] :=  8; fStartState[ 10] :=  8; fStartState[ 11] :=  8; 
fStartState[ 12] :=  8; fStartState[ 13] :=  8; fStartState[ 14] :=  8; fStartState[ 15] :=  8; 
fStartState[ 16] :=  8; fStartState[ 17] :=  8; fStartState[ 18] :=  8; fStartState[ 19] :=  8; 
fStartState[ 20] :=  8; fStartState[ 21] :=  8; fStartState[ 22] :=  8; fStartState[ 23] :=  8; 
fStartState[ 24] :=  8; fStartState[ 25] :=  8; fStartState[ 26] :=  8; fStartState[ 27] :=  8; 
fStartState[ 28] :=  8; fStartState[ 29] :=  8; fStartState[ 30] :=  8; fStartState[ 31] :=  8; 
fStartState[ 32] :=  8; fStartState[ 33] :=  8; fStartState[ 34] :=  8; fStartState[ 35] :=  8; 
fStartState[ 36] :=  8; fStartState[ 37] :=  8; fStartState[ 38] :=  8; fStartState[ 39] :=  2; 
fStartState[ 40] :=  8; fStartState[ 41] :=  8; fStartState[ 42] :=  8; fStartState[ 43] :=  8; 
fStartState[ 44] :=  6; fStartState[ 45] :=  8; fStartState[ 46] :=  4; fStartState[ 47] :=  8; 
fStartState[ 48] :=  8; fStartState[ 49] :=  8; fStartState[ 50] :=  8; fStartState[ 51] :=  8; 
fStartState[ 52] :=  8; fStartState[ 53] :=  8; fStartState[ 54] :=  8; fStartState[ 55] :=  8; 
fStartState[ 56] :=  8; fStartState[ 57] :=  8; fStartState[ 58] :=  8; fStartState[ 59] :=  5; 
fStartState[ 60] :=  8; fStartState[ 61] :=  8; fStartState[ 62] :=  8; fStartState[ 63] :=  8; 
fStartState[ 64] :=  8; fStartState[ 65] :=  1; fStartState[ 66] :=  1; fStartState[ 67] :=  1; 
fStartState[ 68] :=  1; fStartState[ 69] :=  1; fStartState[ 70] :=  1; fStartState[ 71] :=  1; 
fStartState[ 72] :=  1; fStartState[ 73] :=  1; fStartState[ 74] :=  1; fStartState[ 75] :=  1; 
fStartState[ 76] :=  1; fStartState[ 77] :=  1; fStartState[ 78] :=  1; fStartState[ 79] :=  1; 
fStartState[ 80] :=  1; fStartState[ 81] :=  1; fStartState[ 82] :=  1; fStartState[ 83] :=  1; 
fStartState[ 84] :=  1; fStartState[ 85] :=  1; fStartState[ 86] :=  1; fStartState[ 87] :=  1; 
fStartState[ 88] :=  1; fStartState[ 89] :=  1; fStartState[ 90] :=  1; fStartState[ 91] :=  8; 
fStartState[ 92] :=  8; fStartState[ 93] :=  8; fStartState[ 94] :=  8; fStartState[ 95] :=  8; 
fStartState[ 96] :=  8; fStartState[ 97] :=  1; fStartState[ 98] :=  1; fStartState[ 99] :=  1; 
fStartState[100] :=  1; fStartState[101] :=  1; fStartState[102] :=  1; fStartState[103] :=  1; 
fStartState[104] :=  1; fStartState[105] :=  1; fStartState[106] :=  1; fStartState[107] :=  1; 
fStartState[108] :=  1; fStartState[109] :=  1; fStartState[110] :=  1; fStartState[111] :=  1; 
fStartState[112] :=  1; fStartState[113] :=  1; fStartState[114] :=  1; fStartState[115] :=  1; 
fStartState[116] :=  1; fStartState[117] :=  1; fStartState[118] :=  1; fStartState[119] :=  1; 
fStartState[120] :=  1; fStartState[121] :=  1; fStartState[122] :=  1; fStartState[123] :=  8; 
fStartState[124] :=  8; fStartState[125] :=  8; fStartState[126] :=  8; fStartState[127] :=  8; 
fStartState[128] :=  8; fStartState[129] :=  8; fStartState[130] :=  8; fStartState[131] :=  8; 
fStartState[132] :=  8; fStartState[133] :=  8; fStartState[134] :=  8; fStartState[135] :=  8; 
fStartState[136] :=  8; fStartState[137] :=  8; fStartState[138] :=  8; fStartState[139] :=  8; 
fStartState[140] :=  8; fStartState[141] :=  8; fStartState[142] :=  8; fStartState[143] :=  8; 
fStartState[144] :=  8; fStartState[145] :=  8; fStartState[146] :=  8; fStartState[147] :=  8; 
fStartState[148] :=  8; fStartState[149] :=  8; fStartState[150] :=  8; fStartState[151] :=  8; 
fStartState[152] :=  8; fStartState[153] :=  8; fStartState[154] :=  8; fStartState[155] :=  8; 
fStartState[156] :=  8; fStartState[157] :=  8; fStartState[158] :=  8; fStartState[159] :=  8; 
fStartState[160] :=  8; fStartState[161] :=  8; fStartState[162] :=  8; fStartState[163] :=  8; 
fStartState[164] :=  8; fStartState[165] :=  8; fStartState[166] :=  8; fStartState[167] :=  8; 
fStartState[168] :=  8; fStartState[169] :=  8; fStartState[170] :=  8; fStartState[171] :=  8; 
fStartState[172] :=  8; fStartState[173] :=  8; fStartState[174] :=  8; fStartState[175] :=  8; 
fStartState[176] :=  8; fStartState[177] :=  8; fStartState[178] :=  8; fStartState[179] :=  8; 
fStartState[180] :=  8; fStartState[181] :=  8; fStartState[182] :=  8; fStartState[183] :=  8; 
fStartState[184] :=  8; fStartState[185] :=  8; fStartState[186] :=  8; fStartState[187] :=  8; 
fStartState[188] :=  8; fStartState[189] :=  8; fStartState[190] :=  8; fStartState[191] :=  8; 
fStartState[192] :=  8; fStartState[193] :=  8; fStartState[194] :=  8; fStartState[195] :=  8; 
fStartState[196] :=  8; fStartState[197] :=  8; fStartState[198] :=  8; fStartState[199] :=  8; 
fStartState[200] :=  8; fStartState[201] :=  8; fStartState[202] :=  8; fStartState[203] :=  8; 
fStartState[204] :=  8; fStartState[205] :=  8; fStartState[206] :=  8; fStartState[207] :=  8; 
fStartState[208] :=  8; fStartState[209] :=  8; fStartState[210] :=  8; fStartState[211] :=  8; 
fStartState[212] :=  8; fStartState[213] :=  8; fStartState[214] :=  8; fStartState[215] :=  8; 
fStartState[216] :=  8; fStartState[217] :=  8; fStartState[218] :=  8; fStartState[219] :=  8; 
fStartState[220] :=  8; fStartState[221] :=  8; fStartState[222] :=  8; fStartState[223] :=  8; 
fStartState[224] :=  8; fStartState[225] :=  8; fStartState[226] :=  8; fStartState[227] :=  8; 
fStartState[228] :=  8; fStartState[229] :=  8; fStartState[230] :=  8; fStartState[231] :=  8; 
fStartState[232] :=  8; fStartState[233] :=  8; fStartState[234] :=  8; fStartState[235] :=  8; 
fStartState[236] :=  8; fStartState[237] :=  8; fStartState[238] :=  8; fStartState[239] :=  8; 
fStartState[240] :=  8; fStartState[241] :=  8; fStartState[242] :=  8; fStartState[243] :=  8; 
fStartState[244] :=  8; fStartState[245] :=  8; fStartState[246] :=  8; fStartState[247] :=  8; 
fStartState[248] :=  8; fStartState[249] :=  8; fStartState[250] :=  8; fStartState[251] :=  8; 
fStartState[252] :=  8; fStartState[253] :=  8; fStartState[254] :=  8; fStartState[255] :=  8; 
end; {Create}


{ --------------------------------------------------------------------------- }
{ ---- implementation for TDelphiDpr ---- }

constructor TDelphiDpr.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TDelphiDprScanner.Create;
  GetScanner.Owner := self;
FLocationList := TStringList.Create;

  InitSymSet;
end; {Create}

destructor TDelphiDpr.Destroy;
begin
  Scanner.Free;
FLocationList.Free;

  inherited;
end; {Destroy}

function TDelphiDpr.ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'identifier expected';
   2 : Result := 'string expected';
   3 : Result := 'dot expected';
   4 : Result := 'semi expected';
   5 : Result := 'comma expected';
   6 : Result := '"program" expected';
   7 : Result := '"uses" expected';
   8 : Result := '"in" expected';
   9 : Result := '"const" expected';
  10 : Result := '"type" expected';
  11 : Result := '"var" expected';
  12 : Result := '"begin" expected';
  13 : Result := '"procedure" expected';
  14 : Result := '"function" expected';
  15 : Result := 'not expected';
  16 : Result := 'invalid next declaration';


  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := AnsiString('Error: ' + AnsiString(IntToStr(ErrorCode)));
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TDelphiDpr.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;
  StreamPartRead := -1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TDelphiDpr.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TDelphiDpr.GetScanner : TDelphiDprScanner;
begin
  Result := Scanner AS TDelphiDprScanner;
end; {GetScanner}

function TDelphiDpr._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TDelphiDpr._UseLocation;begin
Expect(stringSym);
FCurrentLocation  :=  UnicodeLexString;
FCurrentLocation  :=  FCurrentLocation.SubString(1,  Length(FCurrentLocation)  -  2);
end;

procedure TDelphiDpr._UseClause;begin
Expect(identifierSym);
FCurrentLocation  :=  UnicodeLexString  +  '.pas';
while (fCurrentInputSymbol = dotSym) do begin
Get;
Expect(identifierSym);
end;
if (fCurrentInputSymbol = inSym) then begin
Get;
_UseLocation;
end;
FLocationList.Add(FCurrentLocation);
end;

procedure TDelphiDpr._NextDecl;begin
case fCurrentInputSymbol of
  constSym : begin
Get;
    end;
  typeSym : begin
Get;
    end;
  varSym : begin
Get;
    end;
  beginSym : begin
Get;
    end;
  procedureSym : begin
Get;
    end;
  functionSym : begin
Get;
    end;
else begin SynError(16);
    end;
end;
end;

procedure TDelphiDpr._UseClauses;begin
Expect(usesSym);
_UseClause;
while (fCurrentInputSymbol = commaSym) do begin
Get;
_UseClause;
end;
Expect(semiSym);
end;

procedure TDelphiDpr._DelphiDpr;begin
Expect(programSym);
Expect(identifierSym);
Expect(semiSym);
_UseClauses;
_NextDecl;
end;

function TDelphiDpr.GetBuildDate : TDateTime;
const
  BDate = 41424;
  Hour = 02;
  Min = 18;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TDelphiDpr.GetVersion : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TDelphiDpr.GetVersionStr : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TDelphiDpr.GetVersionInfo : AnsiString;
begin
  Result := 'Comment: Parses Delphi DPR files.' + #13#10 +
'Author: Martin Harvey' + #13#10 +
'Copyright: (c) Martin Harvey';
end;

procedure TDelphiDpr.SetVersion(const Value : AnsiString);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TDelphiDpr.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_DelphiDpr;
end;  {Parse}

procedure TDelphiDpr.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
end; {InitSymSet}

end { DelphiDpr }.    
