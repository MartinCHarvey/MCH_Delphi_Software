unit -->Grammar<--;
/* Component frame file (code template) for use with with Coco/R for Delphi.
   For use with version xxxxxxxx
*/

{==============================================================================
-->Grammar<--
-->GrammarVersion<--
Date of Generation: -->GrammarVersionLastBuild<--
-->GrammarVersionInfo<--

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface

/% Uses (Interface) SysUtils, Classes, CocoBase %/

const
  -->DelphiConst<--
  -->constants<--
type
  -->DelphiType<--
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  E-->Grammar<-- = class(Exception);
  T-->Grammar<-- = class;

  -->OnHomographEvent<--
  T-->Scanner<-- = class(TCocoRScanner)
  private
    FOwner : T-->Grammar<--;
    -->ScannerCommentField<--
    -->ScannerHashField<--
    -->OnHomographField<--
    -->LiteralSupportDecl<--
    -->ScannerComment<--
  protected
    procedure NextCh; override;
  public
    constructor Create;
    -->ScannerDestroyDecl<--

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : T-->Grammar<-- read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
    -->OnHomographProperty<--
  end;  { T-->Scanner<-- }

  T-->Grammar<-- = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..-->Max<--] of SymbolSet; // symSet[0] = allSyncSyms
    -->GrammarCommentField<--

    -->VersionMethods<--
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;
    -->WeakMethods<--

    {Production methods}
    -->ProductionsDec<--
    -->DelphiPrivate<--
    -->DelphiProtected<--
  protected
    { Protected Declarations }
    procedure Get; override;
    -->GrammarCommentProperty<--
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString; override;
    procedure Execute; override;
    function GetScanner : T-->Scanner<--;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    -->VersionProperties<--

    -->DelphiPublic<--
    -->DelphiPublished<--
  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    -->VersionString<--

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { T-->Grammar<-- }

implementation

/% Uses (Implementation) %/

-->const<--
  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
-->ArbitraryCode<--

{ --------------------------------------------------------------------------- }
{ ---- implementation for T-->Scanner<-- ---- }

procedure T-->Scanner<--.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

-->Comment<--

-->LiteralSupport<--

procedure T-->Scanner<--.Get(var sym : integer);
var
  state : integer;
  label __start_get;
 begin   {Get}
__start_get:
  -->GetSyA<--

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
      -->GetSyB<--
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor T-->Scanner<--.Create;
begin
  inherited;
  -->ScannerInit<--
end; {Create}

-->ScannerDestroyImpl<--

{ --------------------------------------------------------------------------- }
{ ---- implementation for T-->Grammar<-- ---- }

constructor T-->Grammar<--.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := T-->Scanner<--.Create;
  GetScanner.Owner := self;
  -->DelphiCreate<--
  InitSymSet;
end; {Create}

destructor T-->Grammar<--.Destroy;
begin
  Scanner.Free;
  -->DelphiDestroy<--
  inherited;
end; {Destroy}

function T-->Grammar<--.ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString;
begin
  case ErrorCode of
    -->Errors<--
    -->DelphiErrors<--
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := AnsiString('Error: ' + AnsiString(IntToStr(ErrorCode)));
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure T-->Grammar<--.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;
  StreamPartRead := -1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure T-->Grammar<--.Get;
begin
  repeat

    -->GrammarGetComment<--

    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
      -->pragmas<--
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function T-->Grammar<--.GetScanner : T-->Scanner<--;
begin
  Result := Scanner AS T-->Scanner<--;
end; {GetScanner}

function T-->Grammar<--._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

-->WeakImpl<--
-->ProductionsBody<--
-->VersionImpl<--

procedure T-->Grammar<--.Parse;
begin
  errDist := minErrDist;
  -->ParseRoot<--
end;  {Parse}

procedure T-->Grammar<--.InitSymSet;
begin
  -->ParserInit<--
end; {InitSymSet}

end { -->Grammar<-- }.

