unit Coco;




{==============================================================================
Coco
0.0.0.0
Date of Generation: 25/10/2019 07:49

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,CRT,CRA,CRTypes,CocoOptions,CocoSwitch,CocoDefs,Dialogs,mwStringHashList;



const
maxT = 70;
maxP = 71;
type
TTokenObj = class(TObject)
    private
      fIsPragma : boolean;
      fIndex : integer;
      fPosition : TSymbolPosition;
    public
      constructor Create;
      destructor Destroy; override;
      property IsPragma : boolean read fIsPragma write fIsPragma;
      property Index : integer read fIndex write fIndex;
      property Position : TSymbolPosition read fPosition write fPosition;
    end; //TTokenObj

  SymbolSet = array[0..maxT div setsize] of TBitSet;

  ECoco = class(Exception);
  TCoco = class;

  TCocoScanner = class(TCocoRScanner)
  private
    FOwner : TCoco;
fHashList: TmwStringHashList;
function CharInIgnoreSet(const Ch : AnsiChar) : boolean;
procedure CheckLiteral(var Sym : integer);
function GetNextSymbolString: AnsiString;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
destructor Destroy; override;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TCoco read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TCocoScanner }

  TCoco = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..21] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : AnsiString;
    function GetVersionStr : AnsiString;
    procedure SetVersion(const Value : AnsiString);
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;
function WeakSeparator(n, syFol, repFol : integer) : boolean;
procedure ExpectWeak(n, follow : integer);

    {Production methods}
    procedure _CocoOption;
    procedure _TokenFactor (var gL, gR: INTEGER);
    procedure _TokenTerm (var gL, gR: INTEGER);
    procedure _SimpleMethodCall (out BooleanFunction : AnsiString);
    procedure _IfStatement (var gL, gR: INTEGER);
    procedure _Factor (var gL, gR: INTEGER);
    procedure _Term (var gL, gR: INTEGER);
    procedure _Symbol (var name: CRTName; var kind: INTEGER; var HGType : THomographType);
    procedure _SingleChar (var n: INTEGER);
    procedure _SimSet (var oneSet: CRTSet);
    procedure _Set (var oneSet: CRTSet);
    procedure _TokenExpr (var gL, gR: INTEGER);
    procedure _NameDecl;
    procedure _TokenDecl (typ: INTEGER);
    procedure _SetDecl;
    procedure _DelphiSourceParts;
    procedure _UsesClause;
    procedure _Expression (var gL, gR: INTEGER);
    procedure _SemText (var semPos: CRTPosition);
    procedure _Description (var sn : CRTSymbolNode);
    procedure _Attribs (var attrPos: CRTPosition);
    procedure _Declaration (var startedDFA : boolean);
    procedure _DelphiSection;
    procedure _Ident (var name: CRTName);
    procedure _CocoOptionList;
    procedure _Coco;

  private
    FOutput : TStringList;
    FLL1Count : integer;
    FLL1TestConducted : boolean;
    FGrammarCount : integer;
    FWarningCount : integer;
    FErrorCount : integer;
    FErrorCnt : integer;
    fCRAbortErr : AnsiString;
    fTokenList : TStringList;
    fTableHandler: TTableHandler;
    fAutomaton: TAutomaton;
    fOptions: TCocoOptions;
    fOnInsertComment: TInsertCommentAtTop;

    procedure FixString (var name: AnsiString; len: integer);
    function RemoveQuotes(const S : AnsiString) : AnsiString;
    procedure MatchLiteral (sp: integer);
    procedure SetCtx (gp: integer);
    function ValidOptionParams(Op : TCocoSwitch;
        OptionState : boolean; ParamList : TStringList) : boolean;
    procedure SetOption(const OptionName: AnsiString; OptionState : boolean;
        ParamList : TStringList);
    procedure OptionsModify(Op : TCocoSwitch; AddOption : boolean);
    procedure ClearTokenList;
    procedure SetOptions(const Value: TCocoOptions);
    procedure SetCRAbortErr(const Value: AnsiString);
    function GetErrorData(const Token1 : integer; const Token2 : integer) : AnsiString;
    procedure InDistinguishedError(const Token : integer; const Data : AnsiString);
    function GetTokenIndex(const sp : integer) : integer;

  protected
    function GetSuccessful: boolean; override;

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString; override;
    procedure Execute; override;
    function GetScanner : TCocoScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : AnsiString read GetVersionStr;

  public
    procedure ResetCocoR;
    procedure PrintDivider;
    procedure Msg(S : AnsiString; Output : TStrings);
    function GetCharAt(BufferPosition: int64): AnsiChar;
    function GetCurrentSymbol: TSymbolPosition;
    procedure GetScannerError(const ErrorCode: integer;
        const Symbol: TSymbolPosition; const Data: AnsiString;
        const ErrorType: integer);

    property Output : TStringList read FOutput write FOutput;
    property ErrorCount : integer read FErrorCount write FErrorCount;
    property LL1Count : integer read FLL1Count write FLL1Count;
    property LL1TestConducted : boolean read fLL1TestConducted write fLL1TestConducted;
    property GrammarCount : integer read FGrammarCount write FGrammarCount;
    property WarningCount : integer read FWarningCount write FWarningCount;

    property ErrorCnt : integer read fErrorCnt write FErrorCnt;
    property CRAbortErr : AnsiString read fCRAbortErr write fCRAbortErr;
    property TokenList : TStringList read fTokenList;

    property TableHandler : TTableHandler read fTableHandler write fTableHandler;
    property Automaton : TAutomaton read fAutomaton write fAutomaton;
    property Options : TCocoOptions read fOptions write SetOptions;
    property OnInsertComment : TInsertCommentAtTop read fOnInsertComment
        write fOnInsertComment; 

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : AnsiString read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TCoco }

implementation
uses  Sets;



const

  EOFSYMB = 0;  identSym = 1;  stringSym = 2;  badstringSym = 3;
  integer_Sym = 4;  COMPILERSym = 5;  PRODUCTIONSSym = 6;  _equalSym = 7;
  _pointSym = 8;  ENDSym = 9;  DELPHISym = 10;  END_underscoreDELPHISym = 11;
  CONSTSym = 12;  TYPESym = 13;  PRIVATESym = 14;  PROTECTEDSym = 15;
  PUBLICSym = 16;  PUBLISHEDSym = 17;  ERRORSSym = 18;  CREATESym = 19;
  DESTROYSym = 20;  USESSym = 21;  _lparenINTERFACE_rparenSym = 22;
  _lparenIMPLEMENTATION_rparenSym = 23;  _commaSym = 24;  CHARACTERSSym = 25;
  TOKENSSym = 26;  NAMESSym = 27;  PRAGMASSym = 28;  COMMENTSSym = 29;
  FROMSym = 30;  TOSym = 31;  NESTEDSym = 32;  IGNORESym = 33;  CASESym = 34;
  _plusSym = 35;  _minusSym = 36;  _point_pointSym = 37;  ANYSym = 38;
  NONESym = 39;  CHRSym = 40;  _lparenSym = 41;  _rparenSym = 42;
  DEFAULTSym = 43;  _barSym = 44;  ORSym = 45;  WEAKSym = 46;  BEGINSym = 47;
  _lbrackSym = 48;  _rbrackSym = 49;  OPTIONSym = 50;
  END_underscoreOPTIONSym = 51;  _lbraceSym = 52;  _rbraceSym = 53;
  REPEATSym = 54;  END_underscoreREPEATSym = 55;  SYNCSym = 56;  IFSym = 57;
  THENSym = 58;  ELSESym = 59;  CONTEXTSym = 60;  HOMOGRAPHSym = 61;
  _lessSym = 62;  _greaterSym = 63;  _less_pointSym = 64;
  _point_greaterSym = 65;  _lparen_pointSym = 66;  _point_rparenSym = 67;
  DESCRIPTIONSym = 68;  _dollarSym = 69;  NOSYMB = 70;
  CompilerDirectiveSym = 71;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
const
  _identSym = 0;   // symbol kinds 
  _stringSym = 1;   

constructor TTokenObj.Create;
begin
  inherited;
  fPosition := TSymbolPosition.Create;
end; {Create}

destructor TTokenObj.Destroy;
begin
  fPosition.Free;
  inherited;
end; {Destroy}
  
procedure TCoco.FixString(var name : AnsiString; len : integer);
var
  double, spaces : boolean;
  i : integer;
begin
  if len = 2 then
  begin
    SemError(129, '');
    exit;
  end;
  if fTableHandler.IgnoreCase then    // force uppercase 
    for i := 2 to len - 1 do
      name[i] := UpCase(name[i]);
  double := false;
  spaces := false;
  for i := 2 to len - 1 do   // search for interior " or spaces 
  begin
    if name[i] = '"' then
      double := true;
    if name[i] <= ' ' then
      spaces := true;
  end;
  if not double then  // force delimiters to be " quotes 
    name[1] := '"'; name[len] := '"';
  if spaces then SemError(124, '');
end; {FixString}

procedure TCoco.MatchLiteral(sp : integer);
// store string either as token or as literal 
var
  sn, sn1 : CRTSymbolNode;
  matchedSp : integer;
begin
  fTableHandler.GetSym(sp, sn);
  fAutomaton.MatchDFA(sn.name, sp, matchedSp);
  if matchedSp <> CRTnoSym then
  begin
    fTableHandler.GetSym(matchedSp, sn1);
    sn1.struct := CRTclassLitToken;
    fTableHandler.PutSym(matchedSp, sn1);
    sn.struct := CRTlitToken;
  end
  else
    sn.struct := CRTclassToken;
  fTableHandler.PutSym(sp, sn);
end; {MatchLiteral}

procedure TCoco.SetCtx(gp : integer);
// set transition code to contextTrans 
var
  gn : CRTGraphNode;
begin
  while gp > 0 do
  begin
    fTableHandler.GetNode(gp, gn);
    if (gn.typ = CRTchart) or (gn.typ = CRTchrclass) then
    begin 
      gn.p2 := contextTrans;
      fTableHandler.PutNode(gp, gn);
    end
    else if (gn.typ = CRTopt) or (gn.typ = CRTiter) then
      SetCtx(gn.p1)
    else if gn.typ = CRTalt then
    begin 
      SetCtx(gn.p1);
      SetCtx(gn.p2);
    end;
    gp := gn.next;
  end;
end; {SetCtx}

procedure TCoco.OptionsModify(Op : TCocoSwitch; AddOption : boolean);
begin
  if AddOption then
    fOptions.Switches.SwitchSet := fOptions.Switches.SwitchSet + [Op]
  else
    fOptions.Switches.SwitchSet := fOptions.Switches.SwitchSet - [Op];
end; {OptionsModify}

function TCoco.ValidOptionParams(Op : TCocoSwitch;
    OptionState : boolean; ParamList : TStringList) : boolean;
begin
  if OptionState then
  begin
    case Op of
      crsGenRegistration : Result := ParamList.Count = 1;
      crsUseHashFunctions : Result := ParamList.Count = 2;
      else
        Result := ParamList.Count = 0;
    end; {case}
  end
  else
    Result := ParamList.Count = 0;
end; {ValidOptionParams}

function TCoco.RemoveQuotes(const S : AnsiString) : AnsiString;
begin        
  if (S > '') AND (S[1] IN ['"', #39]) then
    Result := copy(S,2,Length(S) - 2)
  else
    Result := S;
end; {RemoveQuotes}

procedure TCoco.SetOption(const OptionName: AnsiString; OptionState : boolean;
    ParamList : TStringList);
var
  Op : TCocoSwitch;
begin
  if length(OptionName) > 1 then
    SemError(131,OptionName)
  else
  begin
     case OptionName[1] of 
      'A' : Op := crsTraceAutomaton;
      'B' : Op := crsAutoIncBuild;
      'C' : Op := crsGenTestProgram;
      'D' : Op := crsAppendSemiColon;
      'E' : Op := crsGenRegistration;
      'F' : Op := crsStartFollowSets;
      'G' : Op := crsPrintGraph;
      'H' : Op := crsUseHashFunctions;
      'I' : Op := crsTraceStartSets;
      'L' : Op := crsForceListing;
      'M' : Op := crsUseRichEdit;
      'O' : Op := crsGenCommentEvents;
      'R' : Op := crsDfmAsResource;
      'S' : Op := crsPrintSymbolTable;
      'T' : Op := crsGrammarTestsOnly;
      'V' : Op := crsGenVersionInfo;
      'W' : Op := crsSpaceAsWhitespace;
      'X' : Op := crsPrintXRef;  
      'Y' : Op := crsUseSameTextCompare;
      'Z' : Op := crsGenConsoleApp;
      else
      begin
        SemError(131, OptionName);
        Exit;
      end;
    end;  // case 
    if ValidOptionParams(Op, OptionState, ParamList) then
    begin
      OptionsModify(Op, OptionState);
      if (Op = crsGenRegistration) AND OptionState then
        fOptions.AGI.RegistrationPalette := RemoveQuotes(ParamList[0])
      else if (Op = crsUseHashFunctions) AND OptionState then
      begin
        fOptions.AGI.HashPrimary := RemoveQuotes(ParamList[0]); 
        fOptions.AGI.HashSecondary := RemoveQuotes(ParamList[1]); 
      end; 
    end
    else
      SemError(132,OptionName)
  end;
end; {SetOp}         

procedure TCoco.Msg(S : AnsiString;
  Output : TStrings);
begin
  Output.Add(S);
end; {Msg}

procedure TCoco.PrintDivider;
begin
  StreamToListFile('', TRUE);
  StreamToListFile('================================================================================', TRUE);
end; {PrintDivider}

procedure TCoco.ClearTokenList;
var
  i : integer;
begin
  for i := 0 to TokenList.Count - 1 do
    TokenList.Objects[i].Free;
  TokenList.Clear;
end; {ClearTokenList}

procedure TCoco.ResetCocoR;
begin
  ClearTokenList;
  ErrorCnt := 0;
  fLL1TestConducted := FALSE;
  CRAbortErr := '';
  Output.Clear;
end; {ResetCocoR}

procedure TCoco.SetOptions(const Value: TCocoOptions);
begin
  fOptions := Value;
  fTableHandler.SwitchSet := fOptions.Switches.SwitchSet;
end; {SetOptions}

procedure TCoco.GetScannerError(const ErrorCode: integer;
  const Symbol: TSymbolPosition; const Data: AnsiString;
  const ErrorType: integer);
begin
  GetScanner.ScannerError(ErrorCode, Symbol, Data, ErrorType);
end; {GetScannerError}

procedure TCoco.SetCRAbortErr(const Value: AnsiString);
var
  Error : TCocoError;
begin
  Error := TCocoError.Create;
  Error.ErrorType := etMetaError;
  Error.ErrorCode := META_ERROR_ABORT_ERROR;
  Error.Line := 0;
  Error.Col := 0;
  Error.Data := Value;
  ErrorList.Add(Error);
  fCRAbortErr := Value;
end; {SetCRAbortErr}

function TCoco.GetCurrentSymbol: TSymbolPosition;
begin
  Result := GetScanner.CurrentSymbol;
end; {GetCurrentSymbol}

function TCoco.GetErrorData(const Token1 : integer; const Token2 : integer) : AnsiString;
var
  Token1Index : integer;
  Token2Index : integer;
begin
  {TODO: Obtain information on where the first token is}
  Token1Index := GetTokenIndex(Token1);
  Token2Index := GetTokenIndex(Token2);
  if TTokenObj(TokenList.Objects[Token1Index]).IsPragma then
    Result := 'Pragma (' + TokenList[Token1Index] + ') and '
  else
    Result := 'Token (' + TokenList[Token1Index] + ') and ';
  if TTokenObj(TokenList.Objects[Token2Index]).IsPragma then
    Result := Result + 'Pragma (' + TokenList[Token2Index] + ')'
  else
    Result := Result + 'Token (' + TokenList[Token2Index] + ')';
end; {GetErrorData}

procedure TCoco.InDistinguishedError(const Token : integer; const Data : AnsiString);
var
  TokenIdx : integer;
  Position : TSymbolPosition;
begin
  Position := TSymbolPosition.Create;
  try
    TokenIdx := GetTokenIndex(Token);
    TTokenObj(TokenList.Objects[TokenIdx]).Position.Assign(Position);
    Position.Col := 0;
    GetScanner.ScannerError(154, Position, Data, etGrammar);
  finally
    FreeAndNIL(Position);
  end;
end; {InDistinguishedError}

function TCoco.GetTokenIndex(const sp : integer) : integer;
var
  i : integer;
begin
  Result := 0;
  for i := 0 to TokenList.Count - 1 do
  begin
    if TTokenObj(TokenList.Objects[i]).Index = sp then
    begin
      Result := i;
      Break;
    end;
  end;
end; {GetTokenIndex}

function TCoco.GetCharAt(BufferPosition: int64): AnsiChar;
begin
  Result := GetScanner.CharAt(BufferPosition);
end; {GetCharAt}

function TCoco.GetSuccessful: boolean;
var
  i : integer;
begin
  {Don't call inherited}
  Result := TRUE;
  for i := 0 to ErrorList.Count - 1 do
    if TCocoError(ErrorList[i]).ErrorType IN [etGrammar, etGeneration] then
    begin
      Result := FALSE;
      Break;  {@Break for speed}
    end;
end; {GetSuccessful}

(*----------------------------------------------------------------------------*)



{ --------------------------------------------------------------------------- }
{ ---- implementation for TCocoScanner ---- }

procedure TCocoScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TCocoScanner.Comment : boolean;
var
  level : integer;
  StartCommentCh: AnsiChar;
  startLine : integer;
  oldLineStart : longint;
  CommentStr : AnsiString;
begin
StartCommentCh := CurrInputCh;
  level := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = AnsiChar(13)) then
begin
level := level -  1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
level := level -  1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
Result := false;
if (CurrInputCh = '(') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = ')') then
begin
level := level -  1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
end
else if (CurrInputCh = '(') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
 if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
level := level + 1;
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
end;  { Comment }

function TCocoScanner.CharInIgnoreSet(const Ch : AnsiChar) : boolean;
begin
Result := (Ch = ' ')    OR
((CurrInputCh >= AnsiChar(9)) AND (CurrInputCh <= AnsiChar(10)) OR
(CurrInputCh = AnsiChar(13)));
end; {CharInIgnoreSet}

function TCocoScanner.GetNextSymbolString: AnsiString;
var
  i: integer;
  q: int64;
begin
  Result := '';
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    inc(q);
    inc(i);
  end;
end; {GetNextSymbolString}

procedure TCocoScanner.CheckLiteral(var Sym : integer);
var
  SymId : integer;
  DefaultSymId : integer;
  aToken : AnsiString;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
      sym := SymId;
  end;
end; {CheckLiteral}


procedure TCocoScanner.Get(var sym : integer);
var
  state : integer;
  label __start_get;
 begin   {Get}
__start_get:
while CharInIgnoreSet(CurrInputCh) do
  NextCh;
if ((CurrInputCh = '/') OR (CurrInputCh = '/') OR (CurrInputCh = '(')) AND Comment then goto __start_get;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
sym := identSym;
CheckLiteral(sym);
exit;
end;
   2: begin
sym := stringSym;
exit;
end;
   3: begin
sym := badstringSym;
exit;
end;
   4: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else
begin
sym := integer_Sym;
exit;
end;
   5: if (CurrInputCh = '$') then
begin
state := 6; 
end
else
begin
sym := _lbrackSym;
exit;
end;
   6: if NOT ((CurrInputCh = AnsiChar(13))) then
begin
state := 7; 
end
else
begin
  sym := _noSym;
exit;
end;
   7: if (CurrInputCh = ']') then
begin
state := 8; 
end
else
begin
  sym := _noSym;
exit;
end;
   8: begin
sym := CompilerDirectiveSym;
exit;
end;
   9: if ((CurrInputCh = AnsiChar(0)) OR
(CurrInputCh >= ' ') AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#')) then
begin
 
end
else if ((CurrInputCh = AnsiChar(10)) OR
(CurrInputCh = AnsiChar(13))) then
begin
state := 3; 
end
else if (CurrInputCh = '"') then
begin
state := 2; 
end
else
begin
  sym := _noSym;
exit;
end;
  10: if ((CurrInputCh = AnsiChar(0)) OR
(CurrInputCh >= ' ') AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(')) then
begin
 
end
else if ((CurrInputCh = AnsiChar(10)) OR
(CurrInputCh = AnsiChar(13))) then
begin
state := 3; 
end
else if (CurrInputCh = AnsiChar(39)) then
begin
state := 2; 
end
else
begin
  sym := _noSym;
exit;
end;
  11: begin
sym := _equalSym;
exit;
end;
  12: if (CurrInputCh = '.') then
begin
state := 41; 
end
else if (CurrInputCh = '>') then
begin
state := 50; 
end
else if (CurrInputCh = ')') then
begin
state := 52; 
end
else
begin
sym := _pointSym;
exit;
end;
  13: if (CurrInputCh = 'I') then
begin
state := 14; 
end
else if (CurrInputCh = '.') then
begin
state := 51; 
end
else
begin
sym := _lparenSym;
exit;
end;
  14: if (CurrInputCh = 'N') then
begin
state := 15; 
end
else if (CurrInputCh = 'M') then
begin
state := 24; 
end
else
begin
  sym := _noSym;
exit;
end;
  15: if (CurrInputCh = 'T') then
begin
state := 16; 
end
else
begin
  sym := _noSym;
exit;
end;
  16: if (CurrInputCh = 'E') then
begin
state := 17; 
end
else
begin
  sym := _noSym;
exit;
end;
  17: if (CurrInputCh = 'R') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  18: if (CurrInputCh = 'F') then
begin
state := 19; 
end
else
begin
  sym := _noSym;
exit;
end;
  19: if (CurrInputCh = 'A') then
begin
state := 20; 
end
else
begin
  sym := _noSym;
exit;
end;
  20: if (CurrInputCh = 'C') then
begin
state := 21; 
end
else
begin
  sym := _noSym;
exit;
end;
  21: if (CurrInputCh = 'E') then
begin
state := 22; 
end
else
begin
  sym := _noSym;
exit;
end;
  22: if (CurrInputCh = ')') then
begin
state := 23; 
end
else
begin
  sym := _noSym;
exit;
end;
  23: begin
sym := _lparenINTERFACE_rparenSym;
exit;
end;
  24: if (CurrInputCh = 'P') then
begin
state := 25; 
end
else
begin
  sym := _noSym;
exit;
end;
  25: if (CurrInputCh = 'L') then
begin
state := 26; 
end
else
begin
  sym := _noSym;
exit;
end;
  26: if (CurrInputCh = 'E') then
begin
state := 27; 
end
else
begin
  sym := _noSym;
exit;
end;
  27: if (CurrInputCh = 'M') then
begin
state := 28; 
end
else
begin
  sym := _noSym;
exit;
end;
  28: if (CurrInputCh = 'E') then
begin
state := 29; 
end
else
begin
  sym := _noSym;
exit;
end;
  29: if (CurrInputCh = 'N') then
begin
state := 30; 
end
else
begin
  sym := _noSym;
exit;
end;
  30: if (CurrInputCh = 'T') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  31: if (CurrInputCh = 'A') then
begin
state := 32; 
end
else
begin
  sym := _noSym;
exit;
end;
  32: if (CurrInputCh = 'T') then
begin
state := 33; 
end
else
begin
  sym := _noSym;
exit;
end;
  33: if (CurrInputCh = 'I') then
begin
state := 34; 
end
else
begin
  sym := _noSym;
exit;
end;
  34: if (CurrInputCh = 'O') then
begin
state := 35; 
end
else
begin
  sym := _noSym;
exit;
end;
  35: if (CurrInputCh = 'N') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  36: if (CurrInputCh = ')') then
begin
state := 37; 
end
else
begin
  sym := _noSym;
exit;
end;
  37: begin
sym := _lparenIMPLEMENTATION_rparenSym;
exit;
end;
  38: begin
sym := _commaSym;
exit;
end;
  39: begin
sym := _plusSym;
exit;
end;
  40: begin
sym := _minusSym;
exit;
end;
  41: begin
sym := _point_pointSym;
exit;
end;
  42: begin
sym := _rparenSym;
exit;
end;
  43: begin
sym := _barSym;
exit;
end;
  44: begin
sym := _rbrackSym;
exit;
end;
  45: begin
sym := _lbraceSym;
exit;
end;
  46: begin
sym := _rbraceSym;
exit;
end;
  47: if (CurrInputCh = '.') then
begin
state := 49; 
end
else
begin
sym := _lessSym;
exit;
end;
  48: begin
sym := _greaterSym;
exit;
end;
  49: begin
sym := _less_pointSym;
exit;
end;
  50: begin
sym := _point_greaterSym;
exit;
end;
  51: begin
sym := _lparen_pointSym;
exit;
end;
  52: begin
sym := _point_rparenSym;
exit;
end;
  53: begin
sym := _dollarSym;
exit;
end;
  54: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TCocoScanner.Create;
begin
  inherited;
fHashList := TmwStringHashList.Create(TinyHash, HashSecondaryOne, HashCompare);
fHashList.AddString('ANY', ANYSym, ANYSym);
fHashList.AddString('BEGIN', BEGINSym, BEGINSym);
fHashList.AddString('CASE', CASESym, CASESym);
fHashList.AddString('CHARACTERS', CHARACTERSSym, CHARACTERSSym);
fHashList.AddString('CHR', CHRSym, CHRSym);
fHashList.AddString('COMMENTS', COMMENTSSym, COMMENTSSym);
fHashList.AddString('COMPILER', COMPILERSym, COMPILERSym);
fHashList.AddString('CONST', CONSTSym, CONSTSym);
fHashList.AddString('CONTEXT', CONTEXTSym, CONTEXTSym);
fHashList.AddString('CREATE', CREATESym, CREATESym);
fHashList.AddString('DEFAULT', DEFAULTSym, DEFAULTSym);
fHashList.AddString('DELPHI', DELPHISym, DELPHISym);
fHashList.AddString('DESCRIPTION', DESCRIPTIONSym, DESCRIPTIONSym);
fHashList.AddString('DESTROY', DESTROYSym, DESTROYSym);
fHashList.AddString('ELSE', ELSESym, ELSESym);
fHashList.AddString('END', ENDSym, ENDSym);
fHashList.AddString('END_DELPHI', END_underscoreDELPHISym, END_underscoreDELPHISym);
fHashList.AddString('END_OPTION', END_underscoreOPTIONSym, END_underscoreOPTIONSym);
fHashList.AddString('END_REPEAT', END_underscoreREPEATSym, END_underscoreREPEATSym);
fHashList.AddString('ERRORS', ERRORSSym, ERRORSSym);
fHashList.AddString('FROM', FROMSym, FROMSym);
fHashList.AddString('HOMOGRAPH', HOMOGRAPHSym, HOMOGRAPHSym);
fHashList.AddString('IF', IFSym, IFSym);
fHashList.AddString('IGNORE', IGNORESym, IGNORESym);
fHashList.AddString('NAMES', NAMESSym, NAMESSym);
fHashList.AddString('NESTED', NESTEDSym, NESTEDSym);
fHashList.AddString('NONE', NONESym, NONESym);
fHashList.AddString('OPTION', OPTIONSym, OPTIONSym);
fHashList.AddString('OR', ORSym, ORSym);
fHashList.AddString('PRAGMAS', PRAGMASSym, PRAGMASSym);
fHashList.AddString('PRIVATE', PRIVATESym, PRIVATESym);
fHashList.AddString('PRODUCTIONS', PRODUCTIONSSym, PRODUCTIONSSym);
fHashList.AddString('PROTECTED', PROTECTEDSym, PROTECTEDSym);
fHashList.AddString('PUBLIC', PUBLICSym, PUBLICSym);
fHashList.AddString('PUBLISHED', PUBLISHEDSym, PUBLISHEDSym);
fHashList.AddString('REPEAT', REPEATSym, REPEATSym);
fHashList.AddString('SYNC', SYNCSym, SYNCSym);
fHashList.AddString('THEN', THENSym, THENSym);
fHashList.AddString('TO', TOSym, TOSym);
fHashList.AddString('TOKENS', TOKENSSym, TOKENSSym);
fHashList.AddString('TYPE', TYPESym, TYPESym);
fHashList.AddString('USES', USESSym, USESSym);
fHashList.AddString('WEAK', WEAKSym, WEAKSym);
CurrentCh := CharAt;
fStartState[  0] := 54; fStartState[  1] := 55; fStartState[  2] := 55; fStartState[  3] := 55; 
fStartState[  4] := 55; fStartState[  5] := 55; fStartState[  6] := 55; fStartState[  7] := 55; 
fStartState[  8] := 55; fStartState[  9] := 55; fStartState[ 10] := 55; fStartState[ 11] := 55; 
fStartState[ 12] := 55; fStartState[ 13] := 55; fStartState[ 14] := 55; fStartState[ 15] := 55; 
fStartState[ 16] := 55; fStartState[ 17] := 55; fStartState[ 18] := 55; fStartState[ 19] := 55; 
fStartState[ 20] := 55; fStartState[ 21] := 55; fStartState[ 22] := 55; fStartState[ 23] := 55; 
fStartState[ 24] := 55; fStartState[ 25] := 55; fStartState[ 26] := 55; fStartState[ 27] := 55; 
fStartState[ 28] := 55; fStartState[ 29] := 55; fStartState[ 30] := 55; fStartState[ 31] := 55; 
fStartState[ 32] := 55; fStartState[ 33] := 55; fStartState[ 34] :=  9; fStartState[ 35] := 55; 
fStartState[ 36] := 53; fStartState[ 37] := 55; fStartState[ 38] := 55; fStartState[ 39] := 10; 
fStartState[ 40] := 13; fStartState[ 41] := 42; fStartState[ 42] := 55; fStartState[ 43] := 39; 
fStartState[ 44] := 38; fStartState[ 45] := 40; fStartState[ 46] := 12; fStartState[ 47] := 55; 
fStartState[ 48] :=  4; fStartState[ 49] :=  4; fStartState[ 50] :=  4; fStartState[ 51] :=  4; 
fStartState[ 52] :=  4; fStartState[ 53] :=  4; fStartState[ 54] :=  4; fStartState[ 55] :=  4; 
fStartState[ 56] :=  4; fStartState[ 57] :=  4; fStartState[ 58] := 55; fStartState[ 59] := 55; 
fStartState[ 60] := 47; fStartState[ 61] := 11; fStartState[ 62] := 48; fStartState[ 63] := 55; 
fStartState[ 64] := 55; fStartState[ 65] :=  1; fStartState[ 66] :=  1; fStartState[ 67] :=  1; 
fStartState[ 68] :=  1; fStartState[ 69] :=  1; fStartState[ 70] :=  1; fStartState[ 71] :=  1; 
fStartState[ 72] :=  1; fStartState[ 73] :=  1; fStartState[ 74] :=  1; fStartState[ 75] :=  1; 
fStartState[ 76] :=  1; fStartState[ 77] :=  1; fStartState[ 78] :=  1; fStartState[ 79] :=  1; 
fStartState[ 80] :=  1; fStartState[ 81] :=  1; fStartState[ 82] :=  1; fStartState[ 83] :=  1; 
fStartState[ 84] :=  1; fStartState[ 85] :=  1; fStartState[ 86] :=  1; fStartState[ 87] :=  1; 
fStartState[ 88] :=  1; fStartState[ 89] :=  1; fStartState[ 90] :=  1; fStartState[ 91] :=  5; 
fStartState[ 92] := 55; fStartState[ 93] := 44; fStartState[ 94] := 55; fStartState[ 95] :=  1; 
fStartState[ 96] := 55; fStartState[ 97] :=  1; fStartState[ 98] :=  1; fStartState[ 99] :=  1; 
fStartState[100] :=  1; fStartState[101] :=  1; fStartState[102] :=  1; fStartState[103] :=  1; 
fStartState[104] :=  1; fStartState[105] :=  1; fStartState[106] :=  1; fStartState[107] :=  1; 
fStartState[108] :=  1; fStartState[109] :=  1; fStartState[110] :=  1; fStartState[111] :=  1; 
fStartState[112] :=  1; fStartState[113] :=  1; fStartState[114] :=  1; fStartState[115] :=  1; 
fStartState[116] :=  1; fStartState[117] :=  1; fStartState[118] :=  1; fStartState[119] :=  1; 
fStartState[120] :=  1; fStartState[121] :=  1; fStartState[122] :=  1; fStartState[123] := 45; 
fStartState[124] := 43; fStartState[125] := 46; fStartState[126] := 55; fStartState[127] := 55; 
fStartState[128] := 55; fStartState[129] := 55; fStartState[130] := 55; fStartState[131] := 55; 
fStartState[132] := 55; fStartState[133] := 55; fStartState[134] := 55; fStartState[135] := 55; 
fStartState[136] := 55; fStartState[137] := 55; fStartState[138] := 55; fStartState[139] := 55; 
fStartState[140] := 55; fStartState[141] := 55; fStartState[142] := 55; fStartState[143] := 55; 
fStartState[144] := 55; fStartState[145] := 55; fStartState[146] := 55; fStartState[147] := 55; 
fStartState[148] := 55; fStartState[149] := 55; fStartState[150] := 55; fStartState[151] := 55; 
fStartState[152] := 55; fStartState[153] := 55; fStartState[154] := 55; fStartState[155] := 55; 
fStartState[156] := 55; fStartState[157] := 55; fStartState[158] := 55; fStartState[159] := 55; 
fStartState[160] := 55; fStartState[161] := 55; fStartState[162] := 55; fStartState[163] := 55; 
fStartState[164] := 55; fStartState[165] := 55; fStartState[166] := 55; fStartState[167] := 55; 
fStartState[168] := 55; fStartState[169] := 55; fStartState[170] := 55; fStartState[171] := 55; 
fStartState[172] := 55; fStartState[173] := 55; fStartState[174] := 55; fStartState[175] := 55; 
fStartState[176] := 55; fStartState[177] := 55; fStartState[178] := 55; fStartState[179] := 55; 
fStartState[180] := 55; fStartState[181] := 55; fStartState[182] := 55; fStartState[183] := 55; 
fStartState[184] := 55; fStartState[185] := 55; fStartState[186] := 55; fStartState[187] := 55; 
fStartState[188] := 55; fStartState[189] := 55; fStartState[190] := 55; fStartState[191] := 55; 
fStartState[192] := 55; fStartState[193] := 55; fStartState[194] := 55; fStartState[195] := 55; 
fStartState[196] := 55; fStartState[197] := 55; fStartState[198] := 55; fStartState[199] := 55; 
fStartState[200] := 55; fStartState[201] := 55; fStartState[202] := 55; fStartState[203] := 55; 
fStartState[204] := 55; fStartState[205] := 55; fStartState[206] := 55; fStartState[207] := 55; 
fStartState[208] := 55; fStartState[209] := 55; fStartState[210] := 55; fStartState[211] := 55; 
fStartState[212] := 55; fStartState[213] := 55; fStartState[214] := 55; fStartState[215] := 55; 
fStartState[216] := 55; fStartState[217] := 55; fStartState[218] := 55; fStartState[219] := 55; 
fStartState[220] := 55; fStartState[221] := 55; fStartState[222] := 55; fStartState[223] := 55; 
fStartState[224] := 55; fStartState[225] := 55; fStartState[226] := 55; fStartState[227] := 55; 
fStartState[228] := 55; fStartState[229] := 55; fStartState[230] := 55; fStartState[231] := 55; 
fStartState[232] := 55; fStartState[233] := 55; fStartState[234] := 55; fStartState[235] := 55; 
fStartState[236] := 55; fStartState[237] := 55; fStartState[238] := 55; fStartState[239] := 55; 
fStartState[240] := 55; fStartState[241] := 55; fStartState[242] := 55; fStartState[243] := 55; 
fStartState[244] := 55; fStartState[245] := 55; fStartState[246] := 55; fStartState[247] := 55; 
fStartState[248] := 55; fStartState[249] := 55; fStartState[250] := 55; fStartState[251] := 55; 
fStartState[252] := 55; fStartState[253] := 55; fStartState[254] := 55; fStartState[255] := 55; 
end; {Create}

destructor TCocoScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  inherited;
end;

{ --------------------------------------------------------------------------- }
{ ---- implementation for TCoco ---- }

constructor TCoco.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TCocoScanner.Create;
  GetScanner.Owner := self;
fOutput := TStringList.Create;
    fTokenList := TStringList.Create;
    fTableHandler := TTableHandler.Create;
    fTableHandler.OnStreamLn := StreamToListFile;
    fTableHandler.OnPrintDivider := PrintDivider;
    fTableHandler.OnScannerError := GetScannerError;
    fTableHandler.OnErrorStr := ErrorStr;
    fTableHandler.OnAbortErrorMessage := SetCRAbortErr;
  
    fAutomaton := TAutomaton.Create;
    fAutomaton.TableHandler := fTableHandler;
    fAutomaton.OnStreamLn := StreamToListFile;
    fAutomaton.OnPrintDivider := PrintDivider;
    fAutomaton.OnScannerError := GetScannerError;
    fAutomaton.OnErrorStr := ErrorStr;
    fAutomaton.OnGetCurrentSymbol := GetCurrentSymbol;
    fAutomaton.OnGetErrorData := GetErrorData;
    fAutomaton.OnInDistinguishedError := InDistinguishedError;

  InitSymSet;
end; {Create}

destructor TCoco.Destroy;
begin
  Scanner.Free;
fOutput.Clear;
    fOutput.Free;     
    fOutput := NIL; 
    
    ClearTokenList;               
    fTokenList.Free;    
    fTokenList := NIL;

    fAutomaton.Finalize;
    fAutomaton.Free;
    fAutomaton := NIL;

    fTableHandler.Clear;
    fTableHandler.Free;
    fTableHandler := NIL;

  inherited;
end; {Destroy}

function TCoco.ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'identifier expected';
   2 : Result := 'string expected';
   3 : Result := 'bad string expected';
   4 : Result := 'integer expected';
   5 : Result := '"COMPILER" expected';
   6 : Result := '"PRODUCTIONS" expected';
   7 : Result := '"=" expected';
   8 : Result := '"." expected';
   9 : Result := '"END" expected';
  10 : Result := '"DELPHI" expected';
  11 : Result := '"END_DELPHI" expected';
  12 : Result := '"CONST" expected';
  13 : Result := '"TYPE" expected';
  14 : Result := '"PRIVATE" expected';
  15 : Result := '"PROTECTED" expected';
  16 : Result := '"PUBLIC" expected';
  17 : Result := '"PUBLISHED" expected';
  18 : Result := '"ERRORS" expected';
  19 : Result := '"CREATE" expected';
  20 : Result := '"DESTROY" expected';
  21 : Result := '"USES" expected';
  22 : Result := '"(INTERFACE)" expected';
  23 : Result := '"(IMPLEMENTATION)" expected';
  24 : Result := '"," expected';
  25 : Result := '"CHARACTERS" expected';
  26 : Result := '"TOKENS" expected';
  27 : Result := '"NAMES" expected';
  28 : Result := '"PRAGMAS" expected';
  29 : Result := '"COMMENTS" expected';
  30 : Result := '"FROM" expected';
  31 : Result := '"TO" expected';
  32 : Result := '"NESTED" expected';
  33 : Result := '"IGNORE" expected';
  34 : Result := '"CASE" expected';
  35 : Result := '"+" expected';
  36 : Result := '"-" expected';
  37 : Result := '".." expected';
  38 : Result := '"ANY" expected';
  39 : Result := '"NONE" expected';
  40 : Result := '"CHR" expected';
  41 : Result := '"(" expected';
  42 : Result := '")" expected';
  43 : Result := '"DEFAULT" expected';
  44 : Result := '"|" expected';
  45 : Result := '"OR" expected';
  46 : Result := '"WEAK" expected';
  47 : Result := '"BEGIN" expected';
  48 : Result := '"[" expected';
  49 : Result := '"]" expected';
  50 : Result := '"OPTION" expected';
  51 : Result := '"END_OPTION" expected';
  52 : Result := '"{" expected';
  53 : Result := '"}" expected';
  54 : Result := '"REPEAT" expected';
  55 : Result := '"END_REPEAT" expected';
  56 : Result := '"SYNC" expected';
  57 : Result := '"IF" expected';
  58 : Result := '"THEN" expected';
  59 : Result := '"ELSE" expected';
  60 : Result := '"CONTEXT" expected';
  61 : Result := '"HOMOGRAPH" expected';
  62 : Result := '"<" expected';
  63 : Result := '">" expected';
  64 : Result := '"<." expected';
  65 : Result := '".>" expected';
  66 : Result := '"(." expected';
  67 : Result := '".)" expected';
  68 : Result := '"DESCRIPTION" expected';
  69 : Result := '"$" expected';
  70 : Result := 'not expected';
  71 : Result := 'invalid Coco/R for Delphi option';
  72 : Result := 'invalid Coco/R for Delphi option';
  73 : Result := 'invalid token factor';
  74 : Result := 'invalid Coco/R factor';
  75 : Result := 'invalid Coco/R factor';
  76 : Result := 'invalid Coco/R term';
  77 : Result := 'invalid symbol';
  78 : Result := 'invalid single character';
  79 : Result := 'invalid simple set';
  80 : Result := 'invalid name declaration';
  81 : Result := 'this symbol not expected in token declaration';
  82 : Result := 'invalid token declaration';
  83 : Result := 'invalid Delphi source part';
  84 : Result := 'invalid uses clause';
  85 : Result := 'invalid Attributes';
  86 : Result := 'invalid Coco/R Declaration';
  87 : Result := 'invalid Coco/R Declaration';
  88 : Result := 'invalid Coco/R Declaration';
  89 : Result := 'this symbol not expected in Coco/R for Delphi grammar';
  90 : Result := 'invalid Coco/R for Delphi grammar';

102 : Result := 'string literal may not extend over line end';
    103 : Result := 'a literal must not have attributes';
    104 : Result := 'this symbol kind not allowed in production';
    105 : Result := 'attribute mismatch between declaration and use';
    106 : Result := 'undefined string in production';
    107 : Result := 'name declared twice';
    108 : Result := 'this type not allowed on left side of production';
    109 : Result := 'earlier semantic action was not terminated';
    111 : Result := 'missing production for grammar name';
    112 : Result := 'grammar symbol must not have attributes';
    113 : Result := 'a literal must not be declared with a structure';
    114 : Result := 'semantic action not allowed here';
    115 : Result := 'undefined name';
    116 : Result := 'attributes not allowed in token declaration';
    117 : Result := 'name does not match grammar name';
    118 : Result := 'unacceptable constant value';
    119 : Result := 'may not ignore CHR(0)';
    120 : Result := 'token may not be empty';
    121 : Result := 'token must not start with an iteration';
    122 : Result := 'only characters allowed in comment declaration';
    123 : Result := 'only terminals may be weak';
    124 : Result := 'literal tokens may not contain white space';
    125 : Result := 'comment delimiter must be 1 or 2 characters long';
    126 : Result := 'character set contains more than one character';
    127 : Result := 'could not make deterministic automaton';
    128 : Result := 'semantic action text too long - please split it';
    129 : Result := 'literal tokens may not be empty';
    130 : Result := 'IGNORE CASE must appear earlier';
    131 : Result := '"' + Data + '" is an invalid option'; 
    132 : Result := 'invalid modifiers for option "' + Data + '"';
    
    150 : Result := Data;
    151 : Result := 'only one ' + Data + ' allowed';
    152 : Result := 'could not generate ' + Data;
    153 : Result := 'only one "' + Data + '" Delphi code section allowed';
    154 : Result := Data + ' cannot be distinguished';
    155 : Result := 'only one "DEFAULT" token allowed';
    156 : Result := 'must have a "DEFAULT" token defined'; 
    157 : Result := 'The option "' + fOptions.Switches.SwitchString(crsUseHashFunctions)
              + '" must be enabled to use "HOMOGRAPH" and "DEFAULT" modifiers';

    158 : Result := 'Cannot have an ELSE statement in this location of an OPTION';
    159 : Result := 'Cannot have an IF statement as the first thing in a REPEAT';
    160 : Result := 'Cannot have a semantic action in this location';
        
    200 : Result := Data + ' is a deletable symbol';
    201 : Result := Data + ' is the start of several alternatives';
    202 : Result := Data + ' is the start & successor of a deletable structure';
    203 : Result := Data + ' is an ANY node that matches no symbol';
    204 : Result := Data + ' is an undefined nonterminal';
    205 : Result := Data + ' is an unreachable nonterminal';
    206 : Result := Data + ' is an underivable nonterminal';
    207 : Result := Data + ' is a circular derivation';

   1000 : Result := 'Abort Error: ' + Data;
   1001 : Result := 'Source not found';
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := AnsiString('Error: ' + AnsiString(IntToStr(ErrorCode)));
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TCoco.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;
  StreamPartRead := -1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TCoco.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
case fCurrentInputSymbol of
  CompilerDirectiveSym: begin  ShowMessage(LexString); 
 end;
end;
GetScanner.NextSymbol.Pos := GetScanner.CurrentSymbol.Pos;
GetScanner.NextSymbol.Col := GetScanner.CurrentSymbol.Col;
GetScanner.NextSymbol.Line := GetScanner.CurrentSymbol.Line;
GetScanner.NextSymbol.Len := GetScanner.CurrentSymbol.Len;
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TCoco.GetScanner : TCocoScanner;
begin
  Result := Scanner AS TCocoScanner;
end; {GetScanner}

function TCoco._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TCoco.ExpectWeak(n, follow : integer);
begin
  if fCurrentInputSymbol = n then
    Get
  else
  begin
    SynError(n);
    while (fCurrentInputSymbol > EOFSYMB) AND (not _In(symSet[follow], fCurrentInputSymbol)) do
      Get;
  end
end;  {ExpectWeak}

function TCoco.WeakSeparator(n, syFol, repFol : integer) : boolean;
var
  s : SymbolSet;
  i : integer;
begin
  if fCurrentInputSymbol = n then
  begin
    Get;
    Result := true;
    exit;
  end
  else if _In(symSet[repFol], fCurrentInputSymbol) then
  begin
    Result := false;
    exit;
  end
  else
  begin
    i := 0;
    while i <= maxT div setsize do
    begin
      s[i] := symSet[0, i] + symSet[syFol, i] + symSet[repFol, i];
      inc(i)
    end;
    SynError(n);
    while not _In(s, fCurrentInputSymbol) do
      Get;
    Result := _In(symSet[syFol], fCurrentInputSymbol)
  end
end;  {WeakSeparator}

procedure TCoco._CocoOption;var
   OptionName  :  AnsiString;
   OptionState  :  boolean;
   ParamList  :  TStringList;
begin
ParamList  :=  TStringList.Create;
try
Expect(_dollarSym);
Expect(identSym);
OptionName  :=  LexString;
if (fCurrentInputSymbol = _plusSym) then begin
Get;
end else if (fCurrentInputSymbol = _minusSym) then begin
Get;
end else begin SynError(71);
end;
OptionState  :=  LexName  =  '+';
if (fCurrentInputSymbol = identSym) OR
 (fCurrentInputSymbol = stringSym) then begin
if (fCurrentInputSymbol = identSym) then begin
Get;
end else begin
Get;
end;
ParamList.Add(LexString);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
if (fCurrentInputSymbol = identSym) then begin
Get;
end else if (fCurrentInputSymbol = stringSym) then begin
Get;
end else begin SynError(72);
end;
ParamList.Add(LexString);
end;
end;
SetOption(OptionName,  OptionState,  ParamList);
finally
   ParamList.Free;
end;
end;

procedure TCoco._TokenFactor (var  gL,  gR:  INTEGER);var
   kind  :  integer;
   c  :  integer;
   oneSet  :  CRTSet;
   name  :  CRTName;
   HGType  :  THomographType;

begin
gL  :=0;
gR  :=  0;
case fCurrentInputSymbol of
  identSym, stringSym, HOMOGRAPHSym : begin
_Symbol(name,  kind,  HGType);
if  kind  =  _identSym  then
begin
   c  :=  fTableHandler.ClassWithName(name);
   if  c  <  0  then
   begin
     SemError(115,'');
     Sets.Clear(oneSet);
     c  :=  fTableHandler.NewClass(name,  oneSet);
   end;
   gL  :=  fTableHandler.NewNode(CRTchrclass,  c,  0);
   gR  :=  gL
end
else  //  string
   fTableHandler.StrToGraph(name,  gL,  gR);
    end;
  _lparenSym : begin
Get;
_TokenExpr(gL,  gR);
Expect(_rparenSym);
    end;
  BEGINSym : begin
Get;
_TokenExpr(gL,  gR);
Expect(ENDSym);
    end;
  _lbrackSym : begin
Get;
_TokenExpr(gL,  gR);
Expect(_rbrackSym);
fTableHandler.MakeOption(gL,  gR);
    end;
  OPTIONSym : begin
Get;
_TokenExpr(gL,  gR);
Expect(END_underscoreOPTIONSym);
fTableHandler.MakeOption(gL,  gR);
    end;
  _lbraceSym : begin
Get;
_TokenExpr(gL,  gR);
Expect(_rbraceSym);
fTableHandler.MakeIteration(gL,  gR);
    end;
  REPEATSym : begin
Get;
_TokenExpr(gL,  gR);
Expect(END_underscoreREPEATSym);
fTableHandler.MakeIteration(gL,  gR);
    end;
else begin SynError(73);
    end;
end;
end;

procedure TCoco._TokenTerm (var  gL,  gR:  INTEGER);var
   gL2  :  integer;
   gR2  :  integer;
begin
_TokenFactor(gL,  gR);
while _In(symSet[1], fCurrentInputSymbol) do begin
_TokenFactor(gL2,  gR2);
fTableHandler.ConcatSeq(gL,  gR,  gL2,  gR2);
end;
if (fCurrentInputSymbol = CONTEXTSym) then begin
Get;
Expect(_lparenSym);
_TokenExpr(gL2,  gR2);
SetCtx(gL2);  fTableHandler.ConcatSeq(gL,  gR,  gL2,  gR2);
Expect(_rparenSym);
end;
end;

procedure TCoco._SimpleMethodCall (out  BooleanFunction  :  AnsiString);begin
Expect(identSym);
BooleanFunction  :=  LexString;
if (fCurrentInputSymbol = _lparenSym) then begin
Get;
BooleanFunction  :=  BooleanFunction  +  LexString;
Expect(identSym);
BooleanFunction  :=  BooleanFunction  +  LexString;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
BooleanFunction  :=  BooleanFunction  +  LexString;
Expect(identSym);
BooleanFunction  :=  BooleanFunction  +  LexString;
end;
Expect(_rparenSym);
BooleanFunction  :=  BooleanFunction  +  LexString;
end;
end;

procedure TCoco._IfStatement (var  gL,  gR:  INTEGER);var
   BooleanFunction  :  AnsiString;
   gn  :  CRTGraphNode;
   IfNode  :  integer;
   IfEnd  :  integer;
   ElseNode  :  integer;

begin
Expect(IFSym);
_SimpleMethodCall(BooleanFunction);
Expect(THENSym);
Expect(BEGINSym);
IfNode  :=  fTableHandler.NewNode(CRTif,  0,  0);
fTableHandler.GetNode(IfNode,  gn);
gn.BooleanFunction  :=  BooleanFunction;
fTableHandler.PutNode(IfNode,  gn);
_Expression(gL,gR);
fTableHandler.GetNode(IfNode,  gn);
gn.Next  :=  gL;
fTableHandler.PutNode(IfNode,  gn);
Expect(ENDSym);
IfEnd  :=  fTableHandler.NewNode(CRTendsc,  0,  0);
fTableHandler.GetNode(IfEnd,  gn);
gn.P1  :=  IfNode;
fTableHandler.PutNode(IfEnd,  gn);

fTableHandler.GetNode(IfNode,  gn);
gn.P1  :=  IfEnd;
fTableHandler.PutNode(IfNode,  gn);

fTableHandler.GetNode(gR,  gn);
gn.Next  :=  IfEnd;
fTableHandler.PutNode(gR,  gn);
gR  :=  IfEnd;
if (fCurrentInputSymbol = ELSESym) then begin
Get;
Expect(BEGINSym);
ElseNode  :=  fTableHandler.NewNode(CRTelse,  0,  0);
fTableHandler.GetNode(ElseNode,  gn);
gn.P1  :=  IfNode;
fTableHandler.PutNode(ElseNode,  gn);

fTableHandler.GetNode(IfNode,  gn);
gn.p2  :=  ElseNode;
fTableHandler.PutNode(IfNode,  gn);

fTableHandler.GetNode(IfEnd,  gn);
gn.Next  :=  ElseNode;
gn.typ  :=  CRTend;
fTableHandler.PutNode(IfEnd,  gn);
_Expression(gL,  gR);
fTableHandler.GetNode(ElseNode,  gn);
gn.Next  :=  gL;
fTableHandler.PutNode(ElseNode,  gn);
Expect(ENDSym);
IfEnd  :=  fTableHandler.NewNode(CRTendsc,  0,  0);
fTableHandler.GetNode(IfEnd,  gn);
gn.P1  :=  ElseNode;
fTableHandler.PutNode(IfEnd,  gn);

fTableHandler.GetNode(gR,  gn);
gn.Next  :=  IfEnd;
fTableHandler.PutNode(gR,  gn);
gR  :=  IfEnd;

end;
gL  :=  IfNode;  {the  letf  node  is  always  the  "if"  node}
end;

procedure TCoco._Factor (var  gL,  gR:  INTEGER);var
   sp  :  integer;
   kind  :  integer;
   name  :  CRTName;
   gn  :  CRTGraphNode;
   sn  :  CRTSymbolNode;
   oneSet  :  CRTSet;
   undef  :  boolean;
   weak  :  boolean;
   pos  :  CRTPosition;
   HGType  :  THomographType;

begin
gL  :=  0;
gR  :=  0;
weak  :=  FALSE;
case fCurrentInputSymbol of
  identSym, stringSym, WEAKSym, HOMOGRAPHSym : begin
if (fCurrentInputSymbol = WEAKSym) then begin
Get;
weak  :=  TRUE;
fTableHandler.HasWeak  :=  true;
end;
_Symbol(name,  kind,  HGType);
sp  :=  fTableHandler.FindSym(name);
undef  :=  sp  =  CRTnoSym;
if  undef  then
   if  kind  =  _identSym  then  (*  forward  nt  *)
     sp  :=  fTableHandler.NewSym(CRTnt,  name,  0)
   else  if  fTableHandler.GenScanner  then
   begin
     sp  :=  fTableHandler.NewSym(CRTt,  name,  GetScanner.CurrentSymbol.line);
     MatchLiteral(sp)
   end
   else
   begin  (*  undefined  string  in  production  *)
     SemError(106,'');  sp  :=  0
   end;
fTableHandler.GetSym(sp,  sn);
if  (sn.HomographType  =  htNone)  AND  (HGType  <>  htNone)  then
begin
   sn.HomographType  :=  HGType;
   fTableHandler.PutSym(sp,  sn);
end;
if  (sn.typ  <>  CRTt)  AND  (sn.typ  <>  CRTnt)  then
   SemError(104,'');
if  weak  then
   if  sn.typ  =  CRTt  then
     sn.typ  :=  CRTwt
   else
     SemError(123,'');
gL  :=  fTableHandler.NewNode(sn.typ,  sp,  GetScanner.CurrentSymbol.line);
gR  :=  gL;
if (fCurrentInputSymbol = _lessSym) OR
 (fCurrentInputSymbol = _less_pointSym) then begin
_Attribs(pos);
fTableHandler.GetNode(gL,  gn);
gn.pos  :=  pos;
fTableHandler.PutNode(gL,  gn);
fTableHandler.GetSym(sp,  sn);
if  sn.typ  <>  CRTnt  then
   SemError(103,'');
if  undef  then
begin
   sn.attrPos  :=  pos;
   fTableHandler.PutSym(sp,  sn)
end
else  if  sn.attrPos.beg  <  0  then
   SemError(105,'');
end else if _In(symSet[2], fCurrentInputSymbol) then begin
fTableHandler.GetSym(sp,  sn);
if  sn.attrPos.beg  >=  0  then
   SemError(105,'');
end else begin SynError(74);
end;
    end;
  IFSym : begin
_IfStatement(gL,  gR);
    end;
  _lparenSym : begin
Get;
_Expression(gL,  gR);
Expect(_rparenSym);
    end;
  BEGINSym : begin
Get;
_Expression(gL,  gR);
Expect(ENDSym);
    end;
  _lbrackSym : begin
Get;
_Expression(gL,  gR);
Expect(_rbrackSym);
fTableHandler.MakeOption(gL,  gR);
    end;
  OPTIONSym : begin
Get;
_Expression(gL,  gR);
Expect(END_underscoreOPTIONSym);
fTableHandler.MakeOption(gL,  gR);
    end;
  _lbraceSym : begin
Get;
_Expression(gL,  gR);
Expect(_rbraceSym);
fTableHandler.MakeIteration(gL,  gR);
    end;
  REPEATSym : begin
Get;
_Expression(gL,  gR);
Expect(END_underscoreREPEATSym);
fTableHandler.MakeIteration(gL,  gR);
    end;
  _lparen_pointSym : begin
_SemText(pos);
gL  :=  fTableHandler.NewNode(CRTsem,  0,  0);
gR  :=  gL;
fTableHandler.GetNode(gL,  gn);
gn.pos  :=  pos;
fTableHandler.PutNode(gL,  gn);
    end;
  ANYSym : begin
Get;
Sets.Fill(oneSet);
Sets.Excl(oneSet,  CRTeofSy);
gL  :=  fTableHandler.NewNode(CRTany,  fTableHandler.NewSet(oneSet),  0);
gR  :=  gL;
    end;
  SYNCSym : begin
Get;
gL  :=  fTableHandler.NewNode(CRTsync,  0,  0);
gR  :=  gL;
    end;
else begin SynError(75);
    end;
end;
end;

procedure TCoco._Term (var  gL,  gR:  INTEGER);var
   gL2  :  integer;
   gR2  :  integer;
begin
gL  :=  0;
gR  :=  0;
if _In(symSet[3], fCurrentInputSymbol) then begin
_Factor(gL,  gR);
while _In(symSet[3], fCurrentInputSymbol) do begin
_Factor(gL2,  gR2);
fTableHandler.ConcatSeq(gL,  gR,  gL2,  gR2);
end;
end else if _In(symSet[4], fCurrentInputSymbol) then begin
gL  :=  fTableHandler.NewNode(CRTeps,  0,  0);
gR  :=  gL;
end else begin SynError(76);
end;
end;

procedure TCoco._Symbol (var  name:  CRTName;  var  kind:  INTEGER;  var  HGType  :  THomographType);var
   myName  :  AnsiString;
begin
HGType  :=  htNone;
if (fCurrentInputSymbol = identSym) then begin
_Ident(name);
kind  :=  _identSym;
end else if (fCurrentInputSymbol = stringSym) OR
 (fCurrentInputSymbol = HOMOGRAPHSym) then begin
if (fCurrentInputSymbol = HOMOGRAPHSym) then begin
Get;
HGType  :=  htHomograph;
end;
Expect(stringSym);
myName  :=  Scanner.GetName(GetScanner.CurrentSymbol);
kind  :=  _stringSym;
FixString(myName,  GetScanner.CurrentSymbol.len);
name  :=  myName;
end else begin SynError(77);
end;
end;

procedure TCoco._SingleChar (var  n:  INTEGER);var
   i  :  integer;
   s  :  AnsiString;
begin
Expect(CHRSym);
Expect(_lparenSym);
if (fCurrentInputSymbol = integer_Sym) then begin
Get;
s  :=  Scanner.GetName(GetScanner.CurrentSymbol);
Val(s,  n,  i);
if  n  >  255  then
begin
   SemError(118,'');
   n  :=  n  mod  256;
end;
if  fTableHandler.IgnoreCase  then
   n  :=  ORD(UpCase(AnsiChar(n)));
end else if (fCurrentInputSymbol = stringSym) then begin
Get;
s  :=  Scanner.GetName(GetScanner.CurrentSymbol);
if  GetScanner.CurrentSymbol.len  <>  3  then
   SemError(118,'');
if  fTableHandler.IgnoreCase  then
   s[2]  :=  UpCase(s[2]);
n  :=  ORD(s[2]);
end else begin SynError(78);
end;
Expect(_rparenSym);
end;

procedure TCoco._SimSet (var  oneSet:  CRTSet);var
   i  :  integer;
   n1  :  integer;
   n2  :  integer;
   c  :  integer;
   name  :  CRTName;
   s  :  AnsiString;
begin
if (fCurrentInputSymbol = identSym) then begin
_Ident(name);
c  :=  fTableHandler.ClassWithName(name);
if  c  <  0  then
begin
   SemError(115,'');
   Sets.Clear(oneSet)
end
else
   fTableHandler.GetClass(c,  oneSet);
end else if (fCurrentInputSymbol = stringSym) then begin
Get;
s  :=  Scanner.GetName(GetScanner.CurrentSymbol);
Sets.Clear(oneSet);  i  :=  2;
while  s[i]  <>  s[1]  do
begin
  if  fTableHandler.IgnoreCase  then
    s[i]  :=  UpCase(s[i]);
  Sets.Incl(oneSet,  ORD(s[i]));
  INC(i)
end;
end else if (fCurrentInputSymbol = CHRSym) then begin
_SingleChar(n1);
Sets.Clear(oneSet);
Sets.Incl(oneSet,  n1);
if (fCurrentInputSymbol = _point_pointSym) then begin
Get;
_SingleChar(n2);
for  i  :=  n1  to  n2  do
   Sets.Incl(oneSet,  i);
end;
end else if (fCurrentInputSymbol = ANYSym) then begin
Get;
Sets.Fill(oneSet);
end else if (fCurrentInputSymbol = NONESym) then begin
Get;
Sets.Clear(oneSet);
end else begin SynError(79);
end;
end;

procedure TCoco._Set (var  oneSet:  CRTSet);var
   set2  :  CRTSet;
begin
_SimSet(oneSet);
while (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _minusSym) do begin
if (fCurrentInputSymbol = _plusSym) then begin
Get;
_SimSet(set2);
Sets.Unite(oneSet,  set2);
end else begin
Get;
_SimSet(set2);
Sets.Differ(oneSet,  set2);
end;
end;
end;

procedure TCoco._TokenExpr (var  gL,  gR:  INTEGER);var
   gL2  :  integer;
   gR2  :  integer;
   first  :  boolean;
begin
_TokenTerm(gL,  gR);
first  :=  TRUE;
while (fCurrentInputSymbol = _barSym) OR
 (fCurrentInputSymbol = ORSym) do begin
if (fCurrentInputSymbol = _barSym) then begin
ExpectWeak(_barSym, 5);
end else begin
ExpectWeak(ORSym, 5);
end;
_TokenTerm(gL2,  gR2);
if  first  then
begin
   fTableHandler.MakeFirstAlt(gL,  gR);
   first  :=  FALSE
end;
fTableHandler.ConcatAlt(gL,  gR,  gL2,  gR2);
end;
end;

procedure TCoco._NameDecl;var
   name  :  CRTName;
   str  :  AnsiString;
begin
_Ident(name);
Expect(_equalSym);
if (fCurrentInputSymbol = identSym) then begin
Get;
str  :=  Scanner.GetName(GetScanner.CurrentSymbol);
end else if (fCurrentInputSymbol = stringSym) then begin
Get;
str  :=  Scanner.GetName(GetScanner.CurrentSymbol);
FixString(str,  GetScanner.CurrentSymbol.len);
end else begin SynError(80);
end;
fTableHandler.NewName(name,  str);
Expect(_pointSym);
end;

procedure TCoco._TokenDecl (typ:  INTEGER);var
   kind  :  integer;
   name  :  CRTName;
   pos  :  CRTPosition;
   sp  :  integer;
   gL  :  integer;
   gR  :  integer;
   sn  :  CRTSymbolNode;
   TokenObj  :  TTokenObj;
   HGType  :  THomographType;
   TempHGType  :  THomographType;
begin
HGType  :=  htNone;
if (fCurrentInputSymbol = DEFAULTSym) then begin
Get;
HGType  :=  htDefaultIdent;
end;
_Symbol(name,  kind,  TempHGType);
sp  :=  0;
if  fTableHandler.FindSym(name)  <>  CRTnoSym  then
   SemError(107,'')
else
begin
   TokenObj  :=  TTokenObj.Create;
   if  typ  =  CRTt  then
     TokenObj.IsPragma  :=  FALSE
   else
     TokenObj.IsPragma  :=  TRUE;
   TokenObj.Position.Line  :=  GetScanner.CurrentSymbol.Line;
   TokenObj.Position.Col  :=  GetScanner.CurrentSymbol.Col;
   TokenObj.Position.Len  :=  GetScanner.CurrentSymbol.Len;
   TokenObj.Position.Pos  :=  GetScanner.CurrentSymbol.Pos;

   sp  :=  fTableHandler.NewSym(typ,  name,  GetScanner.CurrentSymbol.line);
   TokenObj.Index  :=  sp;
   TokenList.AddObject(name,  TokenObj);
   fTableHandler.GetSym(sp,  sn);
   sn.struct  :=  CRTclassToken;
   if  (sn.HomographType  =  htNone)  AND  (HGType  <>  htNone)  then
     sn.HomographType  :=  HGType;
end;
if (fCurrentInputSymbol = DESCRIPTIONSym) then begin
_Description(sn);
end;
while not ( _In(symSet[6], fCurrentInputSymbol)) do begin SynError(81); Get; end;
if (fCurrentInputSymbol = _equalSym) then begin
Get;
_TokenExpr(gL,  gR);
if  kind  <>  _identSym  then
   SemError(113,'');
fTableHandler.CompleteGraph(gR);
fAutomaton.ConvertToStates(gL,  sp);
Expect(_pointSym);
end else if _In(symSet[7], fCurrentInputSymbol) then begin
if  kind  =  _identSym  then
fTableHandler.GenScanner  :=  FALSE
else
MatchLiteral(sp);
end else begin SynError(82);
end;
if (fCurrentInputSymbol = _lparen_pointSym) then begin
_SemText(pos);
if  typ  =  CRTt  then
   SemError(114,'');
sn.semPos  :=  pos;
end;
fTableHandler.PutSym(sp,  sn);
end;

procedure TCoco._SetDecl;var
   c  :  integer;
   oneSet  :   CRTSet;
   name  :  CRTName;
begin
_Ident(name);
c  :=  fTableHandler.ClassWithName(name);
if  c  >=  0  then
   SemError(107,'');
Expect(_equalSym);
_Set(oneSet);
fTableHandler.NewClass(name,  oneSet);
Expect(_pointSym);
end;

procedure TCoco._DelphiSourceParts;var
   SrcPos  :  TCRTPosition;
begin
SrcPos  :=  NIL;
case fCurrentInputSymbol of
  CONSTSym : begin
Get;
SrcPos  :=  fTableHandler.ConstDeclPos;
    end;
  TYPESym : begin
Get;
SrcPos  :=  fTableHandler.TypeDeclPos;
    end;
  PRIVATESym : begin
Get;
SrcPos  :=  fTableHandler.PrivateDeclPos;
    end;
  PROTECTEDSym : begin
Get;
SrcPos  :=  fTableHandler.ProtectedDeclPos;
    end;
  PUBLICSym : begin
Get;
SrcPos  :=  fTableHandler.PublicDeclPos;
    end;
  PUBLISHEDSym : begin
Get;
SrcPos  :=  fTableHandler.PublishedDeclPos;
    end;
  ERRORSSym : begin
Get;
SrcPos  :=  fTableHandler.ErrorsDeclPos;
    end;
  CREATESym : begin
Get;
SrcPos  :=  fTableHandler.CreateDeclPos;
    end;
  DESTROYSym : begin
Get;
SrcPos  :=  fTableHandler.DestroyDeclPos;
    end;
else begin SynError(83);
    end;
end;
if  Assigned(SrcPos)  then
begin
   if  SrcPos.TextPresent  then
     SemError(153,LexString);
   SrcPos.TextPresent  :=  true;
   SrcPos.StartText  :=  GetScanner.NextSymbol.Pos;
end;
while _In(symSet[8], fCurrentInputSymbol) do begin
Get;
end;
if  Assigned(SrcPos)  then
begin
   SrcPos.TextLength  :=  GetScanner.NextSymbol.Pos  -  SrcPos.StartText  -  2;
   SrcPos.Column  :=  0;
end;
end;

procedure TCoco._UsesClause;var
   isInterface  :  boolean;
begin
Expect(USESSym);
isInterface  :=  FALSE;
if (fCurrentInputSymbol = _lparenINTERFACE_rparenSym) then begin
Get;
if  fTableHandler.InterfaceUses.Count  >  0  then
   SemError(151,'interface  uses  clause');
isInterface  :=  TRUE;
end else if (fCurrentInputSymbol = _lparenIMPLEMENTATION_rparenSym) then begin
Get;
if  fTableHandler.ImplementationUses.Count  >  0  then
   SemError(151,'implementation  uses  clause');
isInterface  :=  FALSE;
end else begin SynError(84);
end;
Expect(identSym);
if  isInterface  then
   fTableHandler.InterfaceUses.Add(LexString)
else
   fTableHandler.ImplementationUses.Add(LexString);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
Expect(identSym);
if  isInterface  then
   fTableHandler.InterfaceUses.Add(LexString)
else
   fTableHandler.ImplementationUses.Add(LexString);
end;
end;

procedure TCoco._Expression (var  gL,  gR:  INTEGER);var
   gL2  :  integer;
   gR2  :  integer;
   first  :  boolean;
begin
_Term(gL,  gR);
first  :=  TRUE;
while (fCurrentInputSymbol = _barSym) OR
 (fCurrentInputSymbol = ORSym) do begin
if (fCurrentInputSymbol = _barSym) then begin
ExpectWeak(_barSym, 9);
end else begin
ExpectWeak(ORSym, 9);
end;
_Term(gL2,  gR2);
if  first  then
begin
   fTableHandler.MakeFirstAlt(gL,  gR);
   first  :=  FALSE;
end;
fTableHandler.ConcatAlt(gL,  gR,  gL2,  gR2);
end;
end;

procedure TCoco._SemText (var  semPos:  CRTPosition);begin
Expect(_lparen_pointSym);
semPos.beg  :=  GetScanner.CurrentSymbol.pos  +  2;
semPos.col  :=  GetScanner.CurrentSymbol.col  +  2;
while _In(symSet[10], fCurrentInputSymbol) do begin
if _In(symSet[11], fCurrentInputSymbol) then begin
Get;
end else if (fCurrentInputSymbol = badstringSym) then begin
Get;
SemError(102,'');
end else begin
Get;
SemError(109,'');
end;
end;
Expect(_point_rparenSym);
semPos.len  :=  (GetScanner.CurrentSymbol.pos  -  semPos.beg);
end;

procedure TCoco._Description (var  sn  :  CRTSymbolNode);begin
Expect(DESCRIPTIONSym);
Expect(stringSym);
if  sn.ErrorDesc  >  ''  then
   SemError(151,'error  description')
else
   sn.ErrorDesc  :=  LexString;
end;

procedure TCoco._Attribs (var  attrPos:  CRTPosition);begin
if (fCurrentInputSymbol = _lessSym) then begin
Get;
attrPos.beg  :=  GetScanner.CurrentSymbol.pos  +  1;
attrPos.col  :=  GetScanner.CurrentSymbol.col  +  1;
while _In(symSet[12], fCurrentInputSymbol) do begin
if _In(symSet[13], fCurrentInputSymbol) then begin
Get;
end else begin
Get;
SemError(102,'');
end;
end;
Expect(_greaterSym);
attrPos.len  :=  (GetScanner.CurrentSymbol.pos  -  attrPos.beg);
end else if (fCurrentInputSymbol = _less_pointSym) then begin
Get;
attrPos.beg  :=  GetScanner.CurrentSymbol.pos  +  2;
attrPos.col  :=  GetScanner.CurrentSymbol.col  +  2;
while _In(symSet[14], fCurrentInputSymbol) do begin
if _In(symSet[15], fCurrentInputSymbol) then begin
Get;
end else begin
Get;
SemError(102,'');
end;
end;
Expect(_point_greaterSym);
attrPos.len  :=  (GetScanner.CurrentSymbol.pos  -  attrPos.beg);
end else begin SynError(85);
end;
end;

procedure TCoco._Declaration (var  startedDFA  :  boolean);var
   gL1  :  integer;
   gR1  :  integer;
   gL2  :  integer;
   gR2  :  integer;
   nested  :  boolean;
begin
nested  :=  FALSE;
case fCurrentInputSymbol of
  CHARACTERSSym : begin
Get;
while (fCurrentInputSymbol = identSym) do begin
_SetDecl;
end;
    end;
  TOKENSSym : begin
Get;
while (fCurrentInputSymbol = identSym) OR
 (fCurrentInputSymbol = stringSym) OR
 (fCurrentInputSymbol = DEFAULTSym) OR
 (fCurrentInputSymbol = HOMOGRAPHSym) do begin
_TokenDecl(CRTt);
end;
    end;
  NAMESSym : begin
Get;
while (fCurrentInputSymbol = identSym) do begin
_NameDecl;
end;
    end;
  PRAGMASSym : begin
Get;
while (fCurrentInputSymbol = identSym) OR
 (fCurrentInputSymbol = stringSym) OR
 (fCurrentInputSymbol = DEFAULTSym) OR
 (fCurrentInputSymbol = HOMOGRAPHSym) do begin
_TokenDecl(CRTpr);
end;
    end;
  COMMENTSSym : begin
Get;
Expect(FROMSym);
_TokenExpr(gL1,  gR1);
Expect(TOSym);
_TokenExpr(gL2,  gR2);
if (fCurrentInputSymbol = NESTEDSym) then begin
Get;
nested  :=  TRUE;
end else if _In(symSet[16], fCurrentInputSymbol) then begin
nested  :=  FALSE;
end else begin SynError(86);
end;
if  Assigned(fOnInsertComment)  then
   fOnInsertComment(gL1,  gL2,  nested);
    end;
  IGNORESym : begin
Get;
if (fCurrentInputSymbol = CASESym) then begin
Get;
if  startedDFA  then
   SemError(130,'');
fTableHandler.IgnoreCase  :=  TRUE;
end else if (fCurrentInputSymbol = identSym) OR
 (fCurrentInputSymbol = stringSym) OR
 (fCurrentInputSymbol = ANYSym) OR
 (fCurrentInputSymbol = NONESym) OR
 (fCurrentInputSymbol = CHRSym) then begin
_Set(fTableHandler.IgnoredCharSet);
if  Sets.IsIn(fTableHandler.IgnoredCharSet,  0)  then
   SemError(119,'');
end else begin SynError(87);
end;
    end;
else begin SynError(88);
    end;
end;
startedDFA  :=  TRUE;
end;

procedure TCoco._DelphiSection;begin
Expect(DELPHISym);
while _In(symSet[17], fCurrentInputSymbol) do begin
if (fCurrentInputSymbol = USESSym) then begin
_UsesClause;
end else begin
_DelphiSourceParts;
end;
end;
Expect(END_underscoreDELPHISym);
end;

procedure TCoco._Ident (var  name:  CRTName);var
   str  :  AnsiString;
begin
Expect(identSym);
str  :=  Scanner.GetName(GetScanner.CurrentSymbol);
name  :=  str;
end;

procedure TCoco._CocoOptionList;begin
_CocoOption;
while (fCurrentInputSymbol = _dollarSym) do begin
_CocoOption;
end;
end;

procedure TCoco._Coco;var
   startedDFA  :  boolean;
   ok  :  boolean;
   undef  :  boolean;
   hasAttrs:  boolean;
   gR  :  integer;
   gramLine  :  integer;
   sp  :  integer;
   name  :  CRTName;
   gramName  :   CRTName;
   sn  :  CRTSymbolNode;

begin
if (fCurrentInputSymbol = _dollarSym) then begin
_CocoOptionList;
end;
Expect(COMPILERSym);
gramLine  :=  GetScanner.CurrentSymbol.line;
fTableHandler.NewSym(CRTt,  'EOF',  0);
fTableHandler.GenScanner  :=  TRUE;
fTableHandler.IgnoreCase  :=  FALSE;
Sets.Clear(fTableHandler.IgnoredCharSet);
startedDFA  :=  FALSE;
_Ident(gramName);
if (fCurrentInputSymbol = DELPHISym) then begin
_DelphiSection;
end;
fTableHandler.SemDeclPos.TextPresent  :=  TRUE;
fTableHandler.SemDeclPos.StartText  :=  GetScanner.NextSymbol.Pos;
while _In(symSet[18], fCurrentInputSymbol) do begin
Get;
end;
fTableHandler.SemDeclPos.TextLength  :=  GetScanner.NextSymbol.Pos  -  fTableHandler.SemDeclPos.StartText;
fTableHandler.SemDeclPos.Column  :=  0;
while _In(symSet[19], fCurrentInputSymbol) do begin
_Declaration(startedDFA);
end;
while not ( (fCurrentInputSymbol = EOFSYMB) OR
 (fCurrentInputSymbol = PRODUCTIONSSym)) do begin SynError(89); Get; end;
Expect(PRODUCTIONSSym);
ok  :=  Successful;
if  ok  AND  fTableHandler.GenScanner  then
   fAutomaton.MakeDeterministic(ok);
if  NOT  ok  then
   SemError(127,'');
fTableHandler.nNodes  :=  0;
while (fCurrentInputSymbol = identSym) do begin
_Ident(name);
sp  :=  fTableHandler.FindSym(name);
undef  :=  sp  =  CRTnoSym;
if  undef  then
begin
   sp  :=  fTableHandler.NewSym(CRTnt,  name,  GetScanner.CurrentSymbol.line);
   fTableHandler.GetSym(sp,  sn)
end
else
begin
   fTableHandler.GetSym(sp,  sn);
   if  sn.typ  =  CRTnt  then
   begin
     if  sn.struct  >  0  then
       SemError(107,'')
   end
   else
     SemError(108,'');
   sn.line  :=  GetScanner.CurrentSymbol.line;
end;
hasAttrs  :=  sn.attrPos.beg  >=  0;
if (fCurrentInputSymbol = _lessSym) OR
 (fCurrentInputSymbol = _less_pointSym) then begin
_Attribs(sn.attrPos);
if  NOT  undef  AND  NOT  hasAttrs  then
   SemError(105,'');
fTableHandler.PutSym(sp,  sn);
end else if (fCurrentInputSymbol = _equalSym) OR
 (fCurrentInputSymbol = _lparen_pointSym) OR
 (fCurrentInputSymbol = DESCRIPTIONSym) then begin
if  NOT  undef  AND  hasAttrs  then
   SemError(105,'');
end else begin SynError(90);
end;
if (fCurrentInputSymbol = DESCRIPTIONSym) then begin
_Description(sn);
end;
if (fCurrentInputSymbol = _lparen_pointSym) then begin
_SemText(sn.semPos);
end;
ExpectWeak(_equalSym, 20);
_Expression(sn.struct,  gR);
fTableHandler.CompleteGraph(gR);
fTableHandler.PutSym(sp,  sn);
ExpectWeak(_pointSym, 21);
end;
Expect(ENDSym);
_Ident(name);
sp  :=  fTableHandler.FindSym(gramName);
if  sp  =  CRTnoSym  then
   SemError(111,'')
else
begin
   fTableHandler.GetSym(sp,  sn);
   if  sn.attrPos.beg  >=  0  then
     SemError(112,'');
   fTableHandler.Root  :=  fTableHandler.NewNode(CRTnt,  sp,  gramLine);
end;
if  name  <>  gramName  then
   SemError(117,'');
Expect(_pointSym);
fTableHandler.NewSym(CRTt,  'not',  0);
if   crsUseHashFunctions   IN   fOptions.Switches.SwitchSet   then
   fTableHandler.InterfaceUses.Add('mwStringHashList');
end;

function TCoco.GetBuildDate : TDateTime;
const
  BDate = 0;
  Hour = 00;
  Min = 00;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TCoco.GetVersion : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TCoco.GetVersionStr : AnsiString;
begin
  Result := '0.0.0.0';
end;

procedure TCoco.SetVersion(const Value : AnsiString);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TCoco.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_Coco;
end;  {Parse}

procedure TCoco.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB, identSym, stringSym, PRODUCTIONSSym, _equalSym];
symSet[ 0, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[ 0, 2] := [IGNORESym-32, DEFAULTSym-32];
symSet[ 0, 3] := [HOMOGRAPHSym-48];
symSet[ 0, 4] := [_lparen_pointSym-64];
symSet[ 1, 0] := [identSym, stringSym];
symSet[ 1, 1] := [];
symSet[ 1, 2] := [_lparenSym-32, BEGINSym-32];
symSet[ 1, 3] := [_lbrackSym-48, OPTIONSym-48, _lbraceSym-48, REPEATSym-48, 
                    HOMOGRAPHSym-48];
symSet[ 1, 4] := [];
symSet[ 2, 0] := [identSym, stringSym, _pointSym, ENDSym];
symSet[ 2, 1] := [];
symSet[ 2, 2] := [ANYSym-32, _lparenSym-32, _rparenSym-32, _barSym-32, 
                    ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[ 2, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, HOMOGRAPHSym-48];
symSet[ 2, 4] := [_lparen_pointSym-64];
symSet[ 3, 0] := [identSym, stringSym];
symSet[ 3, 1] := [];
symSet[ 3, 2] := [ANYSym-32, _lparenSym-32, WEAKSym-32, BEGINSym-32];
symSet[ 3, 3] := [_lbrackSym-48, OPTIONSym-48, _lbraceSym-48, REPEATSym-48, 
                    SYNCSym-48, IFSym-48, HOMOGRAPHSym-48];
symSet[ 3, 4] := [_lparen_pointSym-64];
symSet[ 4, 0] := [_pointSym, ENDSym];
symSet[ 4, 1] := [];
symSet[ 4, 2] := [_rparenSym-32, _barSym-32, ORSym-32];
symSet[ 4, 3] := [_rbrackSym-48, END_underscoreOPTIONSym-48, _rbraceSym-48, 
                    END_underscoreREPEATSym-48];
symSet[ 4, 4] := [];
symSet[ 5, 0] := [EOFSYMB, identSym, stringSym, PRODUCTIONSSym, _equalSym];
symSet[ 5, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[ 5, 2] := [IGNORESym-32, _lparenSym-32, DEFAULTSym-32, BEGINSym-32];
symSet[ 5, 3] := [_lbrackSym-48, OPTIONSym-48, _lbraceSym-48, REPEATSym-48, 
                    HOMOGRAPHSym-48];
symSet[ 5, 4] := [_lparen_pointSym-64];
symSet[ 6, 0] := [EOFSYMB, identSym, stringSym, PRODUCTIONSSym, _equalSym];
symSet[ 6, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[ 6, 2] := [IGNORESym-32, DEFAULTSym-32];
symSet[ 6, 3] := [HOMOGRAPHSym-48];
symSet[ 6, 4] := [_lparen_pointSym-64];
symSet[ 7, 0] := [identSym, stringSym, PRODUCTIONSSym];
symSet[ 7, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[ 7, 2] := [IGNORESym-32, DEFAULTSym-32];
symSet[ 7, 3] := [HOMOGRAPHSym-48];
symSet[ 7, 4] := [_lparen_pointSym-64];
symSet[ 8, 0] := [identSym, stringSym, badstringSym, integer_Sym, 
                    COMPILERSym, PRODUCTIONSSym, _equalSym, _pointSym, 
                    ENDSym, DELPHISym];
symSet[ 8, 1] := [_lparenINTERFACE_rparenSym-16, 
                    _lparenIMPLEMENTATION_rparenSym-16, _commaSym-16, 
                    CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16, FROMSym-16, TOSym-16];
symSet[ 8, 2] := [NESTEDSym-32, IGNORESym-32, CASESym-32, _plusSym-32, 
                    _minusSym-32, _point_pointSym-32, ANYSym-32, NONESym-32, 
                    CHRSym-32, _lparenSym-32, _rparenSym-32, DEFAULTSym-32, 
                    _barSym-32, ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[ 8, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, THENSym-48, ELSESym-48, CONTEXTSym-48, 
                    HOMOGRAPHSym-48, _lessSym-48, _greaterSym-48];
symSet[ 8, 4] := [_less_pointSym-64, _point_greaterSym-64, 
                    _lparen_pointSym-64, _point_rparenSym-64, DESCRIPTIONSym-64, 
                    _dollarSym-64, NOSYMB-64];
symSet[ 9, 0] := [EOFSYMB, identSym, stringSym, PRODUCTIONSSym, _equalSym, 
                    _pointSym, ENDSym];
symSet[ 9, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[ 9, 2] := [IGNORESym-32, ANYSym-32, _lparenSym-32, _rparenSym-32, 
                    DEFAULTSym-32, _barSym-32, ORSym-32, WEAKSym-32, 
                    BEGINSym-32];
symSet[ 9, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, HOMOGRAPHSym-48];
symSet[ 9, 4] := [_lparen_pointSym-64];
symSet[10, 0] := [identSym, stringSym, badstringSym, integer_Sym, 
                    COMPILERSym, PRODUCTIONSSym, _equalSym, _pointSym, 
                    ENDSym, DELPHISym, END_underscoreDELPHISym, CONSTSym, 
                    TYPESym, PRIVATESym, PROTECTEDSym];
symSet[10, 1] := [PUBLICSym-16, PUBLISHEDSym-16, ERRORSSym-16, CREATESym-16, 
                    DESTROYSym-16, USESSym-16, _lparenINTERFACE_rparenSym-16, 
                    _lparenIMPLEMENTATION_rparenSym-16, _commaSym-16, 
                    CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16, FROMSym-16, TOSym-16];
symSet[10, 2] := [NESTEDSym-32, IGNORESym-32, CASESym-32, _plusSym-32, 
                    _minusSym-32, _point_pointSym-32, ANYSym-32, NONESym-32, 
                    CHRSym-32, _lparenSym-32, _rparenSym-32, DEFAULTSym-32, 
                    _barSym-32, ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[10, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, THENSym-48, ELSESym-48, CONTEXTSym-48, 
                    HOMOGRAPHSym-48, _lessSym-48, _greaterSym-48];
symSet[10, 4] := [_less_pointSym-64, _point_greaterSym-64, 
                    _lparen_pointSym-64, DESCRIPTIONSym-64, _dollarSym-64, 
                    NOSYMB-64];
symSet[11, 0] := [identSym, stringSym, integer_Sym, COMPILERSym, 
                    PRODUCTIONSSym, _equalSym, _pointSym, ENDSym, DELPHISym, 
                    END_underscoreDELPHISym, CONSTSym, TYPESym, PRIVATESym, 
                    PROTECTEDSym];
symSet[11, 1] := [PUBLICSym-16, PUBLISHEDSym-16, ERRORSSym-16, CREATESym-16, 
                    DESTROYSym-16, USESSym-16, _lparenINTERFACE_rparenSym-16, 
                    _lparenIMPLEMENTATION_rparenSym-16, _commaSym-16, 
                    CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16, FROMSym-16, TOSym-16];
symSet[11, 2] := [NESTEDSym-32, IGNORESym-32, CASESym-32, _plusSym-32, 
                    _minusSym-32, _point_pointSym-32, ANYSym-32, NONESym-32, 
                    CHRSym-32, _lparenSym-32, _rparenSym-32, DEFAULTSym-32, 
                    _barSym-32, ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[11, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, THENSym-48, ELSESym-48, CONTEXTSym-48, 
                    HOMOGRAPHSym-48, _lessSym-48, _greaterSym-48];
symSet[11, 4] := [_less_pointSym-64, _point_greaterSym-64, DESCRIPTIONSym-64, 
                    _dollarSym-64, NOSYMB-64];
symSet[12, 0] := [identSym, stringSym, badstringSym, integer_Sym, 
                    COMPILERSym, PRODUCTIONSSym, _equalSym, _pointSym, 
                    ENDSym, DELPHISym, END_underscoreDELPHISym, CONSTSym, 
                    TYPESym, PRIVATESym, PROTECTEDSym];
symSet[12, 1] := [PUBLICSym-16, PUBLISHEDSym-16, ERRORSSym-16, CREATESym-16, 
                    DESTROYSym-16, USESSym-16, _lparenINTERFACE_rparenSym-16, 
                    _lparenIMPLEMENTATION_rparenSym-16, _commaSym-16, 
                    CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16, FROMSym-16, TOSym-16];
symSet[12, 2] := [NESTEDSym-32, IGNORESym-32, CASESym-32, _plusSym-32, 
                    _minusSym-32, _point_pointSym-32, ANYSym-32, NONESym-32, 
                    CHRSym-32, _lparenSym-32, _rparenSym-32, DEFAULTSym-32, 
                    _barSym-32, ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[12, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, THENSym-48, ELSESym-48, CONTEXTSym-48, 
                    HOMOGRAPHSym-48, _lessSym-48];
symSet[12, 4] := [_less_pointSym-64, _point_greaterSym-64, 
                    _lparen_pointSym-64, _point_rparenSym-64, DESCRIPTIONSym-64, 
                    _dollarSym-64, NOSYMB-64];
symSet[13, 0] := [identSym, stringSym, integer_Sym, COMPILERSym, 
                    PRODUCTIONSSym, _equalSym, _pointSym, ENDSym, DELPHISym, 
                    END_underscoreDELPHISym, CONSTSym, TYPESym, PRIVATESym, 
                    PROTECTEDSym];
symSet[13, 1] := [PUBLICSym-16, PUBLISHEDSym-16, ERRORSSym-16, CREATESym-16, 
                    DESTROYSym-16, USESSym-16, _lparenINTERFACE_rparenSym-16, 
                    _lparenIMPLEMENTATION_rparenSym-16, _commaSym-16, 
                    CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16, FROMSym-16, TOSym-16];
symSet[13, 2] := [NESTEDSym-32, IGNORESym-32, CASESym-32, _plusSym-32, 
                    _minusSym-32, _point_pointSym-32, ANYSym-32, NONESym-32, 
                    CHRSym-32, _lparenSym-32, _rparenSym-32, DEFAULTSym-32, 
                    _barSym-32, ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[13, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, THENSym-48, ELSESym-48, CONTEXTSym-48, 
                    HOMOGRAPHSym-48, _lessSym-48];
symSet[13, 4] := [_less_pointSym-64, _point_greaterSym-64, 
                    _lparen_pointSym-64, _point_rparenSym-64, DESCRIPTIONSym-64, 
                    _dollarSym-64, NOSYMB-64];
symSet[14, 0] := [identSym, stringSym, badstringSym, integer_Sym, 
                    COMPILERSym, PRODUCTIONSSym, _equalSym, _pointSym, 
                    ENDSym, DELPHISym, END_underscoreDELPHISym, CONSTSym, 
                    TYPESym, PRIVATESym, PROTECTEDSym];
symSet[14, 1] := [PUBLICSym-16, PUBLISHEDSym-16, ERRORSSym-16, CREATESym-16, 
                    DESTROYSym-16, USESSym-16, _lparenINTERFACE_rparenSym-16, 
                    _lparenIMPLEMENTATION_rparenSym-16, _commaSym-16, 
                    CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16, FROMSym-16, TOSym-16];
symSet[14, 2] := [NESTEDSym-32, IGNORESym-32, CASESym-32, _plusSym-32, 
                    _minusSym-32, _point_pointSym-32, ANYSym-32, NONESym-32, 
                    CHRSym-32, _lparenSym-32, _rparenSym-32, DEFAULTSym-32, 
                    _barSym-32, ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[14, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, THENSym-48, ELSESym-48, CONTEXTSym-48, 
                    HOMOGRAPHSym-48, _lessSym-48, _greaterSym-48];
symSet[14, 4] := [_less_pointSym-64, _lparen_pointSym-64, _point_rparenSym-64, 
                    DESCRIPTIONSym-64, _dollarSym-64, NOSYMB-64];
symSet[15, 0] := [identSym, stringSym, integer_Sym, COMPILERSym, 
                    PRODUCTIONSSym, _equalSym, _pointSym, ENDSym, DELPHISym, 
                    END_underscoreDELPHISym, CONSTSym, TYPESym, PRIVATESym, 
                    PROTECTEDSym];
symSet[15, 1] := [PUBLICSym-16, PUBLISHEDSym-16, ERRORSSym-16, CREATESym-16, 
                    DESTROYSym-16, USESSym-16, _lparenINTERFACE_rparenSym-16, 
                    _lparenIMPLEMENTATION_rparenSym-16, _commaSym-16, 
                    CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16, FROMSym-16, TOSym-16];
symSet[15, 2] := [NESTEDSym-32, IGNORESym-32, CASESym-32, _plusSym-32, 
                    _minusSym-32, _point_pointSym-32, ANYSym-32, NONESym-32, 
                    CHRSym-32, _lparenSym-32, _rparenSym-32, DEFAULTSym-32, 
                    _barSym-32, ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[15, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, THENSym-48, ELSESym-48, CONTEXTSym-48, 
                    HOMOGRAPHSym-48, _lessSym-48, _greaterSym-48];
symSet[15, 4] := [_less_pointSym-64, _lparen_pointSym-64, _point_rparenSym-64, 
                    DESCRIPTIONSym-64, _dollarSym-64, NOSYMB-64];
symSet[16, 0] := [PRODUCTIONSSym];
symSet[16, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[16, 2] := [IGNORESym-32];
symSet[16, 3] := [];
symSet[16, 4] := [];
symSet[17, 0] := [CONSTSym, TYPESym, PRIVATESym, PROTECTEDSym];
symSet[17, 1] := [PUBLICSym-16, PUBLISHEDSym-16, ERRORSSym-16, CREATESym-16, 
                    DESTROYSym-16, USESSym-16];
symSet[17, 2] := [];
symSet[17, 3] := [];
symSet[17, 4] := [];
symSet[18, 0] := [identSym, stringSym, badstringSym, integer_Sym, 
                    COMPILERSym, _equalSym, _pointSym, ENDSym, DELPHISym, 
                    END_underscoreDELPHISym, CONSTSym, TYPESym, PRIVATESym, 
                    PROTECTEDSym];
symSet[18, 1] := [PUBLICSym-16, PUBLISHEDSym-16, ERRORSSym-16, CREATESym-16, 
                    DESTROYSym-16, USESSym-16, _lparenINTERFACE_rparenSym-16, 
                    _lparenIMPLEMENTATION_rparenSym-16, _commaSym-16, 
                    FROMSym-16, TOSym-16];
symSet[18, 2] := [NESTEDSym-32, CASESym-32, _plusSym-32, _minusSym-32, 
                    _point_pointSym-32, ANYSym-32, NONESym-32, CHRSym-32, 
                    _lparenSym-32, _rparenSym-32, DEFAULTSym-32, _barSym-32, 
                    ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[18, 3] := [_lbrackSym-48, _rbrackSym-48, OPTIONSym-48, 
                    END_underscoreOPTIONSym-48, _lbraceSym-48, _rbraceSym-48, 
                    REPEATSym-48, END_underscoreREPEATSym-48, SYNCSym-48, 
                    IFSym-48, THENSym-48, ELSESym-48, CONTEXTSym-48, 
                    HOMOGRAPHSym-48, _lessSym-48, _greaterSym-48];
symSet[18, 4] := [_less_pointSym-64, _point_greaterSym-64, 
                    _lparen_pointSym-64, _point_rparenSym-64, DESCRIPTIONSym-64, 
                    _dollarSym-64, NOSYMB-64];
symSet[19, 0] := [];
symSet[19, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[19, 2] := [IGNORESym-32];
symSet[19, 3] := [];
symSet[19, 4] := [];
symSet[20, 0] := [EOFSYMB, identSym, stringSym, PRODUCTIONSSym, _equalSym, 
                    _pointSym];
symSet[20, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[20, 2] := [IGNORESym-32, ANYSym-32, _lparenSym-32, DEFAULTSym-32, 
                    _barSym-32, ORSym-32, WEAKSym-32, BEGINSym-32];
symSet[20, 3] := [_lbrackSym-48, OPTIONSym-48, _lbraceSym-48, REPEATSym-48, 
                    SYNCSym-48, IFSym-48, HOMOGRAPHSym-48];
symSet[20, 4] := [_lparen_pointSym-64];
symSet[21, 0] := [EOFSYMB, identSym, stringSym, PRODUCTIONSSym, _equalSym, 
                    ENDSym];
symSet[21, 1] := [CHARACTERSSym-16, TOKENSSym-16, NAMESSym-16, PRAGMASSym-16, 
                    COMMENTSSym-16];
symSet[21, 2] := [IGNORESym-32, DEFAULTSym-32];
symSet[21, 3] := [HOMOGRAPHSym-48];
symSet[21, 4] := [_lparen_pointSym-64];
end; {InitSymSet}

end { Coco }.    
