unit JSONGrammar;




{==============================================================================
JSONGrammar
0.0.0.0
Date of Generation: 20/12/2024 19:00
Comment: Parses JSON data embedded in HTML.
Author: Martin Harvey
Copyright: (c) Martin Harvey

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,Trackables,JSONNodes,DLList;



const
maxT = 13;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EJSONGrammar = class(Exception);
  TJSONGrammar = class;

  TJSONGrammarScanner = class(TCocoRScanner)
  private
    FOwner : TJSONGrammar;
function CharInIgnoreSet(const Ch : AnsiChar) : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TJSONGrammar read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TJSONGrammarScanner }

  TJSONGrammar = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..0] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : AnsiString;
    function GetVersionStr : AnsiString;
    procedure SetVersion(const Value : AnsiString);
    function GetVersionInfo : AnsiString;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _Number (out S:String);
    procedure _String (out S:String);
    procedure _Value (out V:TJSONValue);
    procedure _Member (out M:TJSONMember);
    procedure _Array (out A:TJSONContainer);
    procedure _Object (out O:TJSONContainer);
    procedure _JSONGrammar;

  private
    FParentObject: TObject;

  protected
    procedure AbortParse();
    procedure InsertMemberIntoObject(O: TJSONCOntainer; M: TJSONMember);
    procedure InsertValueIntoArray(A: TJSONContainer; V: TJSONValue);
    procedure InsertValueIntoMember(M: TJSONMember; V: TJSONValue);
    procedure InsertContainerIntoDocument(D: TJSONDocument; C: TJSONContainer);

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString; override;
    procedure Execute; override;
    function GetScanner : TJSONGrammarScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : AnsiString read GetVersionStr;
    property VersionInfo : AnsiString read GetVersionInfo;

  public
    procedure SetLocation(N: TJSONNode);
    procedure ParseWarning(Code: integer; S: string);
    property ParentObject:TObject read FParentObject write FParentObject;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : AnsiString read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TJSONGrammar }

implementation
uses  HTMLParser,HTMLParseEvents,CommonNodes;



const

  EOFSYMB = 0;  NumberTokenSym = 1;  DQuotStringSym = 2;  _lessSym = 3;
  _lbraceSym = 4;  _commaSym = 5;  _rbraceSym = 6;  _lbrackSym = 7;
  _rbrackSym = 8;  _colonSym = 9;  falseSym = 10;  nullSym = 11;  trueSym = 12;
  NOSYMB = 13;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
{ Arbitrary code }
{

Copyright © 2020 Martin Harvey <martin_c_harvey@hotmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

}

procedure TJSONGrammar.SetLocation(N: TJSONNode);
begin
  N.Line := (Scanner as TJSONGrammarScanner).CurrentSymbol.Line;
  N.Col := (Scanner as TJSONGrammarScanner).CurrentSymbol.Col;
end;

procedure TJSONGrammar.ParseWarning(Code: integer; S: string);
var
  Sc: TJSONGrammarScanner;
begin
  Sc := (Scanner as TJSONGrammarScanner);
  if Assigned(ParentObject) and (ParentObject is THTMLParseItem) then
  begin
    (ParentObject as THTMLParseItem).EventList.Add(
      TParseEvent.CreateFromParseWarning(
      Sc.NextSymbol.Col, Sc.NextSymbol.Line, Code, ErrorStr(Code, AnsiString(S)) + AnsiString(S), self));
  end;
end;

procedure TJSONGrammar.AbortParse();
begin
  raise EParseAbort.Create(ErrorStr(1000, ''),
                (Scanner as TJSONGrammarScanner).NextSymbol.Line,
                (Scanner as TJSONGrammarScanner).NextSymbol.Col);
end;

procedure TJSONGrammar.InsertMemberIntoObject(O: TJSONCOntainer; M: TJSONMember);
begin
  if not Assigned(O) or not Assigned(M) then
    AbortParse;
  Assert(O is TJSONContainer);
  Assert(O.ContainerType = jctObject);
  Assert(M is TJSONMember);
  DLListInsertTail(@O.COntainedListHead, @M.SiblingListEntry);
end;

procedure TJSONGrammar.InsertValueIntoArray(A: TJSONContainer; V: TJSONValue);
begin
  if not Assigned(A) or not Assigned(V) then
  begin
    ParseWarning(1001, '');
    exit;
  end;
  Assert(A is TJSONContainer);
  Assert(A.ContainerType = jctArray);
  Assert(V is TJSONValue);
  DLListInsertTail(@A.ContainedListHead, @V.SiblingListEntry);
end;

procedure TJSONGrammar.InsertValueIntoMember(M: TJSONMember; V: TJSONValue);
begin
  if not Assigned(M) or not Assigned(V) then
  begin
    ParseWarning(1001, '');
    exit;
  end;
  Assert(M is TJSONMember);
  Assert(V is TJSONValue);
  DLListInsertTail(@M.ContainedListHead, @V.SiblingListEntry);
end;

procedure TJSONGrammar.InsertContainerIntoDocument(D: TJSONDocument; C: TJSONContainer);
begin
  if not Assigned(D) or not Assigned(C) then
    AbortParse;
  Assert(D is TJSONDocument);
  Assert(C is TJSONContainer);
  DLListInsertTail(@D.ContainedListHead, @C.SiblingListEntry);
end;



{ --------------------------------------------------------------------------- }
{ ---- implementation for TJSONGrammarScanner ---- }

procedure TJSONGrammarScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}


function TJSONGrammarScanner.CharInIgnoreSet(const Ch : AnsiChar) : boolean;
begin
Result := ((CurrInputCh >= AnsiChar(9)) AND (CurrInputCh <= AnsiChar(10)) OR
(CurrInputCh = AnsiChar(13)) OR
(CurrInputCh = ' '));
end; {CharInIgnoreSet}


procedure TJSONGrammarScanner.Get(var sym : integer);
var
  state : integer;
  label __start_get;
 begin   {Get}
__start_get:
while CharInIgnoreSet(CurrInputCh) do
  NextCh;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 2; 
end
else
begin
  sym := _noSym;
exit;
end;
   2: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = 'e') then
begin
state := 8; 
end
else if (CurrInputCh = 'E') then
begin
state := 3; 
end
else if (CurrInputCh = '.') then
begin
state := 6; 
end
else
begin
sym := NumberTokenSym;
exit;
end;
   3: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 5; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 4; 
end
else
begin
  sym := _noSym;
exit;
end;
   4: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 5; 
end
else
begin
  sym := _noSym;
exit;
end;
   5: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else
begin
sym := NumberTokenSym;
exit;
end;
   6: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 7; 
end
else
begin
  sym := _noSym;
exit;
end;
   7: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = 'e') then
begin
state := 8; 
end
else if (CurrInputCh = 'E') then
begin
state := 3; 
end
else
begin
sym := NumberTokenSym;
exit;
end;
   8: begin
sym := NumberTokenSym;
exit;
end;
   9: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  10: if ((CurrInputCh = AnsiChar(13))) then
begin
state := 11; 
end
else if ((CurrInputCh = AnsiChar(10))) then
begin
state := 12; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= 't') OR
(CurrInputCh >= 'v') AND (CurrInputCh <= 'w') OR
(CurrInputCh >= 'y')) then
begin
state := 9; 
end
else if (CurrInputCh = 'u') then
begin
state := 14; 
end
else if (CurrInputCh = 'x') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  11: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 9; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  12: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 9; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  13: begin
sym := DQuotStringSym;
exit;
end;
  14: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= '|')) then
begin
state := 9; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 16; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else if (CurrInputCh = '{') then
begin
state := 17; 
end
else
begin
  sym := _noSym;
exit;
end;
  15: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 9; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 18; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  16: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 9; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 19; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  17: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 9; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 20; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  18: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 9; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  19: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 9; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 21; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  20: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 9; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 22; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  21: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 9; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  22: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 9; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 23; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  23: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 9; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 24; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  24: if ((CurrInputCh = '"')) then
begin
state := 13; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 9; 
end
else if (CurrInputCh = '\') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  25: begin
sym := _lessSym;
exit;
end;
  26: begin
sym := _lbraceSym;
exit;
end;
  27: begin
sym := _commaSym;
exit;
end;
  28: begin
sym := _rbraceSym;
exit;
end;
  29: begin
sym := _lbrackSym;
exit;
end;
  30: begin
sym := _rbrackSym;
exit;
end;
  31: begin
sym := _colonSym;
exit;
end;
  32: if (CurrInputCh = 'a') then
begin
state := 33; 
end
else
begin
  sym := _noSym;
exit;
end;
  33: if (CurrInputCh = 'l') then
begin
state := 34; 
end
else
begin
  sym := _noSym;
exit;
end;
  34: if (CurrInputCh = 's') then
begin
state := 35; 
end
else
begin
  sym := _noSym;
exit;
end;
  35: if (CurrInputCh = 'e') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  36: begin
sym := falseSym;
exit;
end;
  37: if (CurrInputCh = 'u') then
begin
state := 38; 
end
else
begin
  sym := _noSym;
exit;
end;
  38: if (CurrInputCh = 'l') then
begin
state := 39; 
end
else
begin
  sym := _noSym;
exit;
end;
  39: if (CurrInputCh = 'l') then
begin
state := 40; 
end
else
begin
  sym := _noSym;
exit;
end;
  40: begin
sym := nullSym;
exit;
end;
  41: if (CurrInputCh = 'r') then
begin
state := 42; 
end
else
begin
  sym := _noSym;
exit;
end;
  42: if (CurrInputCh = 'u') then
begin
state := 43; 
end
else
begin
  sym := _noSym;
exit;
end;
  43: if (CurrInputCh = 'e') then
begin
state := 44; 
end
else
begin
  sym := _noSym;
exit;
end;
  44: begin
sym := trueSym;
exit;
end;
  45: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TJSONGrammarScanner.Create;
begin
  inherited;
CurrentCh := CharAt;
fStartState[  0] := 45; fStartState[  1] := 46; fStartState[  2] := 46; fStartState[  3] := 46; 
fStartState[  4] := 46; fStartState[  5] := 46; fStartState[  6] := 46; fStartState[  7] := 46; 
fStartState[  8] := 46; fStartState[  9] := 46; fStartState[ 10] := 46; fStartState[ 11] := 46; 
fStartState[ 12] := 46; fStartState[ 13] := 46; fStartState[ 14] := 46; fStartState[ 15] := 46; 
fStartState[ 16] := 46; fStartState[ 17] := 46; fStartState[ 18] := 46; fStartState[ 19] := 46; 
fStartState[ 20] := 46; fStartState[ 21] := 46; fStartState[ 22] := 46; fStartState[ 23] := 46; 
fStartState[ 24] := 46; fStartState[ 25] := 46; fStartState[ 26] := 46; fStartState[ 27] := 46; 
fStartState[ 28] := 46; fStartState[ 29] := 46; fStartState[ 30] := 46; fStartState[ 31] := 46; 
fStartState[ 32] := 46; fStartState[ 33] := 46; fStartState[ 34] :=  9; fStartState[ 35] := 46; 
fStartState[ 36] := 46; fStartState[ 37] := 46; fStartState[ 38] := 46; fStartState[ 39] := 46; 
fStartState[ 40] := 46; fStartState[ 41] := 46; fStartState[ 42] := 46; fStartState[ 43] := 46; 
fStartState[ 44] := 27; fStartState[ 45] :=  1; fStartState[ 46] := 46; fStartState[ 47] := 46; 
fStartState[ 48] :=  2; fStartState[ 49] :=  2; fStartState[ 50] :=  2; fStartState[ 51] :=  2; 
fStartState[ 52] :=  2; fStartState[ 53] :=  2; fStartState[ 54] :=  2; fStartState[ 55] :=  2; 
fStartState[ 56] :=  2; fStartState[ 57] :=  2; fStartState[ 58] := 31; fStartState[ 59] := 46; 
fStartState[ 60] := 25; fStartState[ 61] := 46; fStartState[ 62] := 46; fStartState[ 63] := 46; 
fStartState[ 64] := 46; fStartState[ 65] := 46; fStartState[ 66] := 46; fStartState[ 67] := 46; 
fStartState[ 68] := 46; fStartState[ 69] := 46; fStartState[ 70] := 46; fStartState[ 71] := 46; 
fStartState[ 72] := 46; fStartState[ 73] := 46; fStartState[ 74] := 46; fStartState[ 75] := 46; 
fStartState[ 76] := 46; fStartState[ 77] := 46; fStartState[ 78] := 46; fStartState[ 79] := 46; 
fStartState[ 80] := 46; fStartState[ 81] := 46; fStartState[ 82] := 46; fStartState[ 83] := 46; 
fStartState[ 84] := 46; fStartState[ 85] := 46; fStartState[ 86] := 46; fStartState[ 87] := 46; 
fStartState[ 88] := 46; fStartState[ 89] := 46; fStartState[ 90] := 46; fStartState[ 91] := 29; 
fStartState[ 92] := 46; fStartState[ 93] := 30; fStartState[ 94] := 46; fStartState[ 95] := 46; 
fStartState[ 96] := 46; fStartState[ 97] := 46; fStartState[ 98] := 46; fStartState[ 99] := 46; 
fStartState[100] := 46; fStartState[101] := 46; fStartState[102] := 32; fStartState[103] := 46; 
fStartState[104] := 46; fStartState[105] := 46; fStartState[106] := 46; fStartState[107] := 46; 
fStartState[108] := 46; fStartState[109] := 46; fStartState[110] := 37; fStartState[111] := 46; 
fStartState[112] := 46; fStartState[113] := 46; fStartState[114] := 46; fStartState[115] := 46; 
fStartState[116] := 41; fStartState[117] := 46; fStartState[118] := 46; fStartState[119] := 46; 
fStartState[120] := 46; fStartState[121] := 46; fStartState[122] := 46; fStartState[123] := 26; 
fStartState[124] := 46; fStartState[125] := 28; fStartState[126] := 46; fStartState[127] := 46; 
fStartState[128] := 46; fStartState[129] := 46; fStartState[130] := 46; fStartState[131] := 46; 
fStartState[132] := 46; fStartState[133] := 46; fStartState[134] := 46; fStartState[135] := 46; 
fStartState[136] := 46; fStartState[137] := 46; fStartState[138] := 46; fStartState[139] := 46; 
fStartState[140] := 46; fStartState[141] := 46; fStartState[142] := 46; fStartState[143] := 46; 
fStartState[144] := 46; fStartState[145] := 46; fStartState[146] := 46; fStartState[147] := 46; 
fStartState[148] := 46; fStartState[149] := 46; fStartState[150] := 46; fStartState[151] := 46; 
fStartState[152] := 46; fStartState[153] := 46; fStartState[154] := 46; fStartState[155] := 46; 
fStartState[156] := 46; fStartState[157] := 46; fStartState[158] := 46; fStartState[159] := 46; 
fStartState[160] := 46; fStartState[161] := 46; fStartState[162] := 46; fStartState[163] := 46; 
fStartState[164] := 46; fStartState[165] := 46; fStartState[166] := 46; fStartState[167] := 46; 
fStartState[168] := 46; fStartState[169] := 46; fStartState[170] := 46; fStartState[171] := 46; 
fStartState[172] := 46; fStartState[173] := 46; fStartState[174] := 46; fStartState[175] := 46; 
fStartState[176] := 46; fStartState[177] := 46; fStartState[178] := 46; fStartState[179] := 46; 
fStartState[180] := 46; fStartState[181] := 46; fStartState[182] := 46; fStartState[183] := 46; 
fStartState[184] := 46; fStartState[185] := 46; fStartState[186] := 46; fStartState[187] := 46; 
fStartState[188] := 46; fStartState[189] := 46; fStartState[190] := 46; fStartState[191] := 46; 
fStartState[192] := 46; fStartState[193] := 46; fStartState[194] := 46; fStartState[195] := 46; 
fStartState[196] := 46; fStartState[197] := 46; fStartState[198] := 46; fStartState[199] := 46; 
fStartState[200] := 46; fStartState[201] := 46; fStartState[202] := 46; fStartState[203] := 46; 
fStartState[204] := 46; fStartState[205] := 46; fStartState[206] := 46; fStartState[207] := 46; 
fStartState[208] := 46; fStartState[209] := 46; fStartState[210] := 46; fStartState[211] := 46; 
fStartState[212] := 46; fStartState[213] := 46; fStartState[214] := 46; fStartState[215] := 46; 
fStartState[216] := 46; fStartState[217] := 46; fStartState[218] := 46; fStartState[219] := 46; 
fStartState[220] := 46; fStartState[221] := 46; fStartState[222] := 46; fStartState[223] := 46; 
fStartState[224] := 46; fStartState[225] := 46; fStartState[226] := 46; fStartState[227] := 46; 
fStartState[228] := 46; fStartState[229] := 46; fStartState[230] := 46; fStartState[231] := 46; 
fStartState[232] := 46; fStartState[233] := 46; fStartState[234] := 46; fStartState[235] := 46; 
fStartState[236] := 46; fStartState[237] := 46; fStartState[238] := 46; fStartState[239] := 46; 
fStartState[240] := 46; fStartState[241] := 46; fStartState[242] := 46; fStartState[243] := 46; 
fStartState[244] := 46; fStartState[245] := 46; fStartState[246] := 46; fStartState[247] := 46; 
fStartState[248] := 46; fStartState[249] := 46; fStartState[250] := 46; fStartState[251] := 46; 
fStartState[252] := 46; fStartState[253] := 46; fStartState[254] := 46; fStartState[255] := 46; 
end; {Create}


{ --------------------------------------------------------------------------- }
{ ---- implementation for TJSONGrammar ---- }

constructor TJSONGrammar.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TJSONGrammarScanner.Create;
  GetScanner.Owner := self;
FParseTracker := TTracker.Create;
    FLangStr := 'JSON';

  InitSymSet;
end; {Create}

destructor TJSONGrammar.Destroy;
begin
  Scanner.Free;
FParseTracker.Free;

  inherited;
end; {Destroy}

function TJSONGrammar.ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'NumberToken expected';
   2 : Result := 'DQuotString expected';
   3 : Result := '"<" expected';
   4 : Result := '"{" expected';
   5 : Result := '"," expected';
   6 : Result := '"}" expected';
   7 : Result := '"[" expected';
   8 : Result := '"]" expected';
   9 : Result := '":" expected';
  10 : Result := '"false" expected';
  11 : Result := '"null" expected';
  12 : Result := '"true" expected';
  13 : Result := 'not expected';
  14 : Result := 'invalid JSON Value';
  15 : Result := 'invalid JSON Array';
  16 : Result := 'invalid JSON Object';
  17 : Result := 'invalid JSON data block';

1000: Result := 'Unable to continue after previous errors, aborting.';
    1001: Result := 'Missing or malformed value, skipping.';
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := AnsiString('Error: ' + AnsiString(IntToStr(ErrorCode)));
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TJSONGrammar.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;
  StreamPartRead := -1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TJSONGrammar.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TJSONGrammar.GetScanner : TJSONGrammarScanner;
begin
  Result := Scanner AS TJSONGrammarScanner;
end; {GetScanner}

function TJSONGrammar._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TJSONGrammar._Number (out  S:String);begin
Expect(NumberTokenSym);
S  :=  UnicodeLexString;
end;

procedure TJSONGrammar._String (out  S:String);begin
Expect(DQuotStringSym);
S  :=  UnicodeLexString;
S  :=  S.SubString(1,  Length(S)  -  2);
end;

procedure TJSONGrammar._Value (out  V:TJSONValue);var  VR:  TJSONContainer;
     VS:  TJSONSImpleValue;
     S:string;
begin
V  :=  nil;
VR  :=  nil;
VS  :=  TJSONSimpleValue.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(VS);

case fCurrentInputSymbol of
  falseSym : begin
Get;
VS.ValType  :=  svtFalse;  V:=  VS;

    end;
  nullSym : begin
Get;
VS.ValType  :=  svtNull;  V:=  VS;

    end;
  trueSym : begin
Get;
VS.ValType  :=  svtTrue;  V:=  VS;

    end;
  _lbraceSym : begin
_Object(VR);
VS.Free;  V  :=  VR;

    end;
  _lbrackSym : begin
_Array(VR);
VS.Free;  V  :=  VR;

    end;
  NumberTokenSym : begin
_Number(S);
VS.ValType  :=  svtNumber;
VS.StrData  :=  S;
V  :=  VS;

    end;
  DQuotStringSym : begin
_String(S);
VS.ValType  :=  svtString;
VS.StrData  :=  S;
V  :=  VS;

    end;
else begin SynError(14);
    end;
end;
if  not  Assigned(V)  then  VS.Free;  {  SynError  case  }
end;

procedure TJSONGrammar._Member (out  M:TJSONMember);var  S:  string;
     V:  TJSONValue;
begin
V:=  nil;
M  :=  TJSONMember.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(M);
_String(S);
M.Name  :=  S;
Expect(_colonSym);
_Value(V);
InsertValueIntoMember(M,  V);
end;

procedure TJSONGrammar._Array (out  A:TJSONContainer);var  V:  TJSONValue;
begin
V  :=  nil;
A  :=  TJSONContainer.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(A);
A.ContainerType  :=  jctArray;

Expect(_lbrackSym);
if (fCurrentInputSymbol < 16) { prevent range error } AND
 (fCurrentInputSymbol IN [NumberTokenSym, DQuotStringSym, _lbraceSym, _lbrackSym, 
                    falseSym, nullSym, trueSym])  then begin
_Value(V);
InsertValueIntoArray(A,  V);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_Value(V);
InsertValueIntoArray(A,  V);
end;
end;
if (fCurrentInputSymbol = _rbrackSym) then begin
Get;
end else if (fCurrentInputSymbol = EOFSYMB) OR
 (fCurrentInputSymbol = _lessSym) OR
 (fCurrentInputSymbol = _commaSym) OR
 (fCurrentInputSymbol = _rbraceSym) OR
 (fCurrentInputSymbol = _rbrackSym) then begin
ParseWarning(_rBrackSym,  '');
end else begin SynError(15);
end;
end;

procedure TJSONGrammar._Object (out  O:TJSONContainer);var  M:TJSONMember;
begin
M  :=  nil;
O  :=  TJSONContainer.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(O);
O.ContainerType  :=  jctObject;

Expect(_lbraceSym);
if (fCurrentInputSymbol = DQuotStringSym) then begin
_Member(M);
InsertMemberIntoObject(O,M);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_Member(M);
InsertMemberIntoObject(O,M);
end;
end;
if (fCurrentInputSymbol = _rbraceSym) then begin
Get;
end else if (fCurrentInputSymbol = EOFSYMB) OR
 (fCurrentInputSymbol = _lessSym) OR
 (fCurrentInputSymbol = _commaSym) OR
 (fCurrentInputSymbol = _rbraceSym) OR
 (fCurrentInputSymbol = _rbrackSym) then begin
ParseWarning(_rBraceSym,  '');
end else begin SynError(16);
end;
end;

procedure TJSONGrammar._JSONGrammar;var
      C:  TJSONCOntainer;
      Sc:  TJSONGrammarScanner;

begin
C  :=  nil;
FParseResult  :=  TJSONDocument.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(FParseResult  as  TJSONDocument);
if (fCurrentInputSymbol = _lbraceSym) OR
 (fCurrentInputSymbol = _lbrackSym) then begin
if (fCurrentInputSymbol = _lbraceSym) then begin
_Object(C);
InsertContainerIntoDocument(FParseResult  as  TJSONDocument,  C);
end else begin
_Array(C);
InsertContainerIntoDocument(FParseResult  as  TJSONDocument,  C);
end;
end;
if (fCurrentInputSymbol = _lessSym) then begin
Get;
//Trailing  HTML  in  inline  script:  </script>
Sc  :=  (Scanner  as  TJSONGrammarScanner);
StreamPartRead  :=  Sc.BufferPosition;

end else if (fCurrentInputSymbol = EOFSYMB) then begin
Get;
end else begin SynError(17);
end;
end;

function TJSONGrammar.GetBuildDate : TDateTime;
const
  BDate = 42512;
  Hour = 22;
  Min = 50;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TJSONGrammar.GetVersion : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TJSONGrammar.GetVersionStr : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TJSONGrammar.GetVersionInfo : AnsiString;
begin
  Result := 'Comment: Parses JSON data embedded in HTML.' + #13#10 +
'Author: Martin Harvey' + #13#10 +
'Copyright: (c) Martin Harvey';
end;

procedure TJSONGrammar.SetVersion(const Value : AnsiString);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TJSONGrammar.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_JSONGrammar;
end;  {Parse}

procedure TJSONGrammar.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
end; {InitSymSet}

end { JSONGrammar }.    
