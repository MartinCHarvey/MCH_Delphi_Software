unit HTMLGrammar;




{==============================================================================
HTMLGrammar
0.0.0.0
Date of Generation: 07/03/2020 19:18
Comment: Parses generalised HTML. XML strict matching or nesting not required.
Author: Martin Harvey
Copyright: (c) Martin Harvey

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,Trackables,HTMLNodes,HTMLEscapeHelper,DLList;



const
maxT = 20;
type
TScriptNestMode = (snmNone, snmScript,snmStyle);


  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EHTMLGrammar = class(Exception);
  THTMLGrammar = class;

  THTMLGrammarScanner = class(TCocoRScanner)
  private
    FOwner : THTMLGrammar;
function CharInIgnoreSet(const Ch : AnsiChar) : boolean;
procedure CheckLiteral(var Sym : integer);
function Equal(s : AnsiString) : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : THTMLGrammar read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { THTMLGrammarScanner }

  THTMLGrammar = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..15] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : AnsiString;
    function GetVersionStr : AnsiString;
    procedure SetVersion(const Value : AnsiString);
    function GetVersionInfo : AnsiString;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _HTMLLiteralChar (out S:string);
    procedure _HTMLAposValueChar (out S:string);
    procedure _HTMLQuotValueChar (out S:string);
    procedure _QueryChar (out S:string);
    procedure _SGMLChar (out S:string);
    procedure _IdentifierChar (out S: string);
    procedure _BaseNSequence (out S: string);
    procedure _NumericSequence (out S:string);
    procedure _HTMLTokenChar (out S:string);
    procedure _HTMLLiteralText (out S: string);
    procedure _HTMLEscapedChar (out StringLiteral: string);
    procedure _QueryText (out S:string);
    procedure _SGMLText (out S:string);
    procedure _HTMLTokenisedText (out StringLiteral: string);
    procedure _HTMLAposValueText (out S:string);
    procedure _HTMLQuotValueText (out S:string);
    procedure _TagRVal (var VP: THTMLValuePair);
    procedure _TagValuePair (out VP: THTMLValuePair);
    procedure _Identifier (out S: string);
    procedure _TagValuePairs (var Tag: THTMLTag);
    procedure _TagContents (var Tag:THTMLTag);
    procedure _Whitespace;
    procedure _QueryContents (var Tag:THTMLTag);
    procedure _TagName (var Tag:THTMLTag);
    procedure _SGMLContents (var Tag:THTMLTag);
    procedure _HTMLCleanText (out StringLiteral: string);
    procedure _HTMLTag (out T:THtmlTag);
    procedure _Script (var B: THTMLBlock; ExpectScript: boolean);
    procedure _HTMLBlock (out B: THTMLBlock; var NextTagEndScript: boolean);
    procedure _HTMLBlocks (var TempHead: TDLEntry);
    procedure _HTMLGrammar;

  private
    FScriptMode: TScriptNestMode;
    FDocType: THTMLDocType;
    FScriptStartLine, FScriptStartCol: integer;
    FParentObject: TObject;

  protected
    procedure ParseScript(Block: THTMLBlock);
    function CheckStartScriptTag(T: THTMLTag):boolean;
    procedure CheckEndScriptTag(T: THTMLTag);
    procedure RewindLexer(i: integer);
    procedure AdvanceLexer(i: integer);
    procedure MoveLexer(i: integer);
    procedure InsertBlockToListTail(var TempHead: TDLEntry; Block: THTMLBlock);
    procedure InsertDocToListHead(var TempHead: TDLEntry; Doc: THTMLDocument);
    procedure RemoveTempHead(var TempHead: TDLEntry);
    procedure AbortParse();

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString; override;
    procedure Execute; override;
    function GetScanner : THTMLGrammarScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : AnsiString read GetVersionStr;
    property VersionInfo : AnsiString read GetVersionInfo;

  public
    procedure SetLocation(N: THTMLNode);
    procedure ParseWarning(Code: integer; S:string);

    property ParentObject:TObject read FParentObject write FParentObject;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : AnsiString read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { THTMLGrammar }

implementation
uses  HTMLParser,HTMLParseEvents,StrUtils,CommonNodes,ErrorRecovery;



const

  EOFSYMB = 0;  TokOtherSym = 1;  TokDigitSym = 2;  TokLetterSym = 3;
  TokLinebreakSym = 4;  TokWhitespaceSym = 5;  TokQuotSym = 6;  TokAposSym = 7;
  _lessSym = 8;  _bangSym = 9;  _slashSym = 10;  _querySym = 11;
  _greaterSym = 12;  _equalSym = 13;  _andSym = 14;  _hashSym = 15;
  _semicolonSym = 16;  _minusSym = 17;  _underscoreSym = 18;  _colonSym = 19;
  NOSYMB = 20;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
{ Arbitrary code }
{

Copyright © 2020 Martin Harvey <martin_c_harvey@hotmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

}

procedure THTMLGrammar.ParseWarning(Code: integer; S: string);
var
  Sc: THTMLGrammarScanner;
begin
  Sc := (Scanner as THTMLGrammarScanner);
  if Assigned(ParentObject) and (ParentObject is THTMLParseItem) then
  begin
    (ParentObject as THTMLParseItem).EventList.Add(
      TParseEvent.CreateFromParseWarning(
      Sc.NextSymbol.Col, Sc.NextSymbol.Line, Code, ErrorStr(Code, AnsiString(S)) + AnsiString(S), self));
  end;
end;

procedure THTMLGrammar.MoveLexer(i: integer);
var
  Sc: THTMLGrammarScanner;

begin
  Sc := (Scanner as THTMLGrammarScanner);
  //Assumes we do not rewind / advance over cr/lf etc.
  Sc.BufferPosition := Sc.BufferPosition + i;

  if Sc.BufferPosition > 0 then
    Sc.LastInputCh := Sc.CurrentCh(Pred(Sc.BufferPosition))
  else
    Sc.LastInputCh := _EF;

  Sc.SrcStream.Seek(Sc.BufferPosition, soFromBeginning);
  Sc.CurrInputCh := Sc.CurrentCh(Sc.BufferPosition);
end;

procedure THTMLGrammar.RewindLexer(i: integer);
begin
  MoveLexer(-i);
end;

procedure THTMLGrammar.AdvanceLexer(i: integer);
begin
  MoveLexer(i);
end;

procedure THTMLGrammar.ParseScript(Block: THTMLBlock);
var
  Sc: THTMLGrammarScanner;
  StreamPos: Int64;
  HTMLParseItem: THTMLParseItem;
  Tag: THTMLScriptTag;
  TagHasSrcLink: boolean;
  ParseOK: boolean;
  BytesConsumed: int64;
  ParseSuccessful: boolean;
  ParseResult: TCommonNode;
  ErrRecover: THTMLErrorRecovery;
begin
  Sc := (Scanner as THTMLGrammarScanner);
  Tag := Block.Tag as THTMLScriptTag;
  Assert(Assigned(Block));
  Assert(Assigned(Tag));
  TagHasSrcLink := Assigned(Tag.FindValuePairByName('src'));
  Assert(Assigned(Tag.ScriptData));
  Assert(not Tag.FailedParse);
  Assert(DLItemIsEmpty(@Block.ContainedListHead));
  Assert(Tag.DocType = FDocType);
  Assert(Tag.DocType <> tdtHTML);

  //Create a copy of current input stream, from current position to end,
  //put that in the script data.
  StreamPos := Sc.SrcStream.Position;
  Tag.ScriptData.Seek(0, soFromBeginning);
  Tag.ScriptData.CopyFrom(Sc.SrcStream, Sc.SrcStream.Size - Sc.SrcStream.Position);
  Tag.ScriptData.Seek(0, soFromBeginning);
  Sc.SrcStream.Seek(StreamPos, soFromBeginning); //Don't disturb input stream.

  //Parse the script data.
  HTMLParseItem := ParentObject as THTMLParseItem;
  ParseSuccessful := HTMLParseItem.ParseCommon(Tag.DocType, Tag.ScriptData, ParseResult
{$IFDEF DEBUG_PARSERS}
                          , Tag.Line, Tag.Col
{$ENDIF}
                          , BytesConsumed);
  //BytesConsumed includes either a #0 (EOF) tacked on by the parser,
  //or alternatively, the "<" of the next "</script>" or "</style>",
  //and hence is one more char than the actual script data.

  if BytesConsumed > 0 then //All but most pathalogical of error cases.
    Dec(BytesConsumed);

  Tag.FailedParse := not (ParseSuccessful and Assigned(ParseResult));
  //Unnecessary Block.FixupChildContainedPtrsRec (done at end of HTML parse).
  //Unnecessary FixNodeStrings (done at end of HTML parse)
  if Tag.FailedParse then
  begin
    ErrRecover := THTMLErrorRecovery.Create;
    try
      if not ErrRecover.FindScriptEnd(Tag.ScriptData,
                                      BytesConsumed,
                                      Tag.DocType,
                                      BytesConsumed) then
        SynError(1006);
        //Things really are likely well and truly stuffed, not warning, but error.
        //TODO - AbortParse if we think script data will end up in the document?
    finally
      ErrRecover.Free;
    end;
  end;

  if not TagHasSrcLink then
  begin
    //If no source link then connect what we have.
    if Assigned(ParseResult) then
    begin
      Assert(DLItemIsEmpty(@Block.ContainedListHead));
      DLListInsertHead(@Block.ContainedListHead, @ParseResult.SiblingListEntry);
    end;
  end
  else
  begin
    //If we do have a source link, then check it's not utterly trivial (NULL).
    //If it is, then remove both the parse result, and the script data.
    //Prefer inline data to src links, but inline data shouldn't be NULL.
    //See also THTMLScriptTag.GenUnresolvedRef
    if Assigned(ParseResult) then
    begin
      if DlItemIsEmpty(@ParseResult.ContainedListHead) then
      begin
        //NULL document, free both result and source stream,
        //and code will later fetch src link.
        ParseResult.Free;
        ParseResult := nil;
      end
      else
      begin
        //Add result as usual.
        Assert(DLItemIsEmpty(@Block.ContainedListHead));
        DLListInsertHead(@Block.ContainedListHead, @ParseResult.SiblingListEntry);
      end;
    end;
    //And if for any reason no parse result, free the script data, rely
    //on later fetch from src link.
    if not Assigned(ParseResult) then
    begin
      Tag.ScriptData.Free;
      Tag.ScriptData := nil;
    end;
  end;

  if Assigned(Tag.ScriptData) then
    Tag.ScriptData.Size := BytesConsumed; //Trim script data if we still retain it.

  //Advance lexer to just after script data.
  AdvanceLexer(BytesConsumed);
end;

procedure THTMLGrammar.SetLocation(N: THTMLNode);
begin
  N.Line := (Scanner as THTMLGrammarScanner).CurrentSymbol.Line;
  N.Col := (Scanner as THTMLGrammarScanner).CurrentSymbol.Col;
end;

//Returns whether tag is opening script tag
function THTMLGrammar.CheckStartScriptTag(T: THTMLTag):boolean;
var
  ScriptType, ScriptSrc: THTMLValuePair;
begin
  result := false;
  if ((AnsiCompareText(T.Name, 'script') = 0)
    or (AnsiCompareText(T.Name,'style') = 0))
    and ((T.TagType  = ttOpen) or (T.TagType = ttComplete)) then
  begin
    Assert(T is THTMLScriptTag);
    result := (T.TagType = ttOpen);
    FScriptStartLine := (Scanner as THTMLGrammarScanner).CurrentSymbol.Line;
    FScriptStartCol := (Scanner as THTMLGrammarScanner).CurrentSymbol.Col;
    if (AnsiCompareText(T.Name, 'script') = 0) then
    begin
      FScriptMode := snmScript;
      FDocType := tdtHTML;

      //Work out what sort of script this is.
      ScriptType := T.FindValuePairByName('type');
      if Assigned(ScriptType) then
      begin
        if ContainsStr(ScriptType.ValData, 'javascript') then
          FDocType := tdtJScript
        else if ContainsStr(ScriptType.ValData, 'json') then
          FDocType := tdtJSon;
      end;

      //No luck working out script type? try src link...
      ScriptSrc := T.FIndValuePairByName('src');
      if (FDocType = tdtHTML) and Assigned(ScriptSrc) then
        FDocType := GetDocTypeFromURL(ScriptSrc.ValData); //Might set to unknown

      //Still no luck? Assume javascript.
      if (FDocType = tdtHTML) or (FDocType = tdtUnknown) then
        FDocType := tdtJScript;
    end
    else
    begin
      FScriptMode := snmStyle;
      FDocType := tdtCSS;
    end;

    (T as THTMLScriptTag).DocType := FDocType;
    if result then
    begin
      (T as THTMLScriptTag).ScriptData := TTrackedMemoryStream.Create;
      (T as THTMLScriptTag).ScriptData.Seek(0, soFromBeginning);
    end;
  end;
end;

procedure THTMLGrammar.CheckEndScriptTag(T:THTMLTag);
begin
  if ((AnsiCompareText(T.Name, 'script') = 0) and (FScriptMode = snmScript))
  or ((AnsiCompareText(T.Name, 'style') = 0) and (FScriptMode = snmStyle))
  and (T.TagType = ttClose) then
  begin
    if FScriptMode <> snmNone then
    begin
      FScriptMode := snmNone;
      FScriptStartLine := 0;
      FScriptStartCol := 0;
    end
    else
        ParseWarning(1005, '');
  end;
end;

procedure THTMLGrammar.InsertBlockToListTail(var TempHead: TDLEntry; Block: THTMLBlock);
begin
  if not Assigned(Block) then
    AbortParse;
  Assert(Block is THTMLBlock);
  Assert(DLItemIsEmpty(@Block.SiblingListEntry));
  DLListInsertTail(@TempHead, @Block.SiblingListEntry);
end;

procedure THTMLGrammar.InsertDocToListHead(var TempHead: TDLEntry; Doc: THTMLDocument);
begin
  if not Assigned(Doc) then
    AbortParse;
  Assert(Doc is THTMLDocument);
  Assert(DLItemIsEmpty(@Doc.ContainedListHead));
  DLListInsertHead(@TempHead, @Doc.ContainedListHead);
end;

procedure THTMLGrammar.RemoveTempHead(var TempHead: TDLEntry);
begin
  Assert(DLItemIsList(@TempHead));
  Assert(not DLItemIsEmpty(@TempHead));
  DLListRemoveList(@TempHead);
end;

procedure THTMLGrammar.AbortParse();
begin
  raise EParseAbort.Create(ErrorStr(1013, ''),
                (Scanner as THTMLGrammarScanner).NextSymbol.Line,
                (Scanner as THTMLGrammarScanner).NextSymbol.Col);
end;



{ --------------------------------------------------------------------------- }
{ ---- implementation for THTMLGrammarScanner ---- }

procedure THTMLGrammarScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}


function THTMLGrammarScanner.CharInIgnoreSet(const Ch : AnsiChar) : boolean;
begin
Result := FALSE;
end; {CharInIgnoreSet}

function THTMLGrammarScanner.Equal(s : AnsiString) : boolean;
var
  i : integer;
  q : int64;
begin
  if NextSymbol.Len <> Length(s) then
  begin
    Result := false;
    EXIT
  end;
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    if CurrentCh(q) <> s[i] then
    begin
      Result := false;
      EXIT;
    end;
    inc(i);
    inc(q);
  end;
  Result := true
end;  {Equal}

procedure THTMLGrammarScanner.CheckLiteral(var Sym : integer);
begin
case CurrentCh(bpCurrToken) of
  '#': if Equal('#') then
begin
sym := _hashSym;
end;

  ':': if Equal(':') then
begin
sym := _colonSym;
end;

else
begin
end
end
end; {CheckLiteral}


procedure THTMLGrammarScanner.Get(var sym : integer);
var
  state : integer;
  label __start_get;
 begin   {Get}
__start_get:
if NumEOLInComment > 0 then
begin
  BufferPosition := BufferPosition - 1;
  NumEOLInComment := NumEOLInComment - 1;
  CurrInputCh := _CR;
end;
while CharInIgnoreSet(CurrInputCh) do
  NextCh;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: begin
sym := TokOtherSym;
CheckLiteral(sym);
exit;
end;
   2: begin
sym := TokDigitSym;
exit;
end;
   3: begin
sym := TokLetterSym;
exit;
end;
   4: begin
sym := TokLinebreakSym;
exit;
end;
   5: begin
sym := TokWhitespaceSym;
exit;
end;
   6: begin
sym := TokQuotSym;
exit;
end;
   7: begin
sym := TokAposSym;
exit;
end;
   8: begin
sym := _lessSym;
exit;
end;
   9: begin
sym := _bangSym;
exit;
end;
  10: begin
sym := _slashSym;
exit;
end;
  11: begin
sym := _querySym;
exit;
end;
  12: begin
sym := _greaterSym;
exit;
end;
  13: begin
sym := _equalSym;
exit;
end;
  14: begin
sym := _andSym;
exit;
end;
  15: begin
sym := _semicolonSym;
exit;
end;
  16: begin
sym := _minusSym;
exit;
end;
  17: begin
sym := _underscoreSym;
exit;
end;
  18: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor THTMLGrammarScanner.Create;
begin
  inherited;
CurrentCh := CharAt;
fStartState[  0] :=  1; fStartState[  1] :=  1; fStartState[  2] :=  1; fStartState[  3] :=  1; 
fStartState[  4] :=  1; fStartState[  5] :=  1; fStartState[  6] :=  1; fStartState[  7] :=  1; 
fStartState[  8] :=  1; fStartState[  9] :=  5; fStartState[ 10] :=  4; fStartState[ 11] :=  1; 
fStartState[ 12] :=  1; fStartState[ 13] :=  4; fStartState[ 14] :=  1; fStartState[ 15] :=  1; 
fStartState[ 16] :=  1; fStartState[ 17] :=  1; fStartState[ 18] :=  1; fStartState[ 19] :=  1; 
fStartState[ 20] :=  1; fStartState[ 21] :=  1; fStartState[ 22] :=  1; fStartState[ 23] :=  1; 
fStartState[ 24] :=  1; fStartState[ 25] :=  1; fStartState[ 26] :=  1; fStartState[ 27] :=  1; 
fStartState[ 28] :=  1; fStartState[ 29] :=  1; fStartState[ 30] :=  1; fStartState[ 31] :=  1; 
fStartState[ 32] :=  5; fStartState[ 33] :=  9; fStartState[ 34] :=  6; fStartState[ 35] :=  1; 
fStartState[ 36] :=  1; fStartState[ 37] :=  1; fStartState[ 38] := 14; fStartState[ 39] :=  7; 
fStartState[ 40] :=  1; fStartState[ 41] :=  1; fStartState[ 42] :=  1; fStartState[ 43] :=  1; 
fStartState[ 44] :=  1; fStartState[ 45] := 16; fStartState[ 46] :=  1; fStartState[ 47] := 10; 
fStartState[ 48] :=  2; fStartState[ 49] :=  2; fStartState[ 50] :=  2; fStartState[ 51] :=  2; 
fStartState[ 52] :=  2; fStartState[ 53] :=  2; fStartState[ 54] :=  2; fStartState[ 55] :=  2; 
fStartState[ 56] :=  2; fStartState[ 57] :=  2; fStartState[ 58] :=  1; fStartState[ 59] := 15; 
fStartState[ 60] :=  8; fStartState[ 61] := 13; fStartState[ 62] := 12; fStartState[ 63] := 11; 
fStartState[ 64] :=  1; fStartState[ 65] :=  3; fStartState[ 66] :=  3; fStartState[ 67] :=  3; 
fStartState[ 68] :=  3; fStartState[ 69] :=  3; fStartState[ 70] :=  3; fStartState[ 71] :=  3; 
fStartState[ 72] :=  3; fStartState[ 73] :=  3; fStartState[ 74] :=  3; fStartState[ 75] :=  3; 
fStartState[ 76] :=  3; fStartState[ 77] :=  3; fStartState[ 78] :=  3; fStartState[ 79] :=  3; 
fStartState[ 80] :=  3; fStartState[ 81] :=  3; fStartState[ 82] :=  3; fStartState[ 83] :=  3; 
fStartState[ 84] :=  3; fStartState[ 85] :=  3; fStartState[ 86] :=  3; fStartState[ 87] :=  3; 
fStartState[ 88] :=  3; fStartState[ 89] :=  3; fStartState[ 90] :=  3; fStartState[ 91] :=  1; 
fStartState[ 92] :=  1; fStartState[ 93] :=  1; fStartState[ 94] :=  1; fStartState[ 95] := 17; 
fStartState[ 96] :=  1; fStartState[ 97] :=  3; fStartState[ 98] :=  3; fStartState[ 99] :=  3; 
fStartState[100] :=  3; fStartState[101] :=  3; fStartState[102] :=  3; fStartState[103] :=  3; 
fStartState[104] :=  3; fStartState[105] :=  3; fStartState[106] :=  3; fStartState[107] :=  3; 
fStartState[108] :=  3; fStartState[109] :=  3; fStartState[110] :=  3; fStartState[111] :=  3; 
fStartState[112] :=  3; fStartState[113] :=  3; fStartState[114] :=  3; fStartState[115] :=  3; 
fStartState[116] :=  3; fStartState[117] :=  3; fStartState[118] :=  3; fStartState[119] :=  3; 
fStartState[120] :=  3; fStartState[121] :=  3; fStartState[122] :=  3; fStartState[123] :=  1; 
fStartState[124] :=  1; fStartState[125] :=  1; fStartState[126] :=  1; fStartState[127] :=  1; 
fStartState[128] :=  1; fStartState[129] :=  1; fStartState[130] :=  1; fStartState[131] :=  1; 
fStartState[132] :=  1; fStartState[133] :=  1; fStartState[134] :=  1; fStartState[135] :=  1; 
fStartState[136] :=  1; fStartState[137] :=  1; fStartState[138] :=  1; fStartState[139] :=  1; 
fStartState[140] :=  1; fStartState[141] :=  1; fStartState[142] :=  1; fStartState[143] :=  1; 
fStartState[144] :=  1; fStartState[145] :=  1; fStartState[146] :=  1; fStartState[147] :=  1; 
fStartState[148] :=  1; fStartState[149] :=  1; fStartState[150] :=  1; fStartState[151] :=  1; 
fStartState[152] :=  1; fStartState[153] :=  1; fStartState[154] :=  1; fStartState[155] :=  1; 
fStartState[156] :=  1; fStartState[157] :=  1; fStartState[158] :=  1; fStartState[159] :=  1; 
fStartState[160] :=  1; fStartState[161] :=  1; fStartState[162] :=  1; fStartState[163] :=  1; 
fStartState[164] :=  1; fStartState[165] :=  1; fStartState[166] :=  1; fStartState[167] :=  1; 
fStartState[168] :=  1; fStartState[169] :=  1; fStartState[170] :=  1; fStartState[171] :=  1; 
fStartState[172] :=  1; fStartState[173] :=  1; fStartState[174] :=  1; fStartState[175] :=  1; 
fStartState[176] :=  1; fStartState[177] :=  1; fStartState[178] :=  1; fStartState[179] :=  1; 
fStartState[180] :=  1; fStartState[181] :=  1; fStartState[182] :=  1; fStartState[183] :=  1; 
fStartState[184] :=  1; fStartState[185] :=  1; fStartState[186] :=  1; fStartState[187] :=  1; 
fStartState[188] :=  1; fStartState[189] :=  1; fStartState[190] :=  1; fStartState[191] :=  1; 
fStartState[192] :=  1; fStartState[193] :=  1; fStartState[194] :=  1; fStartState[195] :=  1; 
fStartState[196] :=  1; fStartState[197] :=  1; fStartState[198] :=  1; fStartState[199] :=  1; 
fStartState[200] :=  1; fStartState[201] :=  1; fStartState[202] :=  1; fStartState[203] :=  1; 
fStartState[204] :=  1; fStartState[205] :=  1; fStartState[206] :=  1; fStartState[207] :=  1; 
fStartState[208] :=  1; fStartState[209] :=  1; fStartState[210] :=  1; fStartState[211] :=  1; 
fStartState[212] :=  1; fStartState[213] :=  1; fStartState[214] :=  1; fStartState[215] :=  1; 
fStartState[216] :=  1; fStartState[217] :=  1; fStartState[218] :=  1; fStartState[219] :=  1; 
fStartState[220] :=  1; fStartState[221] :=  1; fStartState[222] :=  1; fStartState[223] :=  1; 
fStartState[224] :=  1; fStartState[225] :=  1; fStartState[226] :=  1; fStartState[227] :=  1; 
fStartState[228] :=  1; fStartState[229] :=  1; fStartState[230] :=  1; fStartState[231] :=  1; 
fStartState[232] :=  1; fStartState[233] :=  1; fStartState[234] :=  1; fStartState[235] :=  1; 
fStartState[236] :=  1; fStartState[237] :=  1; fStartState[238] :=  1; fStartState[239] :=  1; 
fStartState[240] :=  1; fStartState[241] :=  1; fStartState[242] :=  1; fStartState[243] :=  1; 
fStartState[244] :=  1; fStartState[245] :=  1; fStartState[246] :=  1; fStartState[247] :=  1; 
fStartState[248] :=  1; fStartState[249] :=  1; fStartState[250] :=  1; fStartState[251] :=  1; 
fStartState[252] :=  1; fStartState[253] :=  1; fStartState[254] :=  1; fStartState[255] :=  1; 
end; {Create}


{ --------------------------------------------------------------------------- }
{ ---- implementation for THTMLGrammar ---- }

constructor THTMLGrammar.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := THTMLGrammarScanner.Create;
  GetScanner.Owner := self;
FParseTracker := TTracker.Create;
    FLangStr := 'HTML';

  InitSymSet;
end; {Create}

destructor THTMLGrammar.Destroy;
begin
  Scanner.Free;
FParseTracker.Free;

  inherited;
end; {Destroy}

function THTMLGrammar.ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'TokOther expected';
   2 : Result := 'TokDigit expected';
   3 : Result := 'TokLetter expected';
   4 : Result := 'TokLinebreak expected';
   5 : Result := 'TokWhitespace expected';
   6 : Result := 'TokQuot expected';
   7 : Result := 'TokApos expected';
   8 : Result := '"<" expected';
   9 : Result := '"!" expected';
  10 : Result := '"/" expected';
  11 : Result := '"?" expected';
  12 : Result := '">" expected';
  13 : Result := '"=" expected';
  14 : Result := '"&" expected';
  15 : Result := '"#" expected';
  16 : Result := '";" expected';
  17 : Result := '"-" expected';
  18 : Result := '"_" expected';
  19 : Result := '":" expected';
  20 : Result := 'not expected';
  21 : Result := 'invalid HTML character in freeform text';
  22 : Result := 'invalid Value character in tag=&quot;value&quot; in HTML tag';
  23 : Result := 'invalid Value character in tag=&quot;value&quot; in HTML tag';
  24 : Result := 'invalid Query tag character in <?query?>';
  25 : Result := 'invalid SGML character in <!SGMLTag>';
  26 : Result := 'invalid Character in textual identifier';
  27 : Result := 'invalid Character in tag=token in HTMLtag';
  28 : Result := 'invalid Escape sequence for HTML reserved characters';
  29 : Result := 'invalid HTML Tag value pair RVAL';
  30 : Result := 'invalid HTML Tag Value pair';
  31 : Result := 'invalid Whitespace to be skipped in HTML tag';
  32 : Result := 'invalid Uninterrupted text with no embedded tags';
  33 : Result := 'invalid HTML opening or closing tag';
  34 : Result := 'invalid one tag or contiguous section of text';

1000: Result := 'Tag start and end types do not match.';
    1001: Result := 'Cannot add <name, value> pair to tag. Duplicate name?';
    1004: Result := 'Unterminated or badly formed script at EOF';
    1005: Result := 'Too many </script> tags - not well formed.';
    1006: Result := 'Resync after script parse failed. Document likely garbage.';
    1007: Result := 'Unknown HTML escape code.';
    1008: Result := 'Unmatched quotes in script: ';
    1009: Result := 'Unmatched comments in script: ';
    1010: Result := 'Unmatched <![CDATA[]]> tags in script: ';
    1011: Result := 'Internal error, expected </script> but got char data.';
    1012: Result := 'Merged two tag value pairs together - whitespace around "="';
    1013: Result := 'Unable to continue after previous errors, aborting.';
    8888: Result := 'Internal error';
    9999: Result := '';
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := AnsiString('Error: ' + AnsiString(IntToStr(ErrorCode)));
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure THTMLGrammar.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;
  StreamPartRead := -1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure THTMLGrammar.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function THTMLGrammar.GetScanner : THTMLGrammarScanner;
begin
  Result := Scanner AS THTMLGrammarScanner;
end; {GetScanner}

function THTMLGrammar._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure THTMLGrammar._HTMLLiteralChar (out  S:string);begin
if _In(symSet[1], fCurrentInputSymbol) then begin
case fCurrentInputSymbol of
  TokOtherSym : begin
Get;
    end;
  _greaterSym : begin
Get;
    end;
  _semicolonSym : begin
Get;
    end;
  _slashSym : begin
Get;
    end;
  _bangSym : begin
Get;
    end;
  _querySym : begin
Get;
    end;
  TokLetterSym : begin
Get;
    end;
  TokDigitSym : begin
Get;
    end;
  _hashSym : begin
Get;
    end;
  _equalSym : begin
Get;
    end;
  TokQuotSym : begin
Get;
    end;
  TokAposSym : begin
Get;
    end;
  TokWhitespaceSym : begin
Get;
    end;
  TokLinebreakSym : begin
Get;
    end;
  _minusSym : begin
Get;
    end;
  _underscoreSym : begin
Get;
    end;
  _colonSym : begin
Get;
    end;
end;
S  :=  LexString;
end else if _In(symSet[2], fCurrentInputSymbol) then begin
end else begin SynError(21);
end;
end;

procedure THTMLGrammar._HTMLAposValueChar (out  S:string);begin
if _In(symSet[3], fCurrentInputSymbol) then begin
case fCurrentInputSymbol of
  TokOtherSym : begin
Get;
    end;
  _andSym : begin
Get;
    end;
  _lessSym : begin
Get;
    end;
  _greaterSym : begin
Get;
    end;
  _semicolonSym : begin
Get;
    end;
  _slashSym : begin
Get;
    end;
  _bangSym : begin
Get;
    end;
  _querySym : begin
Get;
    end;
  TokLetterSym : begin
Get;
    end;
  TokDigitSym : begin
Get;
    end;
  _hashSym : begin
Get;
    end;
  _equalSym : begin
Get;
    end;
  TokWhitespaceSym : begin
Get;
    end;
  _minusSym : begin
Get;
    end;
  _underscoreSym : begin
Get;
    end;
  TokQuotSym : begin
Get;
    end;
  _colonSym : begin
Get;
    end;
end;
S  :=  LexString;
end else if (fCurrentInputSymbol = TokLinebreakSym) then begin
Get;
S  :=  LexString;
end else begin SynError(22);
end;
end;

procedure THTMLGrammar._HTMLQuotValueChar (out  S:string);begin
if _In(symSet[4], fCurrentInputSymbol) then begin
case fCurrentInputSymbol of
  TokOtherSym : begin
Get;
    end;
  _andSym : begin
Get;
    end;
  _lessSym : begin
Get;
    end;
  _greaterSym : begin
Get;
    end;
  _semicolonSym : begin
Get;
    end;
  _slashSym : begin
Get;
    end;
  _bangSym : begin
Get;
    end;
  _querySym : begin
Get;
    end;
  TokLetterSym : begin
Get;
    end;
  TokDigitSym : begin
Get;
    end;
  _hashSym : begin
Get;
    end;
  _equalSym : begin
Get;
    end;
  TokWhitespaceSym : begin
Get;
    end;
  _minusSym : begin
Get;
    end;
  _underscoreSym : begin
Get;
    end;
  TokAposSym : begin
Get;
    end;
  _colonSym : begin
Get;
    end;
end;
S  :=  LexString;
end else if (fCurrentInputSymbol = TokLinebreakSym) then begin
Get;
S  :=  LexString;
end else begin SynError(23);
end;
end;

procedure THTMLGrammar._QueryChar (out  S:string);begin
if _In(symSet[5], fCurrentInputSymbol) then begin
case fCurrentInputSymbol of
  TokOtherSym : begin
Get;
    end;
  _andSym : begin
Get;
    end;
  _lessSym : begin
Get;
    end;
  _greaterSym : begin
Get;
    end;
  _semicolonSym : begin
Get;
    end;
  _slashSym : begin
Get;
    end;
  _bangSym : begin
Get;
    end;
  TokLetterSym : begin
Get;
    end;
  TokDigitSym : begin
Get;
    end;
  _hashSym : begin
Get;
    end;
  _equalSym : begin
Get;
    end;
  TokWhitespaceSym : begin
Get;
    end;
  TokQuotSym : begin
Get;
    end;
  TokAposSym : begin
Get;
    end;
  _minusSym : begin
Get;
    end;
  _underscoreSym : begin
Get;
    end;
  _colonSym : begin
Get;
    end;
end;
S  :=  LexString;
end else if (fCurrentInputSymbol = TokLinebreakSym) then begin
Get;
end else begin SynError(24);
end;
end;

procedure THTMLGrammar._SGMLChar (out  S:string);begin
if _In(symSet[6], fCurrentInputSymbol) then begin
case fCurrentInputSymbol of
  TokOtherSym : begin
Get;
    end;
  _andSym : begin
Get;
    end;
  _lessSym : begin
Get;
    end;
  _semicolonSym : begin
Get;
    end;
  _slashSym : begin
Get;
    end;
  _bangSym : begin
Get;
    end;
  _querySym : begin
Get;
    end;
  TokLetterSym : begin
Get;
    end;
  TokDigitSym : begin
Get;
    end;
  _hashSym : begin
Get;
    end;
  _equalSym : begin
Get;
    end;
  TokWhitespaceSym : begin
Get;
    end;
  TokQuotSym : begin
Get;
    end;
  TokAposSym : begin
Get;
    end;
  _minusSym : begin
Get;
    end;
  _underscoreSym : begin
Get;
    end;
  _colonSym : begin
Get;
    end;
end;
S  :=  LexString;
end else if (fCurrentInputSymbol = TokLinebreakSym) then begin
Get;
end else begin SynError(25);
end;
end;

procedure THTMLGrammar._IdentifierChar (out  S:  string);begin
case fCurrentInputSymbol of
  TokLetterSym : begin
Get;
    end;
  TokDigitSym : begin
Get;
    end;
  _minusSym : begin
Get;
    end;
  _underscoreSym : begin
Get;
    end;
  _bangSym : begin
Get;
    end;
  _querySym : begin
Get;
    end;
  _hashSym : begin
Get;
    end;
  _colonSym : begin
Get;
    end;
else begin SynError(26);
    end;
end;
S  :=  LexString;
end;

procedure THTMLGrammar._BaseNSequence (out  S:  string);begin
Expect(TokLetterSym);
S  :=  LexString;
while (fCurrentInputSymbol = TokDigitSym) OR
 (fCurrentInputSymbol = TokLetterSym) do begin
if (fCurrentInputSymbol = TokLetterSym) then begin
Get;
end else begin
Get;
end;
S  :=  S  +  LexString;
end;
end;

procedure THTMLGrammar._NumericSequence (out  S:string);begin
Expect(TokDigitSym);
S  :=  LexString;
while (fCurrentInputSymbol = TokDigitSym) do begin
Get;
S  :=  S  +  LexString;
end;
end;

procedure THTMLGrammar._HTMLTokenChar (out  S:string);begin
if _In(symSet[7], fCurrentInputSymbol) then begin
case fCurrentInputSymbol of
  TokOtherSym : begin
Get;
    end;
  _andSym : begin
Get;
    end;
  _lessSym : begin
Get;
    end;
  _semicolonSym : begin
Get;
    end;
  _slashSym : begin
Get;
    end;
  _bangSym : begin
Get;
    end;
  _querySym : begin
Get;
    end;
  TokLetterSym : begin
Get;
    end;
  TokDigitSym : begin
Get;
    end;
  _hashSym : begin
Get;
    end;
  TokQuotSym : begin
Get;
    end;
  TokAposSym : begin
Get;
    end;
  _minusSym : begin
Get;
    end;
  _underscoreSym : begin
Get;
    end;
  _colonSym : begin
Get;
    end;
end;
S  :=  LexString;
end else if (fCurrentInputSymbol = TokQuotSym) then begin
Get;
_HTMLQuotValueText(S);
Expect(TokQuotSym);
end else if (fCurrentInputSymbol = TokAposSym) then begin
Get;
_HTMLAposValueText(S);
Expect(TokAposSym);
end else if (fCurrentInputSymbol = TokLinebreakSym) then begin
Get;
end else begin SynError(27);
end;
end;

procedure THTMLGrammar._HTMLLiteralText (out  S:  string);var  T:string;
begin
_HTMLLiteralChar(S);
while _In(symSet[1], fCurrentInputSymbol) do begin
_HTMLLiteralChar(T);
S  :=  S  +  T;
end;
end;

procedure THTMLGrammar._HTMLEscapedChar (out  StringLiteral:  string);var  IdStr:  string;  FailStr:  string;
     GoodTerminator:  boolean;
begin
StringLiteral  :=  '';
GoodTerminator  :=  false;
FailStr  :=  '&';
Expect(_andSym);
if _In(symSet[8], fCurrentInputSymbol) then begin
if (fCurrentInputSymbol = _hashSym) then begin
Get;
if (fCurrentInputSymbol = TokDigitSym) then begin
_NumericSequence(IdStr);
end else if (fCurrentInputSymbol = TokLetterSym) then begin
_BaseNSequence(IdStr);
end else begin SynError(28);
end;
StringLiteral  :=  LookupNumericEscape(self,  IdStr);
FailStr  :=  FailStr  +  '#'  +  IdStr;
end else begin
_Identifier(IdStr);
StringLiteral  :=  LookupIDEscape(self,  IdStr);
FailStr  :=  FailStr  +  IdStr;
end;
if (fCurrentInputSymbol = _semicolonSym) then begin
Get;
FailStr  :=  FailStr  +  ';';
GoodTerminator  :=  true;
end;
end;
if  (Length(StringLiteral)  =  0)  or  not  GoodTerminator  then
begin
   ParseWarning(1007,  '');
   StringLiteral  :=  FailStr;
end;

end;

procedure THTMLGrammar._QueryText (out  S:string);var  T:string;
begin
_QueryChar(S);
while _In(symSet[9], fCurrentInputSymbol) do begin
_QueryChar(T);
S  :=  S  +  T;
end;
end;

procedure THTMLGrammar._SGMLText (out  S:string);var  T:string;
begin
_SGMLChar(S);
while _In(symSet[10], fCurrentInputSymbol) do begin
_SGMLChar(T);
S  :=  S  +  T;
end;
end;

procedure THTMLGrammar._HTMLTokenisedText (out  StringLiteral:  string);var  T:string;
begin
_HTMLTokenChar(StringLiteral);
while _In(symSet[11], fCurrentInputSymbol) do begin
_HTMLTokenChar(T);
StringLiteral  :=  StringLiteral  +  T;
end;
end;

procedure THTMLGrammar._HTMLAposValueText (out  S:string);var  T:string;
begin
_HTMLAposValueChar(S);
while _In(symSet[12], fCurrentInputSymbol) do begin
_HTMLAposValueChar(T);
S  :=  S  +  T;
end;
end;

procedure THTMLGrammar._HTMLQuotValueText (out  S:string);var  T:string;
begin
_HTMLQuotValueChar(S);
while _In(symSet[13], fCurrentInputSymbol) do begin
_HTMLQuotValueChar(T);
S  :=  S  +  T;
end;
end;

procedure THTMLGrammar._TagRVal (var  VP:  THTMLValuePair);var  Val:  string;
begin
if (fCurrentInputSymbol = TokQuotSym) OR
 (fCurrentInputSymbol = TokAposSym) then begin
if (fCurrentInputSymbol = TokQuotSym) then begin
Get;
if _In(symSet[13], fCurrentInputSymbol) then begin
_HTMLQuotValueText(Val);
end;
Expect(TokQuotSym);
end else begin
Get;
if _In(symSet[12], fCurrentInputSymbol) then begin
_HTMLAposValueText(Val);
end;
Expect(TokAposSym);
end;
VP.ValData  :=  Val;  VP.ValType  :=  tvtString;
end else if _In(symSet[11], fCurrentInputSymbol) then begin
_HTMLTokenisedText(Val);

  Val.Trim;
  VP.ValData  :=  Val;  VP.ValType  :=  tvtTokenSequence;
end else begin SynError(29);
end;
end;

procedure THTMLGrammar._TagValuePair (out  VP:  THTMLValuePair);var  Name:  string;
begin
VP  :=  nil;
if _In(symSet[8], fCurrentInputSymbol) then begin
_Identifier(Name);

VP  :=  THTMLValuePair.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(VP);
Name.Trim;
VP.ValName  :=  Name;

if (fCurrentInputSymbol = _equalSym) then begin
Get;
_TagRVal(VP);
end;
end else if (fCurrentInputSymbol = _equalSym) then begin
Get;

VP  :=  THTMLValuePair.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(VP);

_TagRVal(VP);
end else begin SynError(30);
end;
end;

procedure THTMLGrammar._Identifier (out  S:  string);var  T:string;
begin
_IdentifierChar(S);
while _In(symSet[8], fCurrentInputSymbol) do begin
_IdentifierChar(T);
S  :=  S  +  T;
end;
end;

procedure THTMLGrammar._TagValuePairs (var  Tag:  THTMLTag);var  VP:  THTMLValuePair;
     OK:  boolean;
     Merged:  boolean;

begin
_TagValuePair(VP);

  Tag.AddValuePair(VP,  OK,  Merged);
  if  not  OK  then
  begin
    ParseWarning(1001,  '');
    VP.Free;
  end;
  Assert(not  Merged);

if (fCurrentInputSymbol = TokLinebreakSym) OR
 (fCurrentInputSymbol = TokWhitespaceSym) then begin
_Whitespace;
end;
while _In(symSet[14], fCurrentInputSymbol) do begin
_TagValuePair(VP);

  Tag.AddValuePair(VP,  OK,  Merged);
  if  not  OK  then
  begin
    ParseWarning(1001,  '');
    VP.Free;
  end
  else  if  Merged  then
  begin
    ParseWarning(1012,  '');
    VP.Free;
  end;

if (fCurrentInputSymbol = TokLinebreakSym) OR
 (fCurrentInputSymbol = TokWhitespaceSym) then begin
_Whitespace;
end;
end;
end;

procedure THTMLGrammar._TagContents (var  Tag:THTMLTag);begin
if _In(symSet[14], fCurrentInputSymbol) then begin
_TagValuePairs(Tag);
end;
end;

procedure THTMLGrammar._Whitespace;begin
if (fCurrentInputSymbol = TokWhitespaceSym) then begin
Get;
end else if (fCurrentInputSymbol = TokLinebreakSym) then begin
Get;
end else begin SynError(31);
end;
while (fCurrentInputSymbol = TokLinebreakSym) OR
 (fCurrentInputSymbol = TokWhitespaceSym) do begin
if (fCurrentInputSymbol = TokWhitespaceSym) then begin
Get;
end else begin
Get;
end;
end;
end;

procedure THTMLGrammar._QueryContents (var  Tag:THTMLTag);var  S:string;  VP:  THTMLValuePair;  OK,  M:  boolean;
begin
_QueryText(S);
VP  :=  THTMLValuePair.CreateWithTracker(FParseTracker  as  TTracker);
VP.ValName  :=  'TagContents';
VP.ValData  :=  S;
VP.ValType  :=  tvtString;
Tag.AddValuePair(VP,  OK,  M);
Assert(OK);
Assert(not  M);

end;

procedure THTMLGrammar._TagName (var  Tag:THTMLTag);var  S:string;
begin
_Identifier(S);
Tag.Name  :=  S;
end;

procedure THTMLGrammar._SGMLContents (var  Tag:THTMLTag);var  S:string;  VP:  THTMLValuePair;  OK,  M:  boolean;
begin
_SGMLText(S);
VP  :=  THTMLValuePair.CreateWithTracker(FParseTracker  as  TTracker);
VP.ValName  :=  'TagContents';
VP.ValData  :=  S;
VP.ValType  :=  tvtString;
Tag.AddValuePair(VP,  OK,  M);
Assert(OK);
Assert(not  M);

end;

procedure THTMLGrammar._HTMLCleanText (out  StringLiteral:  string);var  S1,  S2:  string;
begin
if (fCurrentInputSymbol = _andSym) then begin
_HTMLEscapedChar(S1);
_HTMLCleanText(S2);
StringLiteral  :=  S1  +  S2;
end else if _In(symSet[2], fCurrentInputSymbol) then begin
_HTMLLiteralText(StringLiteral);
end else begin SynError(32);
end;
end;

procedure THTMLGrammar._HTMLTag (out  T:THtmlTag);
var  Tmp:  THTMLTag;

procedure  CreateSpecificScriptTag;
begin
   if  (AnsiCompareText(T.Name,  'script')  =  0)
     or  (AnsiCompareText(T.Name,  'style')  =  0)  then
   begin
     Tmp  :=  THTMLScriptTag.CreateWithTracker(FParseTracker  as  TTracker);
     SetLocation(Tmp);
     Tmp.TagType  :=  T.TagType;
     Tmp.Name  :=  T.Name;
     T.Free;
     T  :=  Tmp;
   end;
end;

begin
T  :=  THTMLTag.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(T);
Expect(_lessSym);
T.TagType  :=  ttOpen;
if (fCurrentInputSymbol = _bangSym) then begin
Get;
T.TagType  :=  ttPling;
_SGMLContents(T);
end else if (fCurrentInputSymbol = _slashSym) then begin
Get;
T.TagType  :=  ttClose;
_TagName(T);
CreateSpecificScriptTag;
end else if (fCurrentInputSymbol = _querySym) then begin
Get;
T.tagType  :=  ttQuery;
_QueryContents(T);
Expect(_querySym);
end else if _In(symSet[8], fCurrentInputSymbol) then begin
_TagName(T);
CreateSpecificScriptTag;
if (fCurrentInputSymbol = TokLinebreakSym) OR
 (fCurrentInputSymbol = TokWhitespaceSym) then begin
_Whitespace;
end;
_TagContents(T);
if (fCurrentInputSymbol = TokLinebreakSym) OR
 (fCurrentInputSymbol = TokWhitespaceSym) then begin
_Whitespace;
end;
if (fCurrentInputSymbol = _slashSym) then begin
Get;
if  T.TagType  <>  ttOpen  then
        SynError(1000)
      else
        T.TagType  :=  ttComplete;
end;
end else begin SynError(33);
end;
Expect(_greaterSym);
end;

procedure THTMLGrammar._Script (var  B:  THTMLBlock;  ExpectScript:  boolean);begin
if  not  ExpectScript  then
   exit;
RewindLexer(2);
ParseScript(B);

Get;
end;

procedure THTMLGrammar._HTMLBlock (out  B:  THTMLBlock;  var  NextTagEndScript:  boolean);var
      S:  string;
      T:  THTMLTag;
      ExpectScript:  boolean;

begin
B  :=  THTMLBlock.CreateWithTracker(FParseTracker  as  TTracker);
SetLocation(B);
B.Line  :=  (Scanner  as  THTMLGrammarScanner).NextSymbol.Line;
B.Col  :=  (Scanner  as  THTMLGrammarScanner).NextSymbol.Col;

if (fCurrentInputSymbol = _lessSym) then begin
_HTMLTag(T);
B.Tag  :=  T;
T.ContainerNode  :=  B;
if  NextTagEndScript  then
   CheckEndScriptTag(T);
ExpectScript  :=  CheckStartScriptTag(T);

_Script(B,  ExpectScript);
NextTagEndScript  :=  ExpectScript;
end else if _In(symSet[2], fCurrentInputSymbol) then begin
_HTMLCleanText(S);

   if  NextTagEndScript  then
   begin
     ParseWarning(1011,'');
     NextTagEndScript  :=  false;
   end;
   B.Text  :=  S;

end else begin SynError(34);
end;
end;

procedure THTMLGrammar._HTMLBlocks (var  TempHead:  TDLEntry);var
      B:  THTMLBlock;
      NextTagEndScript:  boolean;

begin
NextTagEndScript  :=  false;
_HTMLBlock(B,  NextTagEndScript);
InsertBlockToListTail(TempHead,  B);
while _In(symSet[15], fCurrentInputSymbol) do begin
_HTMLBlock(B,  NextTagEndScript);
InsertBlockToListTail(TempHead,  B);
end;
end;

procedure THTMLGrammar._HTMLGrammar;var  TempHead:  TDLEntry;
begin
DLItemInitList(@TempHead);
_HTMLBlocks(TempHead);

     FParseResult  :=  THTMLDocument.CreateWithTracker(FParseTracker  as  TTracker);
     SetLocation(FParseResult  as  THTMLDocument);
     InsertDocToListHead(TempHead,  FParseResult  as  THTMLDocument);
     RemoveTempHead(TempHead);
     (FParseResult  as  THTMLDocument).FixupChildContainedPtrs;

Expect(EOFSYMB);

  if  not  (FScriptMode  =  snmNone)  then
  begin
    ParseWarning(1004,  '');
    ParseWarning(9999,  'Script  start  line:  '  +IntToStr(FScriptStartLine));
    ParseWarning(9999,  'Script  start  column:  '+IntToStr(FScriptStartCol));
  end;

end;

function THTMLGrammar.GetBuildDate : TDateTime;
const
  BDate = 42512;
  Hour = 22;
  Min = 50;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function THTMLGrammar.GetVersion : AnsiString;
begin
  Result := '0.0.0.0';
end;

function THTMLGrammar.GetVersionStr : AnsiString;
begin
  Result := '0.0.0.0';
end;

function THTMLGrammar.GetVersionInfo : AnsiString;
begin
  Result := 'Comment: Parses generalised HTML. XML strict matching or nesting not required.' + #13#10 +
'Author: Martin Harvey' + #13#10 +
'Copyright: (c) Martin Harvey';
end;

procedure THTMLGrammar.SetVersion(const Value : AnsiString);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure THTMLGrammar.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_HTMLGrammar;
end;  {Parse}

procedure THTMLGrammar.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 1, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokLinebreakSym, 
                    TokWhitespaceSym, TokQuotSym, TokAposSym, _bangSym, 
                    _slashSym, _querySym, _greaterSym, _equalSym, _hashSym];
symSet[ 1, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[ 2, 0] := [EOFSYMB, TokOtherSym, TokDigitSym, TokLetterSym, 
                    TokLinebreakSym, TokWhitespaceSym, TokQuotSym, 
                    TokAposSym, _lessSym, _bangSym, _slashSym, _querySym, 
                    _greaterSym, _equalSym, _andSym, _hashSym];
symSet[ 2, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[ 3, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokWhitespaceSym, 
                    TokQuotSym, _lessSym, _bangSym, _slashSym, _querySym, 
                    _greaterSym, _equalSym, _andSym, _hashSym];
symSet[ 3, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[ 4, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokWhitespaceSym, 
                    TokAposSym, _lessSym, _bangSym, _slashSym, _querySym, 
                    _greaterSym, _equalSym, _andSym, _hashSym];
symSet[ 4, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[ 5, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokWhitespaceSym, 
                    TokQuotSym, TokAposSym, _lessSym, _bangSym, _slashSym, 
                    _greaterSym, _equalSym, _andSym, _hashSym];
symSet[ 5, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[ 6, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokWhitespaceSym, 
                    TokQuotSym, TokAposSym, _lessSym, _bangSym, _slashSym, 
                    _querySym, _equalSym, _andSym, _hashSym];
symSet[ 6, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[ 7, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokQuotSym, 
                    TokAposSym, _lessSym, _bangSym, _slashSym, _querySym, 
                    _andSym, _hashSym];
symSet[ 7, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[ 8, 0] := [TokDigitSym, TokLetterSym, _bangSym, _querySym, _hashSym];
symSet[ 8, 1] := [_minusSym-16, _underscoreSym-16, _colonSym-16];
symSet[ 9, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokLinebreakSym, 
                    TokWhitespaceSym, TokQuotSym, TokAposSym, _lessSym, 
                    _bangSym, _slashSym, _greaterSym, _equalSym, _andSym, 
                    _hashSym];
symSet[ 9, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[10, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokLinebreakSym, 
                    TokWhitespaceSym, TokQuotSym, TokAposSym, _lessSym, 
                    _bangSym, _slashSym, _querySym, _equalSym, _andSym, 
                    _hashSym];
symSet[10, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[11, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokLinebreakSym, 
                    TokQuotSym, TokAposSym, _lessSym, _bangSym, _slashSym, 
                    _querySym, _andSym, _hashSym];
symSet[11, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[12, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokLinebreakSym, 
                    TokWhitespaceSym, TokQuotSym, _lessSym, _bangSym, 
                    _slashSym, _querySym, _greaterSym, _equalSym, _andSym, 
                    _hashSym];
symSet[12, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[13, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokLinebreakSym, 
                    TokWhitespaceSym, TokAposSym, _lessSym, _bangSym, 
                    _slashSym, _querySym, _greaterSym, _equalSym, _andSym, 
                    _hashSym];
symSet[13, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
symSet[14, 0] := [TokDigitSym, TokLetterSym, _bangSym, _querySym, 
                    _equalSym, _hashSym];
symSet[14, 1] := [_minusSym-16, _underscoreSym-16, _colonSym-16];
symSet[15, 0] := [TokOtherSym, TokDigitSym, TokLetterSym, TokLinebreakSym, 
                    TokWhitespaceSym, TokQuotSym, TokAposSym, _lessSym, 
                    _bangSym, _slashSym, _querySym, _greaterSym, _equalSym, 
                    _andSym, _hashSym];
symSet[15, 1] := [_semicolonSym-16, _minusSym-16, _underscoreSym-16, 
                    _colonSym-16];
end; {InitSymSet}

end { HTMLGrammar }.    
