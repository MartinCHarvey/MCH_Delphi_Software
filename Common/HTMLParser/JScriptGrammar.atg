$W- //Don't treat space as whitespace.
COMPILER JScriptGrammar

DELPHI
  USES (INTERFACE) Trackables, CommonNodes, JSNodes
  USES (IMPLEMENTATION) HTMLParser, HTMLParseEvents, StrUtils, IOUtils, DLList

  PRIVATE
    FParentObject: TObject;
  PROTECTED
{$IFDEF DEBUG_TOKENS}
    procedure DebugLogToken(Sender : TObject; var CurrentInputSymbol : integer);
{$ENDIF}
    procedure RewindLexer(i: integer);
    procedure AbortParse;
    procedure InsertStmtTail(C: TJSNode; S: TJSStatement; CheckNeighbours:boolean = true);
    procedure InsertStmtHead(C: TJSNode; S: TJSStatement; CheckNeighbours:boolean = true);
    procedure InsertExprTail(C: TJSNode; E: TJSExpr; CheckNeighbours:boolean = true);
    procedure InsertExprHead(C: TJSNode; E: TJSExpr; CheckNeighbours:boolean = true);
    procedure InsertExprListTail(C: TJSNode; EL: TJSExprList; CheckNeighbours:boolean = true);
    procedure InsertTagGroupTail(C: TJSNode; TG: TJSTagGroup; CheckNeighbours:boolean = true);
    function RemoveExprHead(C: TJSNode; CheckNeighbours:boolean = true): TJSExpr;
  PUBLIC
    procedure SetLocation(N: TJSNode);
    procedure ParseWarning(Code: integer; S: string);
    property ParentObject:TObject read FParentObject write FParentObject;
  CREATE
    FParseTracker := TTracker.Create;
{$IFDEF DEBUG_TOKENS}
    AfterGet := DebugLogToken;
{$ENDIF}
    FLangStr := 'JScript';
  DESTROY
    FParseTracker.Free;
  ERRORS
    1000: Result := 'Expected an L value on the left of an assignment expression';
    1001: Result := 'Expected an L value on the left side of the in operator';
    1002: Result := 'Cannot have for loop iterators after for-in binding';
    1003: Result := 'Cannot have multiple variable declarations before for-in binding';
    1004: Result := 'Label expression must be a bare identifier.';
    1005: Result := 'Try statement should be followed by catch / finally.';
    1006: Result := 'functions should only be defined at top level in other functions';
    1007: Result := 'found HTML encapsulation in Javascript, ignored.';
    1008: Result := '"default" used as identifier.';
    1009: Result := '"catch" used as identifier.';
    1010: Result := '"return"used as an identifier.';
    1011: Result := 'switch statement has duplicate labels.';
    1012: Result := 'Unable to continue after previous errors, aborting.';
    1013: Result := '"delete"used as an identifier.';
    1014: Result := '"then"used as an identifier.';
    1015: Result := '"for"used as an identifier.';
    1016: Result := '"return"used as object literal field.';
    1017: Result := '"default" used as object literal field.';
    1018: Result := '"catch" used as object literal field.';
    1019: Result := '"delete"used as an object literal field.';
    1020: Result := '"then"used as an object literal field.';
    1021: Result := '"for"used as an object literal field.';
END_DELPHI

{ Arbitrary code }

{

Copyright © 2020 Martin Harvey <martin_c_harvey@hotmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

}

{$IFDEF DEBUG_TOKENS}
procedure T-->Grammar<--.DebugLogToken(Sender : TObject; var CurrentInputSymbol : integer);
var
  LogStr: AnsiString;
  LexStr: AnsiString;
  DbgLexChar: AnsiString;
begin
  LexStr := LexString;
  if Length(LexStr) > 0 then
    DbgLexChar := AnsiString(IntToStr(Byte(LexString[1])) + ' ')
  else
    DbgLexChar := '';

  LogStr := AnsiString(IntToStr(CurrentInputSymbol) + ' : ' + DbgLexChar +  LexString + CHR(13) + CHR(10));
  Assert(false); //Reinsert logging call.
  //GLogLog(SV_TRACE, LogStr);
end;

{$ENDIF}

procedure T-->Grammar<--.AbortParse;
begin
  raise EParseAbort.Create(ErrorStr(1012, ''),
                (Scanner as T-->Grammar<--Scanner).NextSymbol.Line,
                (Scanner as T-->Grammar<--Scanner).NextSymbol.Col);
end;

procedure T-->Grammar<--.ParseWarning(Code: integer; S: string);
var
  Sc: T-->Grammar<--Scanner;
begin
  Sc := (Scanner as T-->Grammar<--Scanner);
  if Assigned(ParentObject) and (ParentObject is THTMLParseItem) then
  begin
    (ParentObject as THTMLParseItem).EventList.Add(
      TParseEvent.CreateFromParseWarning(
      Sc.NextSymbol.Col, Sc.NextSymbol.Line, Code, ErrorStr(Code, AnsiString(S)) + AnsiString(S), self));
  end;
end;

procedure T-->Grammar<--.SetLocation(N: TJSNode);
begin
  N.Line := (Scanner as T-->Grammar<--Scanner).CurrentSymbol.Line;
  N.Col := (Scanner as T-->Grammar<--Scanner).CurrentSymbol.Col;
end;

//TODO - this messes up symbol line and column positions.
//Needs investigating.
procedure T-->Grammar<--.RewindLexer(i: integer);
var
  Sc: T-->Grammar<--Scanner;

begin
  Sc := (Scanner as T-->Grammar<--Scanner);
  //Assumes we do not rewind over cr/lf etc.
  Sc.BufferPosition := Sc.BufferPosition - i;

  if Sc.BufferPosition > 0 then
    Sc.LastInputCh := Sc.CurrentCh(Pred(Sc.BufferPosition))
  else
    Sc.LastInputCh := _EF;

  Sc.SrcStream.Seek(Sc.BufferPosition, soFromBeginning);
  Sc.CurrInputCh := Sc.CurrentCh(Sc.BufferPosition);
end;


procedure T-->Grammar<--.InsertStmtTail(C: TJSNode; S: TJSStatement; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(S) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := S.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(S is TJSStatement);
  Assert(DLItemIsEmpty(@S.SiblingListEntry));
  DLListInsertTail(@C.ContainedListHead, @S.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := S.SiblingListEntry.FLink.Owner;
    NO := S.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSStatement));
    Assert((not Assigned(NO)) or (NO is TJSStatement));
  end;
{$ENDIF}
end;

procedure T-->Grammar<--.InsertStmtHead(C: TJSNode; S: TJSStatement; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(S) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := S.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(S is TJSStatement);
  Assert(DLItemIsEmpty(@S.SiblingListEntry));
  DLListInsertHead(@C.ContainedListHead, @S.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := S.SiblingListEntry.FLink.Owner;
    NO := S.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSStatement));
    Assert((not Assigned(NO)) or (NO is TJSStatement));
  end;
{$ENDIF}
end;

procedure T-->Grammar<--.InsertExprTail(C: TJSNode; E: TJSExpr; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(E) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := E.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(E is TJSExpr);
  Assert(DLItemIsEmpty(@E.SiblingListEntry));
  DLListInsertTail(@C.ContainedListHead, @E.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := E.SiblingListEntry.FLink.Owner;
    NO := E.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSExpr));
    Assert((not Assigned(NO)) or (NO is TJSExpr));
  end;
{$ENDIF}
end;

procedure T-->Grammar<--.InsertExprHead(C: TJSNode; E: TJSExpr; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(E) then
    AbortParse;
  Assert(C is TJSNode);
  Assert(E is TJSExpr);
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := E.ClassName;
{$ENDIF}
  Assert(DLItemIsEmpty(@E.SiblingListEntry));
  DLListInsertHead(@C.ContainedListHead, @E.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := E.SiblingListEntry.FLink.Owner;
    NO := E.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSExpr));
    Assert((not Assigned(NO)) or (NO is TJSExpr));
  end;
{$ENDIF}
end;

procedure T-->Grammar<--.InsertExprListTail(C: TJSNode; EL: TJSExprList; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(EL) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := EL.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(EL is TJSExprList);
  Assert(DLItemIsEmpty(@EL.SiblingListEntry));
  DLListInsertTail(@C.ContainedListHead, @EL.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := EL.SiblingListEntry.FLink.Owner;
    NO := EL.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSExprList));
    Assert((not Assigned(NO)) or (NO is TJSExprList));
  end;
{$ENDIF}
end;

procedure T-->Grammar<--.InsertTagGroupTail(C: TJSNode; TG: TJSTagGroup; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(TG) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := TG.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(TG is TJSTagGroup);
  Assert(DLItemIsEmpty(@TG.SiblingListEntry));
  DLListInsertTail(@C.ContainedListHead, @TG.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := TG.SiblingListEntry.FLink.Owner;
    NO := TG.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSTagGroup));
    Assert((not Assigned(NO)) or (NO is TJSTagGroup));
  end;
{$ENDIF}
end;

function T-->Grammar<--.RemoveExprHead(C: TJSNode; CheckNeighbours:boolean): TJSExpr;
var
  O: TObject;
  E: PDLEntry;
{$IFOPT C+}
  NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    NO := C.ContainedListHead.FLink.Flink.Owner;
    Assert(not Assigned(NO) or (NO is TJSExpr));
  end;
{$ENDIF}
  E := DLListRemoveHead(@C.ContainedListHead);
  if not Assigned(E) then
    AbortParse;
  Assert(Assigned(E.Owner));
  O := E.Owner;
{$IFOPT C+}
  DebugStr2 := O.ClassName;
{$ENDIF}
  Assert(O is TJSExpr);
  result := TJSExpr(O);
end;

CHARACTERS

    cr = CHR(13) .
    lf = CHR(10) .
    tab = CHR(9) .
    space = " " .
    dquot = CHR(34) .
    squot = "'" .
    backslash = CHR(92) .
    nonascii = CHR(128)..CHR(255) .
    digit = "0123456789" .
    hexDigit = "0123456789abcdefABCDEF" .
    letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$" .
    dqChar = ANY - dquot - lf - cr - backslash .
    sqChar = ANY - squot - lf - cr - backslash .
    singleEsc = ANY - cr - lf .

TOKENS
    //HTML comment delimiters around decent javascript.
    HtmlEncapsulation1 = "<!--" .
    HtmlEncapsulation2 = "//-->" .        //Prob never encounters this
    HtmlEncapsulation3 = "<![CDATA[[" .   //Remainder of tag probably cut off? "//>" .
    HtmlEncapsulation4 = "<!]]>>" .

    _Identifier = (letter | nonascii) { (letter | digit | nonascii) } .

  //TODO - this is a real number specification.
  //Need hex octal etc constants.

    _Number = (  //Decimal or real number.
               ( ( digit { digit }
                 [ "." { digit } ] )
                 |
                 ( "." digit { digit } )
               )
               [ ( "e" | "E" ) [ "-" | "+" ] digit { digit } ]
             )
             |
             (  //Hex number
               "0x" hexDigit { hexDigit }
             )
             //TODO - octal or bin?
             .

    DQuotString =
      dquot
      {
        dqChar //String char.
        |
        (
          "\" //Escape sequence.
          (
            ( //Zero escape
              "0"
            )
            |
            ( //Unicode escape
              "u" hexDigit hexDigit hexDigit hexDigit
            )
            |
            ( //Unicode escape (variant 2)
              "u{"
                hexDigit hexDigit hexDigit hexDigit
              "}"
            )
            |
            ( //Hex escape
              "x" hexDigit hexDigit
            )
            |
            (
              (cr [lf])
              |
              (lf [cr])
            )
            |
            ( //Single char escape sequence.
              singleEsc
            )
          )
        )
      }
      dquot .

    SQuotString =
      squot
      {
        sqChar //String char.
        |
        (
          "\" //Escape sequence.
          (
            ( //Zero escape
              "0"
            )
            |
            ( //Unicode escape
              "u" hexDigit hexDigit hexDigit hexDigit
            )
            |
            ( //Unicode escape (variant 2)
            "u{"
              hexDigit hexDigit hexDigit hexDigit
            "}"
            )
            |
            ( //Hex escape
              "x" hexDigit hexDigit
            )
            |
            (
              (cr [lf])
              |
              (lf [cr])
            )
            |
            ( //Single char escape sequence.
              singleEsc
            )
          )
        )
      }
      squot .

IGNORE  cr + lf + tab + space

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO   lf

PRODUCTIONS

  Identifier<out I:TJSIdentifier> DESCRIPTION "Identifier"
  =
                                (. I := TJSIdentifier.CreateWithTracker(FParseTracker as TTracker);
                                   I.ExprType := etSimpleExpression;
                                   I.SimpleExprType := setIdentifier;
                                .)
    _Identifier                 (. I.Name := LexString; .)
  .

  Number<out N:TJSNumber> DESCRIPTION "Number"
  =
                                (. N := TJSNumber.CreateWithTracker(FParseTracker as TTracker);
                                   N.ExprType := etSimpleExpression;
                                   N.SimpleExprType := setNumber;
                                .)
    _Number                     (. N.StringRep := LexString;
                                   try
                                     N.IntValue := StrToInt(N.StringRep);
                                     N.IntValid := true;
                                   except
                                     on E:Exception do N.IntValid := false;
                                   end;
                                   try
                                     N.Int64Value := StrToInt64(N.StringRep);
                                     N.Int64Valid := true;
                                   except
                                     on E:Exception do N.Int64Valid := false;
                                   end;
                                   try
                                     N.FloatValue := StrToFloat(N.StringRep);
                                     N.FloatValid := true;
                                   except
                                     on E:Exception do N.FloatValid := false;
                                   end;
                                .)

  .

  RegularExpressionEscapeSequence<var Res: string> DESCRIPTION "Regular expression escape sequence"
        (. var Sc: T-->Grammar<--Scanner;.)
  =
        (.
          Sc := Scanner as T-->Grammar<--Scanner;
          Res := Sc.CurrInputCh;
          Sc.NextCh;
          exit;
        .)
        ANY     //Actually any one source character ... requires thought,
                //a bit of faffing with the lexer will be needed.
  .

  RegularExpressionClassChars<var Res: string> DESCRIPTION "Regular expression class characters"
        (. var Sc: T-->Grammar<--Scanner; TokenStr: string; .)
  =
        (.
          Res := '';
          Sc := Scanner as T-->Grammar<--Scanner;
          while (Sc.CurrInputCh <> ']')
            and (Sc.CurrInputCh <> _EF) do
          begin
            Res := Res + Sc.CurrInputCh;
            if Sc.CurrInputCh = '\' then
            begin
              Sc.NextCh;
              TokenStr := '';
              _RegularExpressionEscapeSequence(TokenStr);
              Res := Res + TokenStr;
            end
            else
              Sc.NextCh;
          end;
          exit;
        .)
    RegularExpressionEscapeSequence<TokenStr>
  .

  RegularExpressionBody<var Res:string> DESCRIPTION "Regular expression body"
        (. var Sc: T-->Grammar<--Scanner; ClassStr: string; .)
  =
        (.
          Res := '';
          Sc := Scanner as T-->Grammar<--Scanner;
          while (Sc.CurrInputCh <> '/')
            and (Sc.CurrInputCh <> _EF) do
          begin
            Res := Res + Sc.CurrInputCh;
            if Sc.CurrInputCh = '[' then
            begin
              Sc.NextCh;
              ClassStr := '';
              _RegularExpressionClassChars(ClassStr);
              Res := Res + ClassStr;
              Assert(Sc.CurrInputCh = ']');
            end
            else if Sc.CurrInputCh = '\' then
            begin
              Sc.NextCh;
              ClassStr := '';
              _RegularExpressionEscapeSequence(ClassStr);
              Res := Res + ClassStr;
            end
            else
              Sc.NextCh;
          end;
          //First thing get does is advance to next char,
          //and we need the token stored in the lexer.
          Get;
          exit;
        .)
    //Statements below to appease CoCo
    "\"
    RegularExpressionClassChars<ClassStr>
    RegularExpressionEscapeSequence<ClassStr>
  .

  RegularExpressionFlags<out S:string> DESCRIPTION "Regular expression flags"
  =
    _Identifier                         (. S := LexString; .)
  .

  RegularExpression<out ST:TJSString> DESCRIPTION "Regular expression literal"
                                        (. var
                                                Regexp,
                                                RegexpPrefix,
                                                RegexpSuffix,
                                                S: string;
                                                StartPos, CurPos, Rewind:integer; .)
  =
                                        (. StartPos := (Scanner as TJScriptGrammarScanner).BufferPosition;
                                        .)
    (
      "/"                               (. RegexpPrefix := ''; .)
      |
      "/="                              (. RegexpPrefix := '='; .)
    )
                                        (. CurPos := (Scanner as TJScriptGrammarScanner).BufferPosition;
                                           Rewind := CurPos - StartPos;
                                           RewindLexer(Rewind); .)
    RegularExpressionBody<Regexp>
    "/"                                 (. RegexpSuffix := '/'; .)
    [
      RegularExpressionFlags<S>         (. RegexpSuffix := RegexpSuffix + S; .)
    ]
                                        (. S := RegexpPrefix + Regexp + RegexpSuffix;
                                           ST := TJSString.CreateWithTracker(FParseTracker as TTracker);
                                           ST.ExprType := etSimpleExpression;
                                           ST.SimpleExprType := setRegExp;
                                           ST.StrData := S;
                                        .)
  .

  StringLiteral<out S: TJSString> DESCRIPTION "String literal"
                                        (. var SVal:string; .)
  =
    (
      SQuotString                       (. SVal := LexString; //TODO - check this.
                                           SVal := SVal.SubString(1, Length(SVal) - 2);
                                        .)
      |
      DQuotString                       (. SVal := LexString; //TODO - check this.
                                           SVal := SVal.SubString(1, Length(SVal) - 2);
                                        .)
    )
                                        (. S := TJSString.CreateWithTracker(FParseTracker as TTracker);
                                           S.ExprType := etSimpleExpression;
                                           S.SimpleExprType := setStringLiteral;
                                           S.StrData := SVal;
                                        .)
  .

  PrimaryExpression_Normal<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Primary expression"
                                        (. var O: TJSSimpleExpr; .)
  =
                                        (. E := nil; .)
    (
      SimpleExpression<E, IsLVAL>
      |
      FunctionExpression<E>
                                        (. IsLVAL := false; .)
      |
      ObjectLiteral<O>                  (. IsLVAL := false;
                                           E := O; .)
    )

  .

  PrimaryExpression_Initial<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Primary expression"
  =
    SimpleExpression<E, IsLVAL>
  .

  SimpleExpression<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Simple expression"
                                        (. var I: TJSIdentifier;
                                               S: TJSString;
                                               N: TJSNumber;
                                               A: TJSSimpleExpr;
                                        .)
  =
                                        (. E := nil; .)
    (
      ParenthesizedExpression<E, IsLVAL>
      |
                                        (. E := TJSSimpleExpr.CreateWithTracker(FParseTracker as TTracker); .)
      (
        "this"                          (. (E as TJSSimpleExpr).SimpleExprType := setThis; .)
        |
        "null"
                                        (. IsLVAL := false;
                                           (E as TJSSimpleExpr).SimpleExprType := setNull; .)
        |
        "false"
                                        (. IsLVAL := false;
                                           (E as TJSSimpleExpr).SimpleExprType := setFalse; .)
        |
        "true"
                                        (. IsLVAL := false;
                                           (E as TJSSimpleExpr).SimpleExprType := setTrue; .)
      )
      |
      Identifier<I>                     (. E := I; .)
      |
      Number<N>                         (. IsLVAL := false;
                                           E := N;
                                        .)
      |
      StringLiteral<S>                  (. IsLVAL := false;
                                           E := S; .)
      |
      RegularExpression<S>              (. IsLVAL := false;
                                           E := S; .)
      |
      ArrayLiteral<A>                   (. IsLVAL := false;
                                           E := A; .)
    )
  .

  ParenthesizedExpression<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Parenthesized expression"
                                        (. var SubLVal: boolean; .)
  =
    "("
                                        (. SubLVal := true; .)
    Expression_Normal_AllowIn<E, SubLVal>
                                        (. if not SubLVal then
                                             IsLVAL := false;  .)
    ")"

  .

  FunctionExpression<out E: TJSExpr> DESCRIPTION "Function expression"
                                        (. var F: TJSFunction; .)
  =
                                        (. E := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E.ExprType := etFunctionExpression; .)
    "function"
    (
      AnonymousFunctionDecl<F>
      |
      NamedFunctionDecl<F>
    )
                                        (. InsertStmtTail(E, F); .)

  .

  LiteralField<out F: TJSExpr> DESCRIPTION "Literal field"
                                        (. var LValStart: boolean;
                                               I: TJSIdentifier;
                                               S: TJSString;
                                               N: TJSNumber;
                                               E: TJSExpr; .)
  =
                                        (. LValStart := true;
                                           F := TJSExpr.CreateWithTracker(FParseTracker as TTRacker);
                                           F.ExprType := etObjectFieldDecl;
                                        .)
    (
        Identifier<I>                  (. InsertExprTail(F,I); .)
        |
        StringLiteral<S>               (. InsertExprTail(F,S); .)
        |
        Number<N>                      (. InsertExprTail(F,N); .)
        |

                                        (. //Bit hacky, duplicate identifier code for comp workaround.
                                           I := TJSIdentifier.CreateWithTracker(FParseTracker as TTracker);
                                           I.ExprType := etSimpleExpression;
                                           I.SimpleExprType:= setIdentifier;
                                           InsertExprTail(F,I);
                                        .)
        (
          "return"                        (. ParseWarning(1016, ''); I.Name := LexString; .)
          |
          "default"                       (. ParseWarning(1017, '');  I.Name := LexString; .)
          |
          "catch"                         (. ParseWarning(1018, '');  I.Name := LexString; .)
          |
          "delete"                        (. ParseWarning(1019, '');  I.Name := LexString; .)
          |
          "then"                          (. ParseWarning(1020, '');  I.Name := LexString; .)
          |
          "for"                           (. ParseWarning(1021, '');  I.Name := LexString; .)
        )
    )
    ":"
    AssignmentExpression_Normal_AllowIn<E, LValStart>
                                        (. InsertExprTail(F,E); .)

  .

  FieldList<out L:TJSExprList> DESCRIPTION "Field list"
                                        (. var F: TJSExpr; .)
  =
                                        (. L := TJSExprList.CreateWithTracker(FParseTracker as TTracker);
                                           L.ListType := eltObjectFields;
                                        .)
    [
      LiteralField<F>                   (. InsertExprTail(L,F); .)
      { ","
        [
          LiteralField<F>               (. InsertExprTail(L,F); .)
        ]
      }
    ]
  .

  ObjectLiteral<out E:TJSSImpleExpr> DESCRIPTION "Object literal"
                                        (. var L: TJSExprList; .)
  =
                                        (. E := TJSSimpleExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E.ExprType := etSimpleExpression;
                                           E.SimpleExprType := setObjLit; .)
    "{"
    FieldList<L>                        (. InsertExprListTail(E, L); .)
    "}"

  .

  LiteralElement<out E: TJSExpr> DESCRIPTION "Literal Element"
                                        (. var LValStart: boolean; .)
  =
                                        (. LValStart := true; .)
    AssignmentExpression_Normal_AllowIn<E, LValStart>

  .

  ElementList<out L:TJSExprList> DESCRIPTION "Element list"
                                        (. var E: TJSExpr; SeenComma: boolean; .)
  =
                                        (.
                                           L := TJSExprList.CreateWithTracker(FParseTracker as TTRacker);
                                           L.ListType := eltArrayElems;
                                           E := nil;
                                           SeenComma := false;
                                        .)
    [
      LiteralElement<E>                 (. InsertExprTail(L,E); .)
    ]
    {
      ","                               (. SeenComma := true;
                                           if not Assigned(E) then
                                           begin
                                             E:= TJSSimpleExpr.CreateWithTracker(FParseTracker as TTRacker);
                                             E.ExprType := etSimpleExpression;
                                             (E as TJSSimpleExpr).SimpleExprType := setNull;
                                             InsertExprTail(L,E);
                                           end;
                                           E:= nil;
                                        .)
      [
        LiteralElement<E>               (. InsertExprTail(L,E); .)
      ]
    }
                                        (. if SeenComma and not Assigned(E) then
                                           begin
                                             E:= TJSSimpleExpr.CreateWithTracker(FParseTracker as TTRacker);
                                             E.ExprType := etSimpleExpression;
                                             (E as TJSSimpleExpr).SimpleExprType := setNull;
                                             InsertExprTail(L,E);
                                           end;
                                        .)
  .

  ArrayLiteral<out E:TJSSimpleExpr> DESCRIPTION "Array literal"
                                        (. var L: TJSExprList; .)
  =
                                        (. E := TJSSimpleExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E.ExprType := etSimpleExpression;
                                           E.SimpleExprType := setArrayLit; .)
    "["
    ElementList<L>                      (. InsertExprListTail(E, L); .)
    "]"

  .

  ArgumentList<var L: TJSExprList> DESCRIPTION "Argument list"
                                        (. var LValStart: boolean; E:TJSExpr; .)
  =
                                        (. LValStart := true; .)
    AssignmentExpression_Normal_AllowIn<E, LValStart>
                                        (. InsertExprTail(L,E); .)
    {
      ","
      (. LValStart := true; .)
      AssignmentExpression_Normal_AllowIn<E, LValStart>
                                        (. InsertExprTail(L,E); .)
    }
  .

  Arguments<out L: TJSExprList> DESCRIPTION "Arguments"
  =
                                        (.
                                           L := TJSExprList.CreateWithTracker(FParseTracker as TTracker);
                                           L.ListType := eltArguments;
                                        .)
    "("
    [
      ArgumentList<L>
    ]
    ")"
  .

  MemberOperator<out E:TJSExpr> DESCRIPTION "Member operator"
                                        (. var LVALStart: boolean; E2: TJSExpr; I: TJSIdentifier; .)
  =
                                        (. LValStart := true;
                                           E := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E.ExprType := etArrayAccessOperator;
                                           //Add RHS child here only.
                                        .)
    "["
    Expression_Normal_AllowIn<E2,LVALStart>
                                        (. InsertExprTail(E,E2); .)
    "]"
    |
                                        (. LValStart := true;
                                           E := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E.ExprType := etNamedMemberOperator;
                                           //Add RHS child here only.
                                        .)
    "."
    (
      Identifier<I>                    (. InsertExprTail(E,I); .)
      |

                                        (. //Bit hacky, duplicate identifier code for comp workaround.
                                           I := TJSIdentifier.CreateWithTracker(FParseTracker as TTracker);
                                           I.ExprType := etSimpleExpression;
                                           I.SimpleExprType:= setIdentifier;
                                           InsertExprTail(E,I);
                                        .)
      (
        "return"                        (. ParseWarning(1010, ''); I.Name := LexString; .)
        |
        "default"                       (. ParseWarning(1008, '');  I.Name := LexString; .)
        |
        "catch"                         (. ParseWarning(1009, '');  I.Name := LexString; .)
        |
        "delete"                         (. ParseWarning(1013, '');  I.Name := LexString; .)
        |
        "then"                         (. ParseWarning(1014, '');  I.Name := LexString; .)
        |
        "for"                         (. ParseWarning(1015, '');  I.Name := LexString; .)
      )
    )

  .

  FullNewSubexpression<out E: TJSExpr> DESCRIPTION "Full new subexpression"
                                        (. var LVALStart: boolean; E2: TJSExpr; .)
  =
                                        (. LValStart := true;
                                           E := nil; .)
    (
      PrimaryExpression_Normal<E, LVALStart>
      |
      FullNewExpression<E>
    )

    {
      MemberOperator<E2>
                                        (. //Member operator already constructed, in E2.
                                           //add existing expr to LHS of . or [ operator
                                           InsertExprHead(E2,E);
                                           E := E2;
                                        .)
    }

  .

  FullNewExpression<out E: TJSExpr> DESCRIPTION "Full new expression"
                                        (. var E2, E3: TJSExpr; L: TJSExprList; .)
  =
    "new"
    FullNewSubexpression<E2>
                                        (. E := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E.ExprType := etNewOperator;
                                           InsertExprTail(E,E2); .)
    [
      Arguments<L>
                                        (. E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E3.ExprType := etCallOperator;
                                           InsertExprTail(E3,E);
                                           InsertExprListTail(E3,L, false);
                                           E := E3;
                                        .)
    ]

  .

  CallExpression_Normal<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Call expression"
                                        (. var E2, E3: TJSExpr; L: TJSExprList; .)
  =
                                        (. E := nil; .)
    (
      PrimaryExpression_Normal<E, IsLVAL>
      |
      FullNewExpression<E>
    )

    {
      (
        MemberOperator<E2>
                                        (. //Member operator already constructed, in E2.
                                           //add existing expr to LHS of . or [ operator
                                           InsertExprHead(E2, E);
                                           E := E2;
                                        .)
        |
        Arguments<L>
                                        (. E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E3.ExprType := etCallOperator;
                                           InsertExprTail(E3,E);
                                           InsertExprListTail(E3,L, false);
                                           E := E3;
                                        .)
      )
      (. IsLVAL := true; .)
    }

  .

  CallExpression_Initial<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Call expression"
                                        (. var E2, E3: TJSExpr; L: TJSExprList; .)
  =
                                        (. E := nil; .)
    (
      PrimaryExpression_Initial<E, IsLVAL>
      |
      FullNewExpression<E>
    )

    {
      (
        MemberOperator<E2>
                                        (. //Member operator already constructed, in E2.
                                           //add existing expr to LHS of . or [ operator
                                           InsertExprHead(E2, E);
                                           E := E2;
                                        .)
        |
        Arguments<L>
                                        (. E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E3.ExprType := etCallOperator;
                                           InsertExprTail(E3,E);
                                           InsertExprListTail(E3,L, false);
                                           E := E3;
                                        .)
      )
      (. IsLVAL := true; .)
    }

  .

  LeftSideExpression_Normal<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Left side expression"
  =
                                          (. E := nil; .)
    (
      CallExpression_Normal<E, IsLVAL>
      |
      FullNewExpression<E>
    )
  .

  LeftSideExpression_Initial<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Left side expression"
  =
                                        (. E := nil; .)
    (
      CallExpression_Initial<E, IsLVAL>
      |
      FullNewExpression<E>
    )
  .

  PostfixExpression_Normal<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Postfix expression"
                                        (. var E1: TJSExpr; UnaryType: TJSUnaryType; .)
  =
    LeftSideExpression_Normal<E, IsLVAL>
    [
      (
        "++"                            (. UnaryType := utPostInc; .)
        |
        "--"                            (. UnaryType := utPostDec; .)
      )
                                        (. IsLVAL := false;
                                           E1 := TJSUnaryOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E1.ExprType := etUnaryOperator;
                                           (E1 as TJSUnaryOperator).UnaryType := UnaryType;
                                           InsertExprTail(E1,E);
                                           E := E1;
                                        .)
    ]

  .

  PostfixExpression_Initial<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Postfix expression"
                                        (. var E1: TJSExpr; UnaryType: TJSUnaryType; .)
  =
    LeftSideExpression_Initial<E, IsLVAL>
    [
      (
        "++"                            (. UnaryType := utPostInc; .)
        |
        "--"                            (. UnaryType := utPostDec; .)
      )
                                        (. IsLVAL := false;
                                           E1 := TJSUnaryOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E1.ExprType := etUnaryOperator;
                                           (E1 as TJSUnaryOperator).UnaryType := UnaryType;
                                           InsertExprTail(E1,E);
                                           E := E1;
                                        .)
    ]

  .

  UnaryExpression_Normal<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Unary expression"
                                        (. var E1: TJSExpr; UnaryType: TJSUnaryType; .)
  =
                                        (. E := nil; .)
    (
      PostfixExpression_Normal<E, IsLVAL>

      |
                                        (. UnaryType := utInvalid; .)
      (
        "delete"
        LeftSideExpression_Normal<E, IsLVAL>
                                        (. IsLVAL := false;
                                           UnaryType := utDelete; .)
        |
        "void"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. IsLVAL := false;
                                           UnaryType := utVoid; .)
        |
        "typeof"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. IsLVAL := false;
                                           UnaryType := utTypeof; .)
        |
        "++"
        LeftSideExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utPreInc; .)
        |
        "--"
        LeftSideExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utPreDec; .)
        |
        "+"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utPlus; .)
        |
        "-"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utMinus; .)
        |
        "~"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utBitNot; .)
        |
        "!"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utLogNot; .)
      )
                                        (. E1 := TJSUnaryOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E1.ExprType := etUnaryOperator;
                                           (E1 as TJSUnaryOperator).UnaryType := UnaryType;
                                           InsertExprTail(E1,E);
                                           E := E1;
                                        .)

    )

  .

  UnaryExpression_Initial<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Unary expression"
                                        (. var E1: TJSExpr; UnaryType: TJSUnaryType; .)
  =
                                        (. E := nil; .)
    (
      PostfixExpression_Initial<E, IsLVAL>

      |
                                        (. UnaryType := utInvalid; .)
      (
        "delete"
        LeftSideExpression_Normal<E, IsLVAL>
                                        (. IsLVAL := false;
                                           UnaryType := utDelete; .)
        |
        "void"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. IsLVAL := false;
                                           UnaryType := utVoid; .)
        |
        "typeof"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. IsLVAL := false;
                                           UnaryType := utTypeof; .)
        |
        "++"
        LeftSideExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utPreInc; .)
        |
        "--"
        LeftSideExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utPreDec; .)
        |
        "+"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utPlus; .)
        |
        "-"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utMinus; .)
        |
        "~"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utBitNot; .)
        |
        "!"
        UnaryExpression_Normal<E, IsLVAL>
                                        (. UnaryType := utLogNot; .)
      )
                                        (. E1 := TJSUnaryOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E1.ExprType := etUnaryOperator;
                                           (E1 as TJSUnaryOperator).UnaryType := UnaryType;
                                           InsertExprTail(E1,E);
                                           E := E1;
                                        .)

    )

  .

  MultiplicativeExpression_Normal<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Multiplicative expression"
                                        (. var E1, E2: TJSExpr; ArithType: TJSArithType;.)
  =
    UnaryExpression_Normal<E, IsLVAL>
    {
      (
        "*"                             (. ArithType := atMul; .)
        |
        "/"                             (. ArithType := atDiv; .)
        |
        "%"                             (. ArithType := atMod; .)
      )
      UnaryExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSArithOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etArithOperator;
                                           (E2 as TJSArithOperator).ArithType := ArithType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }

  .

  MultiplicativeExpression_Initial<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Multiplicative expression"
                                        (. var E1, E2: TJSExpr; ArithType: TJSArithType;.)
  =
    UnaryExpression_Initial<E, IsLVAL>
    {
      (
        "*"                             (. ArithType := atMul; .)
        |
        "/"                             (. ArithType := atDiv; .)
        |
        "%"                             (. ArithType := atMod; .)
      )
      UnaryExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSArithOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etArithOperator;
                                           (E2 as TJSArithOperator).ArithType := ArithType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }

  .

  AdditiveExpression_Normal<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Additive expression"
                                        (. var E1, E2: TJSExpr; ArithType: TJSArithType;.)
  =
    MultiplicativeExpression_Normal<E, IsLVAL>
    {
      (
        "+"                             (. ArithType := atAdd; .)
        |
        "-"                             (. ArithType := atSub; .)
      )
      MultiplicativeExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSArithOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etArithOperator;
                                           (E2 as TJSArithOperator).ArithType := ArithType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }

  .

  AdditiveExpression_Initial<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Additive expression"
                                        (. var E1, E2: TJSExpr; ArithType: TJSArithType;.)
  =
    MultiplicativeExpression_Initial<E, IsLVAL>
    {
      (
        "+"                               (. ArithType := atAdd; .)
        |
        "-"                               (. ArithType := atSub; .)
      )
      MultiplicativeExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSArithOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etArithOperator;
                                           (E2 as TJSArithOperator).ArithType := ArithType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  ShiftExpression_Normal<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Shift expression"
                                        (. var E1, E2: TJSExpr; ShiftType: TJSShiftType;.)
  =
    AdditiveExpression_Normal<E, IsLVAL>
    {
      (
        "<<"                            (. ShiftType := stLeft; .)
        |
        ">>"                            (. ShiftType := stRight; .)
        |
        ">>>"                           (. ShiftType := stUnsRight; .)
      )
      AdditiveExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSShiftOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etShiftOperator;
                                           (E2 as TJSShiftOperator).ShiftType := ShiftType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  ShiftExpression_Initial<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Shift expression"
                                        (. var E1, E2: TJSExpr; ShiftType: TJSShiftType;.)
  =
    AdditiveExpression_Initial<E, IsLVAL>
    {
      (
        "<<"                            (. ShiftType := stLeft; .)
        |
        ">>"                            (. ShiftType := stRight; .)
        |
        ">>>"                           (. ShiftType := stUnsRight; .)
      )
      AdditiveExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSShiftOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etShiftOperator;
                                           (E2 as TJSShiftOperator).ShiftType := ShiftType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  RelationalExpression_Normal_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Relational expression"
                                        (. var E1, E2: TJSExpr; TestType: TJSRelationalTestType;.)
  =
    ShiftExpression_Normal<E, IsLVAL>
    {
                                        (. TestType := rtInvalid; .)
      (
        "<"                             (. TestType := rtLessThan; .)
        |
        ">"                             (. TestType := rtGreaterThan; .)
        |
        "<="                            (. TestType := rtLessThanOrEqual; .)
        |
        ">="                            (. TestType := rtGreaterThanOrEqual; .)
        |
        "instanceof"                    (. TestType := rtInstanceOf; .)
        |
        "in"                            (. TestType := rtIn; .)
      )
      ShiftExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSRelationalTest.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etRelationalOperator;
                                           (E2 as TJSRelationalTest).RelationalTestType := TestType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  RelationalExpression_Initial_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Relational expression"
                                        (. var E1, E2: TJSExpr; TestType: TJSRelationalTestType;.)
  =
    ShiftExpression_Initial<E, IsLVAL>
    {
                                        (. TestType := rtInvalid; .)
      (
        "<"                             (. TestType := rtLessThan; .)
        |
        ">"                             (. TestType := rtGreaterThan; .)
        |
        "<="                            (. TestType := rtLessThanOrEqual; .)
        |
        ">="                            (. TestType := rtGreaterThanOrEqual; .)
        |
        "instanceof"                    (. TestType := rtInstanceOf; .)
        |
        "in"                            (. TestType := rtIn; .)
      )
      ShiftExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSRelationalTest.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etRelationalOperator;
                                           (E2 as TJSRelationalTest).RelationalTestType := TestType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  RelationalExpression_Normal_NoIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Relational expression"
                                        (. var E1, E2: TJSExpr; TestType: TJSRelationalTestType;.)
  =
    ShiftExpression_Normal<E, IsLVAL>
    {
                                        (. TestType := rtInvalid; .)
      (
        "<"                             (. TestType := rtLessThan; .)
        |
        ">"                             (. TestType := rtGreaterThan; .)
        |
        "<="                            (. TestType := rtLessThanOrEqual; .)
        |
        ">="                            (. TestType := rtGreaterThanOrEqual; .)
        |
        "instanceof"                    (. TestType := rtInstanceOf; .)
      )
      ShiftExpression_Normal<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSRelationalTest.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etRelationalOperator;
                                           (E2 as TJSRelationalTest).RelationalTestType := TestType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  EqualityExpression_Normal_NoIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Equality expression"
                                        (. var E1, E2: TJSExpr; TestType: TJSEqualityTestType;.)
  =
    RelationalExpression_Normal_NoIn<E, IsLVAL>
    {
      (
        "=="                            (. TestType := etEqual; .)
        |
        "!="                            (. TestType := etNotEqual; .)
        |
        "==="                           (. TestType := etStrictlyEqual; .)
        |
        "!=="                           (. TestType := etNotStrictlyEqual; .)
      )
      RelationalExpression_Normal_NoIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSEqualityTest.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etEqualityTestOperator;
                                           (E2 as TJSEqualityTest).EqualityTestType := TestType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  EqualityExpression_Normal_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Equality expression"
                                        (. var E1, E2: TJSExpr; TestType: TJSEqualityTestType;.)
  =
    RelationalExpression_Normal_AllowIn<E, IsLVAL>
    {
      (
        "=="                            (. TestType := etEqual; .)
        |
        "!="                            (. TestType := etNotEqual; .)
        |
        "==="                           (. TestType := etStrictlyEqual; .)
        |
        "!=="                           (. TestType := etNotStrictlyEqual; .)
      )
      RelationalExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSEqualityTest.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etEqualityTestOperator;
                                           (E2 as TJSEqualityTest).EqualityTestType  := TestType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  EqualityExpression_Initial_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Equality expression"
                                        (. var E1, E2: TJSExpr; TestType: TJSEqualityTestType;.)
  =
    RelationalExpression_Initial_AllowIn<E, IsLVAL>
    {
      (
        "=="                            (. TestType := etEqual; .)
        |
        "!="                            (. TestType := etNotEqual; .)
        |
        "==="                           (. TestType := etStrictlyEqual; .)
        |
        "!=="                           (. TestType := etNotStrictlyEqual; .)
      )
      RelationalExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSEqualityTest.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etEqualityTestOperator;
                                           (E2 as TJSEqualityTest).EqualityTestType  := TestType;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  BitwiseOrExpression_Normal_NoIn<out E:TJSExpr; IsLVAL: boolean> DESCRIPTION "Bitwise or expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseXorExpression_Normal_NoIn<E, IsLVAL>
    {
      "|" BitwiseXorExpression_Normal_NoIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btOr;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
     }
  .

  BitwiseOrExpression_Normal_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Bitwise or expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseXorExpression_Normal_AllowIn<E, IsLVAL>
    {
      "|" BitwiseXorExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btOr;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  BitwiseOrExpression_Initial_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Bitwise or expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseXorExpression_Initial_AllowIn<E, IsLVAL>
    {
      "|" BitwiseXorExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btOr;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  BitwiseXorExpression_Normal_NoIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Bitwise xor expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseAndExpression_Normal_NoIn<E, IsLVAL>
    {
      "^" BitwiseAndExpression_Normal_NoIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btXor;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  BitwiseXorExpression_Normal_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Bitwise xor expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseAndExpression_Normal_AllowIn<E, IsLVAL>
    {
      "^" BitwiseAndExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btXor;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  BitwiseXorExpression_Initial_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Bitwise xor expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseAndExpression_Initial_AllowIn<E, IsLVAL>
    {
      "^" BitwiseAndExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btXor;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  BitwiseAndExpression_Normal_NoIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Bitwise and expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    EqualityExpression_Normal_NoIn<E, IsLVAL>
    {
      "&" EqualityExpression_Normal_NoIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btAnd;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  BitwiseAndExpression_Normal_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Bitwise and expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    EqualityExpression_Normal_AllowIn<E, IsLVAL>
    {
      "&" EqualityExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btAnd;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  BitwiseAndExpression_Initial_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Bitwise and expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    EqualityExpression_Initial_AllowIn<E, IsLVAL>
    {
      "&" EqualityExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSBitwiseOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etBitwiseOperator;
                                           (E2 as TJSBitwiseOperator).BitwiseType := btAnd;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  LogicalOrExpression_Normal_NoIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Logical or expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    LogicalAndExpression_Normal_NoIn<E, IsLVAL>
    {
      "||" LogicalAndExpression_Normal_NoIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSLogicalOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etLogicalOperator;
                                           (E2 as TJSLogicalOperator).LogicalType := otOr;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  LogicalOrExpression_Normal_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Logical or expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    LogicalAndExpression_Normal_AllowIn<E, IsLVAL>
    {
      "||" LogicalAndExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSLogicalOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etLogicalOperator;
                                           (E2 as TJSLogicalOperator).LogicalType := otOr;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  LogicalOrExpression_Initial_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Logical or expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    LogicalAndExpression_Initial_AllowIn<E, IsLVAL>
    {
      "||" LogicalAndExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSLogicalOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etLogicalOperator;
                                           (E2 as TJSLogicalOperator).LogicalType := otOr;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  LogicalAndExpression_Normal_NoIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Logical and expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseOrExpression_Normal_NoIn<E, IsLVAL>
    {
      "&&" BitwiseOrExpression_Normal_NoIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSLogicalOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etLogicalOperator;
                                           (E2 as TJSLogicalOperator).LogicalType := otAnd;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  LogicalAndExpression_Normal_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Logical and expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseOrExpression_Normal_AllowIn<E, IsLVAL>
    {
      "&&" BitwiseOrExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSLogicalOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etLogicalOperator;
                                           (E2 as TJSLogicalOperator).LogicalType := otAnd;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  LogicalAndExpression_Initial_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Logical and expression"
                                        (. var E1, E2: TJSExpr; .)
  =
    BitwiseOrExpression_Initial_AllowIn<E, IsLVAL>
    {
      "&&" BitwiseOrExpression_Normal_AllowIn<E1, IsLVAL>
                                        (. IsLVAL := false;
                                           E2 := TJSLogicalOperator.CreateWithTracker(FParseTracker as TTracker);
                                           E2.ExprType := etLogicalOperator;
                                           (E2 as TJSLogicalOperator).LogicalType := otAnd;
                                           InsertExprTail(E2,E);
                                           InsertExprTail(E2,E1);
                                           E := E2;
                                        .)
    }
  .

  ConditionalExpression_Normal_NoIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Conditional expression"
                                        (. var LVAL1, LVAL2: boolean; E1, E2, E3: TJSExpr; .)
  =
    LogicalOrExpression_Normal_NoIn<E, IsLVAL>
    [
      "?"
                                        (. LVAL1 := true; .)
      AssignmentExpression_Normal_NoIn<E1, LVAL1>
      ":"
                                        (. LVAL2 := true; .)
      AssignmentExpression_Normal_NoIn<E2,LVAL2>
                                        (. IsLVAL := LVAL1 and LVAL2;
                                           E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E3.ExprType := etConditionalOperator;
                                           InsertExprTail(E3,E);
                                           InsertExprTail(E3,E1);
                                           InsertExprTail(E3,E2);
                                           E := E3;
                                        .)
    ]
  .

  ConditionalExpression_Normal_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Conditional expression"
                                        (. var LVAL1, LVAL2: boolean; E1, E2, E3: TJSExpr; .)
  =
    LogicalOrExpression_Normal_AllowIn<E, IsLVAL>
    [
      "?"
                                        (. LVAL1 := true; .)
      AssignmentExpression_Normal_AllowIn<E1, LVAL1>
      ":"
                                        (. LVAL2 := true; .)
      AssignmentExpression_Normal_AllowIn<E2, LVAL2>
                                        (. IsLVAL := LVAL1 and LVAL2;
                                           E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E3.ExprType := etConditionalOperator;
                                           InsertExprTail(E3,E);
                                           InsertExprTail(E3,E1);
                                           InsertExprTail(E3,E2);
                                           E := E3;
                                        .)
    ]
  .

  ConditionalExpression_Initial_AllowIn<out E:TJSExpr; var IsLVAL: boolean> DESCRIPTION "Conditional expression"
                                        (. var LVAL1, LVAL2: boolean; E1, E2, E3: TJSExpr; .)
  =
    LogicalOrExpression_Initial_AllowIn<E, IsLVAL>
    [
      "?"
                                        (. LVAL1 := true; .)
      AssignmentExpression_Normal_AllowIn<E1, LVAL1>
      ":"
                                        (. LVAL2 := true; .)
      AssignmentExpression_Normal_AllowIn<E2, LVAL2>
                                        (. IsLVAL := LVAL1 and LVAL2;
                                           E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E3.ExprType := etConditionalOperator;
                                           InsertExprTail(E3,E);
                                           InsertExprTail(E3,E1);
                                           InsertExprTail(E3,E2);
                                           E := E3;
                                        .)
    ]
  .

  CompoundAssignment<out E:TJSMultiAssign> DESCRIPTION "Compound assignment"
  =
                                        (. E := TJSMultiAssign.CreateWithTracker(FParseTracker as TTracker); .)
    (
      "*="                              (. E.AssignmentType := atMulAssign; .)
      |
      "/="                              (. E.AssignmentType := atDivAssign; .)
      |
      "%="                              (. E.AssignmentType := atModAssign; .)
      |
      "+="                              (. E.AssignmentType := atAddAssign; .)
      |
      "-="                              (. E.AssignmentType := atSubAssign; .)
      |
      "<<="                             (. E.AssignmentType := atShlAssign; .)
      |
      ">>="                             (. E.AssignmentType := atShrAssign; .)
      |
      ">>>="                            (. E.AssignmentType := atUnsShrAssign; .)
      |
      "&="                              (. E.AssignmentType := atBitAndAssign; .)
      |
      "^="                              (. E.AssignmentType := atBitXorAssign; .)
      |
      "|="                              (. E.AssignmentType := atBitOrAssign; .)
    )
  .

  AssignmentExpression_Normal_NoIn<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Assignment expression"
                                                (. var E1, E2: TJSExpr;
                                                       MS: TJSMultiAssign; .)
  =
    ConditionalExpression_Normal_NoIn<E, IsLVAL>
    [
      (
        CompoundAssignment<MS>          (. E1 := MS; .)
        |
        "="
                                        (. E1 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E1.ExprType := etAssignOperator; .)

      )
        (. if not IsLVAL then SynError(1000); .)
      AssignmentExpression_Normal_NoIn<E2, IsLVAL>
                                        (. InsertExprTail(E1,E);
                                           InsertExprTail(E1,E2);
                                           E := E1;
                                        .)
    ]
  .

  AssignmentExpression_Normal_AllowIn<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Assignment expression"
                                                (. var E1, E2: TJSExpr;
                                                       MS: TJSMultiAssign; .)
  =
    ConditionalExpression_Normal_AllowIn<E, IsLVAL>
    [
      (
        CompoundAssignment<MS>          (. E1 := MS; .)
        |
        "="
                                        (. E1 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E1.ExprType := etAssignOperator; .)
      )
        (. if not IsLVAL then SynError(1000); .)
      AssignmentExpression_Normal_AllowIn<E2, IsLVAL>
                                        (. InsertExprTail(E1,E);
                                           InsertExprTail(E1,E2);
                                           E := E1;
                                        .)
    ]
  .

  AssignmentExpression_Initial_AllowIn<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Assignment expression"
                                                (. var E1, E2: TJSExpr;
                                                       MS: TJSMultiAssign; .)
  =
    ConditionalExpression_Initial_AllowIn<E, IsLVAL>
    [
      (
        CompoundAssignment<MS>          (. E1 := MS; .)
        |
        "="
                                        (. E1 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E1.ExprType := etAssignOperator; .)
      )
        (. if not IsLVAL then SynError(1000); .)
      AssignmentExpression_Normal_AllowIn<E2,IsLVAL>
                                        (. InsertExprTail(E1,E);
                                           InsertExprTail(E1,E2);
                                           E := E1;
                                        .)
    ]
  .

  OptionalExpression<out E: TJSExpr> DESCRIPTION "Optional expression"
                                        (. var LVALStart: boolean; .)
  =
                                        (. LValStart := true;
                                           E := nil;
                                         .)
    [
      Expression_Normal_AllowIn<E, LVALStart>
    ]
  .

  Expression_Normal_NoIn<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Expression"
                                        (. var SubLVal: boolean; E2, E3: TJSExpr; .)
  =
    AssignmentExpression_Normal_NoIn<E, IsLVAL>
    { ","
                                        (. SubLVal := true; .)
      AssignmentExpression_Normal_NoIn<E2, SubLVal>
                                        (.
                                            IsLVAL := false;
                                            E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                            E3.ExprType := etCommaOperator;
                                            InsertExprTail(E3,E);
                                            InsertExprTail(E3,E2);
                                            E := E3;
                                        .)
    }
  .

  Expression_Normal_AllowIn<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Expression"
                                        (. var SubLVal: boolean; E2, E3: TJSExpr; .)
  =
    AssignmentExpression_Normal_AllowIn<E, IsLVAL>
    { ","
                                        (. SubLVal := true; .)
      AssignmentExpression_Normal_AllowIn<E2, SubLVal>
                                        (.
                                           IsLVAL := false;
                                           E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E3.ExprType := etCommaOperator;
                                           InsertExprTail(E3,E);
                                           InsertExprTail(E3,E2);
                                           E := E3;
                                        .)
    }
  .

  Expression_Initial_AllowIn<out E: TJSExpr; var IsLVAL: boolean> DESCRIPTION "Expression"
                                        (. var SubLVal: boolean; E2, E3: TJSExpr; .)
  =
    AssignmentExpression_Initial_AllowIn<E, IsLVAL>
    { ","
                                        (. SubLVal := true; .)
      AssignmentExpression_Normal_AllowIn<E2, SubLVal>
                                        (.
                                           IsLVAL := false;
                                           E3 := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E3.ExprType := etCommaOperator;
                                           InsertExprTail(E3,E);
                                           InsertExprTail(E3,E2);
                                           E := E3;
                                        .)
    }
  .

  FinallyClause<out B: TJSBlock> DESCRIPTION "Finally clause"
  =
    "finally"
    Block<B>                            (. B.BlockType := btFinally .)
  .

  CatchClause<out CC: TJSTagGroup> DESCRIPTION "Catch clause"
                                        (. var E: TJSIdentifier; B:TJSBlock; .)
  =
                                        (. CC := TJSTagGroup.CreateWithTracker(FParseTracker as TTracker);
                                           CC.TagGroupType := ttgCatchBlock; .)
    "catch" "("
    Identifier<E>                       (. InsertExprTail(CC, E); .)
    ")"
    Block<B>                            (. B.BlockType := btCatch;
                                           InsertStmtTail(CC, B, false); .)
    .

  TryStatement<out S:TJSStatement> DESCRIPTION "Try statement"
                                        (. var ClauseCount: integer;
                                               B: TJSBlock;
                                               CC: TJSTagGroup;
                                         .)
  =
                                        (. ClauseCount := 0;
                                           S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stThrowStatement;
                                        .)
    "try"
    Block<B>                            (. B.BlockType := btTry;
                                           InsertStmtTail(S,B);
                                        .)
    {
      CatchClause<CC>                   (. Inc(ClauseCount);
                                           InsertTagGroupTail(S, CC, false);
                                        .)
    }
    [
      FinallyClause<B>                  (. Inc(ClauseCount);
                                           InsertStmtTail(S, B, false);
                                        .)
    ]
                                        (. if ClauseCount = 0 then ParseWarning(1005, ''); .)
  .

  ThrowStatement<out S:TJSStatement> DESCRIPTION "Throw statement"
                                        (. var LVALStart: boolean;
                                               E: TJSExpr;
                                        .)
  =
                                        (. LValStart := true;
                                           S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stThrowStatement;
                                        .)
    "throw"
    Expression_Normal_AllowIn<E, LVALStart>
                                        (. InsertExprTail(S, E);  .)
  .

  ReturnStatement<out S:TJSStatement> DESCRIPTION "Return statement"
                                        (. var E:TJSExpr; .)
  =
                                        (. S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stReturnStatement;
                                        .)
    "return"
    OptionalExpression<E>               (. if Assigned(E) then
                                             InsertExprTail(S,E);
                                        .)
  .

  OptionalLabel<out I: TJSIdentifier> DESCRIPTION "OptionalLabel"
  =
                                        (. I := nil; .)
    [
      Identifier<I>
    ]
  .

  BreakStatement<out S:TJSStatement> DESCRIPTION "Break statement"
                                        (. var I:TJSIdentifier; .)
  =
                                        (. S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stBreakStatement;
                                        .)
    "break"
    OptionalLabel<I>                    (. if Assigned(I) then
                                             InsertExprTail(S, I);
                                        .)
  .

  ContinueStatement<out S:TJSStatement> DESCRIPTION "Continue statement"
                                        (. var I:TJSIdentifier; .)
  =
                                        (. S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stContinueStatement;
                                        .)
    "continue"
    OptionalLabel<I>                    (. if Assigned(I) then
                                             InsertExprTail(S, I);
                                        .)
  .

  WithStatement_Full<out S:TJSStatement> DESCRIPTION "With statement"
                                        (. var LVALStart: boolean;
                                               E: TJSExpr;
                                               SSub: TJSStatement; .)
  =
                                        (. LValStart := true;
                                           S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stWithStatement;
                                         .)
    "with"
    ParenthesizedExpression<E, LVALStart>
                                        (. InsertExprTail(S,E); .)
    Statement_Full<SSub>                (. InsertStmtTail(S, SSub, false); .)
  .

  ForPossibleInitializers<out E: TJSExpr; var HasInBinding: boolean> DESCRIPTION "First part of a for statement"
                                        (. var LVALStart,JustOne: boolean;
                                           var E2, E3: TJSExpr;
                                           var VVList: TJSExprList; .)
  =
                                        (. LValStart := true;
                                           HasInBinding := false;
                                           E := nil;
                                        .)
    [
      (
        Expression_Normal_NoIn<E2, LVALStart> //Just a for initializer at this point.
        [
          "in"                            //becomes a for-in binding, prev must be left side.
                                          (. if not LVALStart then SynError(1001);
                                             HasInBinding := true;
                                             LValStart := true; .)
          Expression_Normal_AllowIn<E3, LVALStart>
                                         (.
                                            E := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                            E.ExprType := etInOperator;
                                            InsertExprTail(E, E2);
                                            InsertExprTail(E, E3);
                                         .)
        ]
                                         (. if not Assigned(E) then E := E2; .)
      )
      |
      (
        "var"
        VariableDeclarationList_NoIn<VVList, JustOne>
        [
          "in"                            //becomes a for-in binding, prev must be just one.
                                          (. if not JustOne then SynError(1003);
                                             HasInBinding := true;
                                             LValStart := true;

                                             //Pluck var decl out of list, and dispose of list.
                                             E2 := RemoveExprHead(VVList);
                                             VVList.Free;
                                             VVList := nil;
                                           .)
          Expression_Normal_AllowIn<E3, LValStart>
                                        (. E := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           E.ExprType := etVarInDecl;
                                           InsertExprTail(E, E2);
                                           InsertExprTail(E, E3);
                                        .)
        ]
                                        (. if not Assigned(E) then
                                           begin
                                            E := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                            E.ExprType := etVarDecl;
                                            InsertExprListTail(E, VVList);
                                           end;
                                        .)
      )
    ]
                                        (.
                                           if not Assigned(E) then
                                           begin
                                             E := TJSSimpleExpr.CreateWithTracker(FParseTracker as TTracker);
                                             E.ExprType := etSimpleExpression;
                                             (E as TJSSimpleExpr).SimpleExprType := setNull;
                                           end;
                                        .)
  .

  ForStatement_Full<out S: TJSStatement> DESCRIPTION "For statement"
                                        (. var HasInBinding: boolean;
                                               E: TJSExpr;
                                               EList: TJSExprList;
                                               SBody: TJSStatement;
                                         .)
  =
                                        (.
                                           S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stForStatement;
                                           EList := TJsExprList.CreateWithTracker(FParseTracker as TTracker);
                                           EList.ListType := eltForInitializers;
                                           InsertExprListTail(S, EList);
                                        .)

    "for" "("
    (
        ForPossibleInitializers<E, HasInBinding>
                                        (. InsertExprTail(EList, E); .)
        [
          ";"
                                        (. if HasInBinding then
                                             SynError(1002); .)
          OptionalExpression<E>         (. if Assigned(E) then
                                            InsertExprTail(EList, E)
                                           else
                                           begin
                                             E := TJSSimpleExpr.CreateWithTracker(FParseTracker as TTracker);
                                             E.ExprType := etSimpleExpression;
                                             (E as TJSSimpleExpr).SimpleExprType := setNull;
                                             InsertExprTail(EList, E);
                                           end; .)
          ";"
          OptionalExpression<E>         (. if Assigned(E) then
                                             InsertExprTail(EList, E)
                                           else
                                           begin
                                             E := TJSSimpleExpr.CreateWithTracker(FParseTracker as TTracker);
                                             E.ExprType := etSimpleExpression;
                                             (E as TJSSimpleExpr).SimpleExprType := setNull;
                                             InsertExprTail(EList, E);
                                           end; .)
        ]
    )
    ")"
    Statement_Full<SBody>               (. InsertStmtTail(S, SBody, false); .)
  .

  WhileStatement_Full<out S: TJSStatement> DESCRIPTION "While statement"
    (. var LVALStart: boolean; E: TJSExpr; SRep: TJSStatement; .)
  =
                                        (. LValStart := true;
                                           S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stWhileStatement;
                                        .)
    "while"
    ParenthesizedExpression<E, LVALStart>
    Statement_Full<SRep>
                                        (.
                                          InsertExprTail(S, E);
                                          InsertStmtTail(S, SRep, false);
                                        .)
  .

  DoStatement<out S: TJSStatement> DESCRIPTION "Do statement"
    (. var LVALStart: boolean; E: TJSExpr; SRep: TJSStatement; .)
  =
                                        (. LValStart := true;
                                           S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stDoStatement;
                                        .)
    "do"
    Statement_Full<SRep>
    "while"
    ParenthesizedExpression<E, LVALStart>
                                        (.
                                          InsertExprTail(S, E);
                                          InsertStmtTail(S,SRep, false);
                                        .)
  .

  CaseGuard<out G: TJSExpr> DESCRIPTION "Case guard"
    (. var LVALStart: boolean; .)
  =
    (. LValStart := true;
       G := nil; .)
    (
      "case" Expression_Normal_AllowIn<G, LVALStart>
      |
      "default"                         (. G := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           G.ExprType := etDefaultCase; .)
    )
    ":"
  .

  CaseGuards<var CG: TJSTagGroup> DESCRIPTION "Case guards"
                                        (. var GuardExpr: TJSExpr; .)
  =
    CaseGuard<GuardExpr>                (. InsertExprTail(CG, GuardExpr); .)
    {
      CaseGuard<GuardExpr>              (. InsertExprTail(CG, GuardExpr); .)
    }
  .

  CaseGroup<out CG: TJSTagGroup> DESCRIPTION "Case group"
                                        (. var B: TJSBlock; .)
  =
                                        (. CG := TJSTagGroup.CreateWithTracker(FParseTracker as TTracker);
                                           CG.TagGroupType := ttgCaseGroup; .)
    CaseGuards<CG>
    BlockStatements<B>                  (. B.BlockType := btCaseGroup;
                                           InsertStmtTail(CG, B, false); .)
  .

  CaseGroups<var S: TJSStatement> DESCRIPTION "Case groups"
                                        (. var CG: TJSTagGroup; .)
  =
    {
      CaseGroup<CG>                     (. InsertTagGroupTail(S, CG, false); .)
    }
                                        (. if not (S as TJSSwitchStatement).CheckNoDupDefaults then
                                             SynError(1011);
                                         .)
  .

  SwitchStatement<out S: TJSStatement> DESCRIPTION "Switch statement"
    (. var LVALStart: boolean; E: TJSExpr;
    .)
  =
                                        (. LValStart := true;
                                           S := TJSSwitchStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stSwitchStatement;
                                        .)
    "switch" ParenthesizedExpression<E, LVALStart>
                                        (. InsertExprTail(S, E); .)
    "{"
      CaseGroups<S>
    "}"
  .

  IfStatement_Full<out S:TJSStatement> DESCRIPTION "If statement"
                                        (. var LVALStart: boolean;
                                               E: TJsExpr;
                                               IfStmt: TJSStatement;
                                               ElseStmt: TJSStatement;
                                        .)
  =
                                        (. LValStart := true;
                                           S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stIfStatement;
                                        .)
    "if"
    ParenthesizedExpression<E, LVALStart> (. InsertExprTail(S, E); .)
    Statement_Full<IfStmt>                (. InsertStmtTail(S, IfStmt, false); .)
    //Recursive descent parser will try to bind else onto the
    //innermost if, which is generally what we want.
    [
      "else"
      Statement_Full<ElseStmt>            (. InsertStmtTail(S, ElseStmt, false); .)
    ]
  .

  BlockStatements<out B: TJSBlock> DESCRIPTION "Block statements"
                                        (. var S: TJSStatement; .)
  =
                                        (. B := TJSBlock.CreateWithTracker(FParseTracker as TTracker);
                                        .)
    {
      Statement_Full<S>                 (. InsertStmtTail(B, S);.)
    }
  .

  Block<out B: TJSBlock> DESCRIPTION "Block"
  =
    "{"
        BlockStatements<B>              (. B.BlockType := btExplicit; .)
    "}"
  .

  VariableInitializer_AllowIn<out Init: TJSExpr> DESCRIPTION "Variable initializer"
                                        (. var LVALStart: boolean; .)
  =
                                        (. LValStart := true; Init := nil;.)
    [
      "="
      AssignmentExpression_Normal_AllowIn<Init, LVALStart>
    ]
  .

  VariableInitializer_NoIn<out Init: TJSExpr> DESCRIPTION "Variable initializer"
    (. var LVALStart: boolean; .)
  =
    (. LValStart := true; Init := nil;.)
    [
      "="
      AssignmentExpression_Normal_NoIn<Init, LVALStart>
    ]
  .

  VariableDeclaration_AllowIn<out VD: TJSExpr> DESCRIPTION "Variable declaration"
                                        (. var I: TJSIdentifier; Init: TJSExpr; .)
  =
                                        (. VD := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           VD.ExprType := etVarDecl; .)
    Identifier<I>                       (. InsertExprTail(VD, I); .)
    VariableInitializer_AllowIn<Init>   (. if Assigned(Init) then
                                             InsertExprTail(VD, Init); .)
  .

  VariableDeclaration_NoIn<out VD: TJSExpr> DESCRIPTION "Variable declaration"
                                        (. var I: TJSIdentifier; Init: TJSExpr; .)
  =
                                        (. VD := TJSExpr.CreateWithTracker(FParseTracker as TTracker);
                                           VD.ExprType := etVarDecl; .)
    Identifier<I>                       (. InsertExprTail(VD, I); .)
    VariableInitializer_NoIn<Init>      (. if Assigned(Init) then
                                             InsertExprTail(VD, Init); .)
  .

  VariableDeclarationList_AllowIn<out EL: TJSExprList> DESCRIPTION "Variable declaration list"
                                        (. var VD:TJSExpr; .)
  =
                                        (. EL := TJSExprList.CreateWithTracker(FParseTracker as TTracker);
                                           EL.ListType := eltVarDecls; .)
    VariableDeclaration_AllowIn<VD>      (. InsertExprTail(EL, VD); .)
    {
      "," VariableDeclaration_AllowIn<VD>(. InsertExprTail(EL, VD); .)
    }
  .

  VariableDeclarationList_NoIn<out EL: TJSExprList; var JustOne: boolean> DESCRIPTION "Variable declaration list"
                                        (. var VD:TJSExpr; .)
  =
                                        (. EL := TJSExprList.CreateWithTracker(FParseTracker as TTracker);
                                           EL.ListType := eltVarDecls;
                                           JustOne := true; .)
    VariableDeclaration_NoIn<VD>        (. InsertExprTail(EL, VD); .)
    {
      ","                               (. JustOne := false; .)
      VariableDeclaration_NoIn<VD>      (. InsertExprTail(EL, VD); .)
    }
  .

  VariableDefinition<out S:TJSStatement> DESCRIPTION "Variable definition"
                                        (. var EL: TJSExprList; .)
  =
                                        (. S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stVarDeclStatement;
                                        .)
    "var"
    VariableDeclarationList_AllowIn<EL>
                                        (. InsertExprListTail(S, EL); .)
  .

  ExpressionOrLabelStatement_Full<out S:TJSStatement> DESCRIPTION "Expression statement"
                                        (. var LVALStart: boolean; E: TJSExpr; S2:TJSStatement; .)
  =
                                        (. LValStart := true;
                                           S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stExpressionStatement;
                                        .)
    Expression_Initial_AllowIn<E, LVALStart>
                                        (. InsertExprTail(S, E); .)

    [
      ":"
                                        (. S.StatType := stLabelStatement;
                                           if not (E is TJSIdentifier) then SynError(1004); .)
      Statement_Full<S2>
                                        (. InsertStmtTail(S, S2, false); .)
    ]
  .

  OptionalSemicolon DESCRIPTION "Optional semicolon"
  =
    [ ";" ]
  .

  EmptyStatement<out S: TJSStatement> DESCRIPTION "Empty statement"
  =
    ";"
                                        (. S := TJSStatement.CreateWithTracker(FParseTracker as TTracker);
                                           S.StatType := stEmpty; .)
  .

  Statement_Full<out S:TJSStatement> DESCRIPTION "Statement"
                                        (. var B: TJSBlock; .)
  =
                                        (. S := nil; .)
    (
      EmptyStatement<S>
      |
      ExpressionOrLabelStatement_Full<S> OptionalSemicolon
      |
      VariableDefinition<S> OptionalSemicolon
      |
      Block<B>                          (. S := B; .)
      |
      IfStatement_Full<S>
      |
      SwitchStatement<S>
      |
      DoStatement<S> OptionalSemicolon
      |
      WhileStatement_Full<S>
      |
      ForStatement_Full<S>
      |
      WithStatement_Full<S>
      |
      ContinueStatement<S> OptionalSemicolon
      |
      BreakStatement<S> OptionalSemicolon
      |
      ReturnStatement<S> OptionalSemicolon
      |
      ThrowStatement<S> OptionalSemicolon
      |
      TryStatement<S>
      |
      FunctionDefinition<S>             (. ParseWarning(1006, ''); .)
    )
  .

  FormalParameter<out E:TJSExpr> DESCRIPTION "Formal parameter"
                                (. var I: TJSIdentifier; .)
  =
    Identifier<I>               (. E := I; .)
  .

  FormalParameters<out P:TJSExprList> DESCRIPTION "Formal parameters"
                                (. var E: TJSExpr; .)
  =
                                (. P := TJSExprList.CreateWithTracker(FParseTracker as TTracker);
                                   P.ListType := eltFormalParameters; .)
    [
      FormalParameter<E>        (. InsertExprTail(P, E); .)
      { ","
        FormalParameter<E>      (. InsertExprTail(P, E);  .)
      }
    ]
  .

  FormalParametersAndBody<var F:TJSFunction> DESCRIPTION "Formal parameters and body"
                                (. var P: TJSExprList; var B: TJSBlock; .)
  =
    "("
    FormalParameters<P>         (. InsertExprListTail(F, P); .)
    ")"
    "{"
    TopStatements<B>            (. InsertStmtTail(F, B, false);
                                   B.BlockType := btTopOrFunction; .)
    "}"
  .

  NamedFunctionDecl<out F:TJSFunction> DESCRIPTION "Named function"
  =
                                (. F := TJSFunction.CreateWithTracker(FParseTracker as TTracker); .)
    _Identifier                 (. F.FuncName := LexString; .)
    FormalParametersAndBody<F>
  .

  AnonymousFunctionDecl<out F:TJSFunction> DESCRIPTION "Anonymous function"
  =
                                (. F := TJSFunction.CreateWithTracker(FParseTracker as TTracker); .)
    FormalParametersAndBody<F>
  .

  FunctionDefinition<out F:TJSStatement> DESCRIPTION "Function definition"
                                        (. var FD: TJSFunction; .)
  =
    "function"
    NamedFunctionDecl<FD>              (. F := FD; .)
  .

  TopStatement<out S:TJSStatement> DESCRIPTION "Top level statement"
  =
                                        (. S := nil; .)
    (
      FunctionDefinition<S>
      |
      Statement_Full<S>
    )
  .

  TopStatements<out B: TJSBlock> DESCRIPTION "Top level statements"
                        (. var S: TJSStatement; .)
  =
                        (. B := TJSBlock.CreateWithTracker(FParseTracker as TTracker);
                           B.BlockType := btTopOrFunction;
                         .)
    {
      TopStatement<S>   (. InsertStmtTail(B, S); .)
    }
  .

  HtmlEncapsulateTag =
    HtmlEncapsulation1 |HtmlEncapsulation2 | HtmlEncapsulation3 | HtmlEncapsulation4
  .

  HtmlEncapsulation =
  {
    HtmlEncapsulateTag  (. ParseWarning(1007, ''); .)
  }
  .

  JScriptGrammar DESCRIPTION "Javascript program"
                        (. var Stmts: TJSBlock;
                               Sc: T-->Grammar<--Scanner;
                        .)
  =
                        (. FParseResult := TJSScript.CreateWithTracker(FParseTracker as TTracker); .)
    HtmlEncapsulation
    TopStatements<Stmts>(. //Only insert Statements block if it contains some
                           //statements, so that we can relibably detect the NULL document.
                           if not DLItemIsEmpty(@Stmts.ContainedListHead) then
                             InsertStmtTail((FParseResult as TJSScript), Stmts)
                           else
                             Stmts.Free; //FParseResult has no children.
                        .)
    HtmlEncapsulation
    (
      "<"                 (. //Trailing HTML in inline script: </script>
                             Sc := (Scanner as T-->Grammar<--Scanner);
                             StreamPartRead := Sc.BufferPosition;
                          .)
      |
      EOF                  //Actual end of file.
    )
  .

END JScriptGrammar.
