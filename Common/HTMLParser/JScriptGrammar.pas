unit JScriptGrammar;




{==============================================================================
JScriptGrammar
0.0.0.0
Date of Generation: 07/03/2020 19:18
Comment: Javascript parser.
Author: Martin Harvey
Copyright: (c) Martin Harvey

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,Trackables,CommonNodes,JSNodes;



const
maxT = 87;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EJScriptGrammar = class(Exception);
  TJScriptGrammar = class;

  TJScriptGrammarScanner = class(TCocoRScanner)
  private
    FOwner : TJScriptGrammar;
function CharInIgnoreSet(const Ch : AnsiChar) : boolean;
procedure CheckLiteral(var Sym : integer);
function Equal(s : AnsiString) : boolean;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TJScriptGrammar read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TJScriptGrammarScanner }

  TJScriptGrammar = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..13] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : AnsiString;
    function GetVersionStr : AnsiString;
    procedure SetVersion(const Value : AnsiString);
    function GetVersionInfo : AnsiString;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _JScriptGrammar;
    procedure _HtmlEncapsulation;
    procedure _HtmlEncapsulateTag;
    procedure _TopStatement (out S:TJSStatement);
    procedure _TopStatements (out B: TJSBlock);
    procedure _FormalParametersAndBody (var F:TJSFunction);
    procedure _FormalParameters (out P:TJSExprList);
    procedure _FormalParameter (out E:TJSExpr);
    procedure _FunctionDefinition (out F:TJSStatement);
    procedure _EmptyStatement (out S: TJSStatement);
    procedure _OptionalSemicolon;
    procedure _ExpressionOrLabelStatement_Full (out S:TJSStatement);
    procedure _VariableDefinition (out S:TJSStatement);
    procedure _VariableDeclarationList_AllowIn (out EL: TJSExprList);
    procedure _VariableDeclaration_NoIn (out VD: TJSExpr);
    procedure _VariableDeclaration_AllowIn (out VD: TJSExpr);
    procedure _VariableInitializer_NoIn (out Init: TJSExpr);
    procedure _VariableInitializer_AllowIn (out Init: TJSExpr);
    procedure _IfStatement_Full (out S:TJSStatement);
    procedure _SwitchStatement (out S: TJSStatement);
    procedure _CaseGroups (var S: TJSStatement);
    procedure _BlockStatements (out B: TJSBlock);
    procedure _CaseGroup (out CG: TJSTagGroup);
    procedure _CaseGuards (var CG: TJSTagGroup);
    procedure _CaseGuard (out G: TJSExpr);
    procedure _DoStatement (out S: TJSStatement);
    procedure _WhileStatement_Full (out S: TJSStatement);
    procedure _ForStatement_Full (out S: TJSStatement);
    procedure _VariableDeclarationList_NoIn (out EL: TJSExprList; var JustOne: boolean);
    procedure _ForPossibleInitializers (out E: TJSExpr; var HasInBinding: boolean);
    procedure _Statement_Full (out S:TJSStatement);
    procedure _WithStatement_Full (out S:TJSStatement);
    procedure _ContinueStatement (out S:TJSStatement);
    procedure _BreakStatement (out S:TJSStatement);
    procedure _OptionalLabel (out I: TJSIdentifier);
    procedure _ReturnStatement (out S:TJSStatement);
    procedure _ThrowStatement (out S:TJSStatement);
    procedure _TryStatement (out S:TJSStatement);
    procedure _CatchClause (out CC: TJSTagGroup);
    procedure _Block (out B: TJSBlock);
    procedure _FinallyClause (out B: TJSBlock);
    procedure _Expression_Initial_AllowIn (out E: TJSExpr; var IsLVAL: boolean);
    procedure _Expression_Normal_NoIn (out E: TJSExpr; var IsLVAL: boolean);
    procedure _OptionalExpression (out E: TJSExpr);
    procedure _AssignmentExpression_Initial_AllowIn (out E: TJSExpr; var IsLVAL: boolean);
    procedure _CompoundAssignment (out E:TJSMultiAssign);
    procedure _ConditionalExpression_Initial_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _ConditionalExpression_Normal_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _AssignmentExpression_Normal_NoIn (out E: TJSExpr; var IsLVAL: boolean);
    procedure _ConditionalExpression_Normal_NoIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _LogicalAndExpression_Initial_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _LogicalOrExpression_Initial_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _LogicalAndExpression_Normal_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _LogicalOrExpression_Normal_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _LogicalAndExpression_Normal_NoIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _LogicalOrExpression_Normal_NoIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseAndExpression_Initial_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseAndExpression_Normal_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseAndExpression_Normal_NoIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseXorExpression_Initial_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseOrExpression_Initial_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseXorExpression_Normal_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseOrExpression_Normal_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseXorExpression_Normal_NoIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _BitwiseOrExpression_Normal_NoIn (out E:TJSExpr; IsLVAL: boolean);
    procedure _EqualityExpression_Initial_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _EqualityExpression_Normal_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _EqualityExpression_Normal_NoIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _RelationalExpression_Normal_NoIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _RelationalExpression_Initial_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _RelationalExpression_Normal_AllowIn (out E:TJSExpr; var IsLVAL: boolean);
    procedure _ShiftExpression_Initial (out E: TJSExpr; var IsLVAL: boolean);
    procedure _ShiftExpression_Normal (out E: TJSExpr; var IsLVAL: boolean);
    procedure _AdditiveExpression_Initial (out E: TJSExpr; var IsLVAL: boolean);
    procedure _AdditiveExpression_Normal (out E: TJSExpr; var IsLVAL: boolean);
    procedure _MultiplicativeExpression_Initial (out E: TJSExpr; var IsLVAL: boolean);
    procedure _MultiplicativeExpression_Normal (out E: TJSExpr; var IsLVAL: boolean);
    procedure _UnaryExpression_Initial (out E: TJSExpr; var IsLVAL: boolean);
    procedure _UnaryExpression_Normal (out E: TJSExpr; var IsLVAL: boolean);
    procedure _PostfixExpression_Initial (out E:TJSExpr; var IsLVAL: boolean);
    procedure _PostfixExpression_Normal (out E:TJSExpr; var IsLVAL: boolean);
    procedure _LeftSideExpression_Initial (out E:TJSExpr; var IsLVAL: boolean);
    procedure _LeftSideExpression_Normal (out E:TJSExpr; var IsLVAL: boolean);
    procedure _CallExpression_Initial (out E:TJSExpr; var IsLVAL: boolean);
    procedure _CallExpression_Normal (out E:TJSExpr; var IsLVAL: boolean);
    procedure _FullNewExpression (out E: TJSExpr);
    procedure _FullNewSubexpression (out E: TJSExpr);
    procedure _MemberOperator (out E:TJSExpr);
    procedure _Arguments (out L: TJSExprList);
    procedure _ArgumentList (var L: TJSExprList);
    procedure _ElementList (out L:TJSExprList);
    procedure _LiteralElement (out E: TJSExpr);
    procedure _FieldList (out L:TJSExprList);
    procedure _AssignmentExpression_Normal_AllowIn (out E: TJSExpr; var IsLVAL: boolean);
    procedure _LiteralField (out F: TJSExpr);
    procedure _NamedFunctionDecl (out F:TJSFunction);
    procedure _AnonymousFunctionDecl (out F:TJSFunction);
    procedure _Expression_Normal_AllowIn (out E: TJSExpr; var IsLVAL: boolean);
    procedure _ArrayLiteral (out E:TJSSimpleExpr);
    procedure _ParenthesizedExpression (out E: TJSExpr; var IsLVAL: boolean);
    procedure _PrimaryExpression_Initial (out E: TJSExpr; var IsLVAL: boolean);
    procedure _ObjectLiteral (out E:TJSSImpleExpr);
    procedure _FunctionExpression (out E: TJSExpr);
    procedure _SimpleExpression (out E: TJSExpr; var IsLVAL: boolean);
    procedure _PrimaryExpression_Normal (out E: TJSExpr; var IsLVAL: boolean);
    procedure _StringLiteral (out S: TJSString);
    procedure _RegularExpression (out ST:TJSString);
    procedure _RegularExpressionFlags (out S:string);
    procedure _RegularExpressionBody (var Res:string);
    procedure _RegularExpressionClassChars (var Res: string);
    procedure _RegularExpressionEscapeSequence (var Res: string);
    procedure _Number (out N:TJSNumber);
    procedure _Identifier (out I:TJSIdentifier);

  private
    FParentObject: TObject;

  protected
    {$IFDEF DEBUG_TOKENS}
    procedure DebugLogToken(Sender : TObject; var CurrentInputSymbol : integer);
{$ENDIF}
    procedure RewindLexer(i: integer);
    procedure AbortParse;
    procedure InsertStmtTail(C: TJSNode; S: TJSStatement; CheckNeighbours:boolean = true);
    procedure InsertStmtHead(C: TJSNode; S: TJSStatement; CheckNeighbours:boolean = true);
    procedure InsertExprTail(C: TJSNode; E: TJSExpr; CheckNeighbours:boolean = true);
    procedure InsertExprHead(C: TJSNode; E: TJSExpr; CheckNeighbours:boolean = true);
    procedure InsertExprListTail(C: TJSNode; EL: TJSExprList; CheckNeighbours:boolean = true);
    procedure InsertTagGroupTail(C: TJSNode; TG: TJSTagGroup; CheckNeighbours:boolean = true);
    function RemoveExprHead(C: TJSNode; CheckNeighbours:boolean = true): TJSExpr;

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString; override;
    procedure Execute; override;
    function GetScanner : TJScriptGrammarScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : AnsiString read GetVersionStr;
    property VersionInfo : AnsiString read GetVersionInfo;

  public
    procedure SetLocation(N: TJSNode);
    procedure ParseWarning(Code: integer; S: string);
    property ParentObject:TObject read FParentObject write FParentObject;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : AnsiString read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TJScriptGrammar }

implementation
uses  HTMLParser,HTMLParseEvents,StrUtils,IOUtils,DLList;



const

  EOFSYMB = 0;  HtmlEncapsulation1Sym = 1;  HtmlEncapsulation2Sym = 2;
  HtmlEncapsulation3Sym = 3;  HtmlEncapsulation4Sym = 4;  _IdentifierSym = 5;
  _NumberSym = 6;  DQuotStringSym = 7;  SQuotStringSym = 8;  _backslashSym = 9;
  _slashSym = 10;  _slash_equalSym = 11;  thisSym = 12;  nullSym = 13;
  falseSym = 14;  trueSym = 15;  _lparenSym = 16;  _rparenSym = 17;
  functionSym = 18;  returnSym = 19;  defaultSym = 20;  catchSym = 21;
  deleteSym = 22;  thenSym = 23;  forSym = 24;  _colonSym = 25;  _commaSym = 26;
  _lbraceSym = 27;  _rbraceSym = 28;  _lbrackSym = 29;  _rbrackSym = 30;
  _pointSym = 31;  newSym = 32;  _plus_plusSym = 33;  _minus_minusSym = 34;
  voidSym = 35;  typeofSym = 36;  _plusSym = 37;  _minusSym = 38;
  _tildeSym = 39;  _bangSym = 40;  _starSym = 41;  _percentSym = 42;
  _less_lessSym = 43;  _greater_greaterSym = 44;
  _greater_greater_greaterSym = 45;  _lessSym = 46;  _greaterSym = 47;
  _less_equalSym = 48;  _greater_equalSym = 49;  instanceofSym = 50;
  inSym = 51;  _equal_equalSym = 52;  _bang_equalSym = 53;
  _equal_equal_equalSym = 54;  _bang_equal_equalSym = 55;  _barSym = 56;
  _uparrowSym = 57;  _andSym = 58;  _bar_barSym = 59;  _and_andSym = 60;
  _querySym = 61;  _star_equalSym = 62;  _percent_equalSym = 63;
  _plus_equalSym = 64;  _minus_equalSym = 65;  _less_less_equalSym = 66;
  _greater_greater_equalSym = 67;  _greater_greater_greater_equalSym = 68;
  _and_equalSym = 69;  _uparrow_equalSym = 70;  _bar_equalSym = 71;
  _equalSym = 72;  finallySym = 73;  trySym = 74;  throwSym = 75;
  breakSym = 76;  continueSym = 77;  withSym = 78;  varSym = 79;
  _semicolonSym = 80;  whileSym = 81;  doSym = 82;  caseSym = 83;
  switchSym = 84;  ifSym = 85;  elseSym = 86;  NOSYMB = 87;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
{ Arbitrary code }

{

Copyright © 2020 Martin Harvey <martin_c_harvey@hotmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

}

{$IFDEF DEBUG_TOKENS}
procedure TJScriptGrammar.DebugLogToken(Sender : TObject; var CurrentInputSymbol : integer);
var
  LogStr: AnsiString;
  LexStr: AnsiString;
  DbgLexChar: AnsiString;
begin
  LexStr := LexString;
  if Length(LexStr) > 0 then
    DbgLexChar := AnsiString(IntToStr(Byte(LexString[1])) + ' ')
  else
    DbgLexChar := '';

  LogStr := AnsiString(IntToStr(CurrentInputSymbol) + ' : ' + DbgLexChar +  LexString + CHR(13) + CHR(10));
  Assert(false); //Reinsert logging call.
  //GLogLog(SV_TRACE, LogStr);
end;

{$ENDIF}

procedure TJScriptGrammar.AbortParse;
begin
  raise EParseAbort.Create(ErrorStr(1012, ''),
                (Scanner as TJScriptGrammarScanner).NextSymbol.Line,
                (Scanner as TJScriptGrammarScanner).NextSymbol.Col);
end;

procedure TJScriptGrammar.ParseWarning(Code: integer; S: string);
var
  Sc: TJScriptGrammarScanner;
begin
  Sc := (Scanner as TJScriptGrammarScanner);
  if Assigned(ParentObject) and (ParentObject is THTMLParseItem) then
  begin
    (ParentObject as THTMLParseItem).EventList.Add(
      TParseEvent.CreateFromParseWarning(
      Sc.NextSymbol.Col, Sc.NextSymbol.Line, Code, ErrorStr(Code, AnsiString(S)) + AnsiString(S), self));
  end;
end;

procedure TJScriptGrammar.SetLocation(N: TJSNode);
begin
  N.Line := (Scanner as TJScriptGrammarScanner).CurrentSymbol.Line;
  N.Col := (Scanner as TJScriptGrammarScanner).CurrentSymbol.Col;
end;

//TODO - this messes up symbol line and column positions.
//Needs investigating.
procedure TJScriptGrammar.RewindLexer(i: integer);
var
  Sc: TJScriptGrammarScanner;

begin
  Sc := (Scanner as TJScriptGrammarScanner);
  //Assumes we do not rewind over cr/lf etc.
  Sc.BufferPosition := Sc.BufferPosition - i;

  if Sc.BufferPosition > 0 then
    Sc.LastInputCh := Sc.CurrentCh(Pred(Sc.BufferPosition))
  else
    Sc.LastInputCh := _EF;

  Sc.SrcStream.Seek(Sc.BufferPosition, soFromBeginning);
  Sc.CurrInputCh := Sc.CurrentCh(Sc.BufferPosition);
end;


procedure TJScriptGrammar.InsertStmtTail(C: TJSNode; S: TJSStatement; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(S) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := S.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(S is TJSStatement);
  Assert(DLItemIsEmpty(@S.SiblingListEntry));
  DLListInsertTail(@C.ContainedListHead, @S.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := S.SiblingListEntry.FLink.Owner;
    NO := S.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSStatement));
    Assert((not Assigned(NO)) or (NO is TJSStatement));
  end;
{$ENDIF}
end;

procedure TJScriptGrammar.InsertStmtHead(C: TJSNode; S: TJSStatement; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(S) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := S.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(S is TJSStatement);
  Assert(DLItemIsEmpty(@S.SiblingListEntry));
  DLListInsertHead(@C.ContainedListHead, @S.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := S.SiblingListEntry.FLink.Owner;
    NO := S.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSStatement));
    Assert((not Assigned(NO)) or (NO is TJSStatement));
  end;
{$ENDIF}
end;

procedure TJScriptGrammar.InsertExprTail(C: TJSNode; E: TJSExpr; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(E) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := E.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(E is TJSExpr);
  Assert(DLItemIsEmpty(@E.SiblingListEntry));
  DLListInsertTail(@C.ContainedListHead, @E.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := E.SiblingListEntry.FLink.Owner;
    NO := E.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSExpr));
    Assert((not Assigned(NO)) or (NO is TJSExpr));
  end;
{$ENDIF}
end;

procedure TJScriptGrammar.InsertExprHead(C: TJSNode; E: TJSExpr; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(E) then
    AbortParse;
  Assert(C is TJSNode);
  Assert(E is TJSExpr);
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := E.ClassName;
{$ENDIF}
  Assert(DLItemIsEmpty(@E.SiblingListEntry));
  DLListInsertHead(@C.ContainedListHead, @E.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := E.SiblingListEntry.FLink.Owner;
    NO := E.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSExpr));
    Assert((not Assigned(NO)) or (NO is TJSExpr));
  end;
{$ENDIF}
end;

procedure TJScriptGrammar.InsertExprListTail(C: TJSNode; EL: TJSExprList; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(EL) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := EL.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(EL is TJSExprList);
  Assert(DLItemIsEmpty(@EL.SiblingListEntry));
  DLListInsertTail(@C.ContainedListHead, @EL.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := EL.SiblingListEntry.FLink.Owner;
    NO := EL.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSExprList));
    Assert((not Assigned(NO)) or (NO is TJSExprList));
  end;
{$ENDIF}
end;

procedure TJScriptGrammar.InsertTagGroupTail(C: TJSNode; TG: TJSTagGroup; CheckNeighbours:boolean);
{$IFOPT C+}
var
  PO, NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) or not Assigned(TG) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
  DebugStr2 := TG.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
  Assert(TG is TJSTagGroup);
  Assert(DLItemIsEmpty(@TG.SiblingListEntry));
  DLListInsertTail(@C.ContainedListHead, @TG.SiblingListEntry);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    PO := TG.SiblingListEntry.FLink.Owner;
    NO := TG.SiblingListEntry.BLink.Owner;
    Assert((not Assigned(PO)) or (PO is TJSTagGroup));
    Assert((not Assigned(NO)) or (NO is TJSTagGroup));
  end;
{$ENDIF}
end;

function TJScriptGrammar.RemoveExprHead(C: TJSNode; CheckNeighbours:boolean): TJSExpr;
var
  O: TObject;
  E: PDLEntry;
{$IFOPT C+}
  NO: TObject;
  DebugStr, DebugStr2: string;
{$ENDIF}
begin
  if not Assigned(C) then
    AbortParse;
{$IFOPT C+}
  DebugStr := C.ClassName;
{$ENDIF}
  Assert(C is TJSNode);
{$IFOPT C+}
  if CheckNeighbours then
  begin
    NO := C.ContainedListHead.FLink.Flink.Owner;
    Assert(not Assigned(NO) or (NO is TJSExpr));
  end;
{$ENDIF}
  E := DLListRemoveHead(@C.ContainedListHead);
  if not Assigned(E) then
    AbortParse;
  Assert(Assigned(E.Owner));
  O := E.Owner;
{$IFOPT C+}
  DebugStr2 := O.ClassName;
{$ENDIF}
  Assert(O is TJSExpr);
  result := TJSExpr(O);
end;



{ --------------------------------------------------------------------------- }
{ ---- implementation for TJScriptGrammarScanner ---- }

procedure TJScriptGrammarScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TJScriptGrammarScanner.Comment : boolean;
var
  level : integer;
  StartCommentCh: AnsiChar;
  startLine : integer;
  oldLineStart : longint;
  CommentStr : AnsiString;
begin
StartCommentCh := CurrInputCh;
  level := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = AnsiChar(10)) then
begin
level := level -  1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
level := level -  1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
end;  { Comment }

function TJScriptGrammarScanner.CharInIgnoreSet(const Ch : AnsiChar) : boolean;
begin
Result := ((CurrInputCh >= AnsiChar(9)) AND (CurrInputCh <= AnsiChar(10)) OR
(CurrInputCh = AnsiChar(13)) OR
(CurrInputCh = ' '));
end; {CharInIgnoreSet}

function TJScriptGrammarScanner.Equal(s : AnsiString) : boolean;
var
  i : integer;
  q : int64;
begin
  if NextSymbol.Len <> Length(s) then
  begin
    Result := false;
    EXIT
  end;
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    if CurrentCh(q) <> s[i] then
    begin
      Result := false;
      EXIT;
    end;
    inc(i);
    inc(q);
  end;
  Result := true
end;  {Equal}

procedure TJScriptGrammarScanner.CheckLiteral(var Sym : integer);
begin
case CurrentCh(bpCurrToken) of
  'b': if Equal('break') then
begin
sym := breakSym;
end;

  'c': if Equal('case') then
begin
sym := caseSym;
end
else if Equal('catch') then
begin
sym := catchSym;
end
else if Equal('continue') then
begin
sym := continueSym;
end;

  'd': if Equal('default') then
begin
sym := defaultSym;
end
else if Equal('delete') then
begin
sym := deleteSym;
end
else if Equal('do') then
begin
sym := doSym;
end;

  'e': if Equal('else') then
begin
sym := elseSym;
end;

  'f': if Equal('false') then
begin
sym := falseSym;
end
else if Equal('finally') then
begin
sym := finallySym;
end
else if Equal('for') then
begin
sym := forSym;
end
else if Equal('function') then
begin
sym := functionSym;
end;

  'i': if Equal('if') then
begin
sym := ifSym;
end
else if Equal('in') then
begin
sym := inSym;
end
else if Equal('instanceof') then
begin
sym := instanceofSym;
end;

  'n': if Equal('new') then
begin
sym := newSym;
end
else if Equal('null') then
begin
sym := nullSym;
end;

  'r': if Equal('return') then
begin
sym := returnSym;
end;

  's': if Equal('switch') then
begin
sym := switchSym;
end;

  't': if Equal('then') then
begin
sym := thenSym;
end
else if Equal('this') then
begin
sym := thisSym;
end
else if Equal('throw') then
begin
sym := throwSym;
end
else if Equal('true') then
begin
sym := trueSym;
end
else if Equal('try') then
begin
sym := trySym;
end
else if Equal('typeof') then
begin
sym := typeofSym;
end;

  'v': if Equal('var') then
begin
sym := varSym;
end
else if Equal('void') then
begin
sym := voidSym;
end;

  'w': if Equal('while') then
begin
sym := whileSym;
end
else if Equal('with') then
begin
sym := withSym;
end;

else
begin
end
end
end; {CheckLiteral}


procedure TJScriptGrammarScanner.Get(var sym : integer);
var
  state : integer;
  label __start_get;
 begin   {Get}
__start_get:
while CharInIgnoreSet(CurrInputCh) do
  NextCh;
if ((CurrInputCh = '/') OR (CurrInputCh = '/')) AND Comment then goto __start_get;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if (CurrInputCh = '-') then
begin
state := 2; 
end
else
begin
  sym := _noSym;
exit;
end;
   2: begin
sym := HtmlEncapsulation1Sym;
exit;
end;
   3: if (CurrInputCh = '/') then
begin
state := 4; 
end
else if (CurrInputCh = '=') then
begin
state := 66; 
end
else
begin
sym := _slashSym;
exit;
end;
   4: if (CurrInputCh = '-') then
begin
state := 5; 
end
else
begin
  sym := _noSym;
exit;
end;
   5: if (CurrInputCh = '-') then
begin
state := 6; 
end
else
begin
  sym := _noSym;
exit;
end;
   6: if (CurrInputCh = '>') then
begin
state := 7; 
end
else
begin
  sym := _noSym;
exit;
end;
   7: begin
sym := HtmlEncapsulation2Sym;
exit;
end;
   8: if (CurrInputCh = 'C') then
begin
state := 9; 
end
else
begin
  sym := _noSym;
exit;
end;
   9: if (CurrInputCh = 'D') then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  10: if (CurrInputCh = 'A') then
begin
state := 11; 
end
else
begin
  sym := _noSym;
exit;
end;
  11: if (CurrInputCh = 'T') then
begin
state := 12; 
end
else
begin
  sym := _noSym;
exit;
end;
  12: if (CurrInputCh = 'A') then
begin
state := 13; 
end
else
begin
  sym := _noSym;
exit;
end;
  13: if (CurrInputCh = '[') then
begin
state := 14; 
end
else
begin
  sym := _noSym;
exit;
end;
  14: if (CurrInputCh = '[') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  15: begin
sym := HtmlEncapsulation3Sym;
exit;
end;
  16: if (CurrInputCh = ']') then
begin
state := 17; 
end
else
begin
  sym := _noSym;
exit;
end;
  17: if (CurrInputCh = '>') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  18: if (CurrInputCh = '>') then
begin
state := 19; 
end
else
begin
  sym := _noSym;
exit;
end;
  19: begin
sym := HtmlEncapsulation4Sym;
exit;
end;
  20: if ((CurrInputCh = '$') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
 
end
else
begin
sym := _IdentifierSym;
CheckLiteral(sym);
exit;
end;
  21: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 22; 
end
else if (CurrInputCh = '.') then
begin
state := 25; 
end
else
begin
sym := _NumberSym;
exit;
end;
  22: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 24; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 23; 
end
else
begin
  sym := _noSym;
exit;
end;
  23: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 24; 
end
else
begin
  sym := _noSym;
exit;
end;
  24: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else
begin
sym := _NumberSym;
exit;
end;
  25: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 22; 
end
else
begin
sym := _NumberSym;
exit;
end;
  26: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 27; 
end
else
begin
sym := _pointSym;
exit;
end;
  27: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 22; 
end
else
begin
sym := _NumberSym;
exit;
end;
  28: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 29; 
end
else
begin
  sym := _noSym;
exit;
end;
  29: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
 
end
else
begin
sym := _NumberSym;
exit;
end;
  30: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  31: if ((CurrInputCh = AnsiChar(13))) then
begin
state := 32; 
end
else if ((CurrInputCh = AnsiChar(10))) then
begin
state := 33; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= 't') OR
(CurrInputCh >= 'v') AND (CurrInputCh <= 'w') OR
(CurrInputCh >= 'y')) then
begin
state := 30; 
end
else if (CurrInputCh = 'u') then
begin
state := 42; 
end
else if (CurrInputCh = 'x') then
begin
state := 43; 
end
else
begin
  sym := _noSym;
exit;
end;
  32: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 30; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  33: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 30; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  34: begin
sym := DQuotStringSym;
exit;
end;
  35: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  36: if ((CurrInputCh = AnsiChar(13))) then
begin
state := 37; 
end
else if ((CurrInputCh = AnsiChar(10))) then
begin
state := 38; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= 't') OR
(CurrInputCh >= 'v') AND (CurrInputCh <= 'w') OR
(CurrInputCh >= 'y')) then
begin
state := 35; 
end
else if (CurrInputCh = 'u') then
begin
state := 44; 
end
else if (CurrInputCh = 'x') then
begin
state := 45; 
end
else
begin
  sym := _noSym;
exit;
end;
  37: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 35; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  38: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 35; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  39: begin
sym := SQuotStringSym;
exit;
end;
  40: if (CurrInputCh = '!') then
begin
state := 46; 
end
else if (CurrInputCh = '<') then
begin
state := 83; 
end
else if (CurrInputCh = '=') then
begin
state := 87; 
end
else
begin
sym := _lessSym;
exit;
end;
  41: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 21; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 22; 
end
else if (CurrInputCh = '.') then
begin
state := 25; 
end
else if (CurrInputCh = 'x') then
begin
state := 28; 
end
else
begin
sym := _NumberSym;
exit;
end;
  42: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= '|')) then
begin
state := 30; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 47; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else if (CurrInputCh = '{') then
begin
state := 48; 
end
else
begin
  sym := _noSym;
exit;
end;
  43: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 30; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 49; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  44: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= '|')) then
begin
state := 35; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 50; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else if (CurrInputCh = '{') then
begin
state := 51; 
end
else
begin
  sym := _noSym;
exit;
end;
  45: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 35; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 52; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  46: if (CurrInputCh = '-') then
begin
state := 1; 
end
else if (CurrInputCh = '[') then
begin
state := 8; 
end
else if (CurrInputCh = ']') then
begin
state := 16; 
end
else
begin
  sym := _noSym;
exit;
end;
  47: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 30; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 53; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  48: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 30; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 54; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  49: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 30; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  50: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 35; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 55; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  51: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 35; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 56; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  52: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 35; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  53: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 30; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 57; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  54: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 30; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 58; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  55: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 35; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 59; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  56: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 35; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 60; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  57: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 30; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  58: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 30; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 61; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  59: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 35; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  60: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 35; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 62; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  61: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 30; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 63; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  62: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 35; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 64; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  63: if ((CurrInputCh = '"')) then
begin
state := 34; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 30; 
end
else if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
  sym := _noSym;
exit;
end;
  64: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 39; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 35; 
end
else if (CurrInputCh = '\') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  65: begin
sym := _backslashSym;
exit;
end;
  66: begin
sym := _slash_equalSym;
exit;
end;
  67: begin
sym := _lparenSym;
exit;
end;
  68: begin
sym := _rparenSym;
exit;
end;
  69: begin
sym := _colonSym;
exit;
end;
  70: begin
sym := _commaSym;
exit;
end;
  71: begin
sym := _lbraceSym;
exit;
end;
  72: begin
sym := _rbraceSym;
exit;
end;
  73: begin
sym := _lbrackSym;
exit;
end;
  74: begin
sym := _rbrackSym;
exit;
end;
  75: if (CurrInputCh = '+') then
begin
state := 76; 
end
else if (CurrInputCh = '=') then
begin
state := 102; 
end
else
begin
sym := _plusSym;
exit;
end;
  76: begin
sym := _plus_plusSym;
exit;
end;
  77: if (CurrInputCh = '-') then
begin
state := 78; 
end
else if (CurrInputCh = '=') then
begin
state := 103; 
end
else
begin
sym := _minusSym;
exit;
end;
  78: begin
sym := _minus_minusSym;
exit;
end;
  79: begin
sym := _tildeSym;
exit;
end;
  80: if (CurrInputCh = '=') then
begin
state := 91; 
end
else
begin
sym := _bangSym;
exit;
end;
  81: if (CurrInputCh = '=') then
begin
state := 100; 
end
else
begin
sym := _starSym;
exit;
end;
  82: if (CurrInputCh = '=') then
begin
state := 101; 
end
else
begin
sym := _percentSym;
exit;
end;
  83: if (CurrInputCh = '=') then
begin
state := 104; 
end
else
begin
sym := _less_lessSym;
exit;
end;
  84: if (CurrInputCh = '>') then
begin
state := 85; 
end
else if (CurrInputCh = '=') then
begin
state := 88; 
end
else
begin
sym := _greaterSym;
exit;
end;
  85: if (CurrInputCh = '>') then
begin
state := 86; 
end
else if (CurrInputCh = '=') then
begin
state := 105; 
end
else
begin
sym := _greater_greaterSym;
exit;
end;
  86: if (CurrInputCh = '=') then
begin
state := 106; 
end
else
begin
sym := _greater_greater_greaterSym;
exit;
end;
  87: begin
sym := _less_equalSym;
exit;
end;
  88: begin
sym := _greater_equalSym;
exit;
end;
  89: if (CurrInputCh = '=') then
begin
state := 90; 
end
else
begin
sym := _equalSym;
exit;
end;
  90: if (CurrInputCh = '=') then
begin
state := 92; 
end
else
begin
sym := _equal_equalSym;
exit;
end;
  91: if (CurrInputCh = '=') then
begin
state := 93; 
end
else
begin
sym := _bang_equalSym;
exit;
end;
  92: begin
sym := _equal_equal_equalSym;
exit;
end;
  93: begin
sym := _bang_equal_equalSym;
exit;
end;
  94: if (CurrInputCh = '|') then
begin
state := 97; 
end
else if (CurrInputCh = '=') then
begin
state := 109; 
end
else
begin
sym := _barSym;
exit;
end;
  95: if (CurrInputCh = '=') then
begin
state := 108; 
end
else
begin
sym := _uparrowSym;
exit;
end;
  96: if (CurrInputCh = '&') then
begin
state := 98; 
end
else if (CurrInputCh = '=') then
begin
state := 107; 
end
else
begin
sym := _andSym;
exit;
end;
  97: begin
sym := _bar_barSym;
exit;
end;
  98: begin
sym := _and_andSym;
exit;
end;
  99: begin
sym := _querySym;
exit;
end;
  100: begin
sym := _star_equalSym;
exit;
end;
  101: begin
sym := _percent_equalSym;
exit;
end;
  102: begin
sym := _plus_equalSym;
exit;
end;
  103: begin
sym := _minus_equalSym;
exit;
end;
  104: begin
sym := _less_less_equalSym;
exit;
end;
  105: begin
sym := _greater_greater_equalSym;
exit;
end;
  106: begin
sym := _greater_greater_greater_equalSym;
exit;
end;
  107: begin
sym := _and_equalSym;
exit;
end;
  108: begin
sym := _uparrow_equalSym;
exit;
end;
  109: begin
sym := _bar_equalSym;
exit;
end;
  110: begin
sym := _semicolonSym;
exit;
end;
  111: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TJScriptGrammarScanner.Create;
begin
  inherited;
CurrentCh := CharAt;
fStartState[  0] := 111; fStartState[  1] := 112; fStartState[  2] := 112; fStartState[  3] := 112; 
fStartState[  4] := 112; fStartState[  5] := 112; fStartState[  6] := 112; fStartState[  7] := 112; 
fStartState[  8] := 112; fStartState[  9] := 112; fStartState[ 10] := 112; fStartState[ 11] := 112; 
fStartState[ 12] := 112; fStartState[ 13] := 112; fStartState[ 14] := 112; fStartState[ 15] := 112; 
fStartState[ 16] := 112; fStartState[ 17] := 112; fStartState[ 18] := 112; fStartState[ 19] := 112; 
fStartState[ 20] := 112; fStartState[ 21] := 112; fStartState[ 22] := 112; fStartState[ 23] := 112; 
fStartState[ 24] := 112; fStartState[ 25] := 112; fStartState[ 26] := 112; fStartState[ 27] := 112; 
fStartState[ 28] := 112; fStartState[ 29] := 112; fStartState[ 30] := 112; fStartState[ 31] := 112; 
fStartState[ 32] := 112; fStartState[ 33] := 80; fStartState[ 34] := 30; fStartState[ 35] := 112; 
fStartState[ 36] := 20; fStartState[ 37] := 82; fStartState[ 38] := 96; fStartState[ 39] := 35; 
fStartState[ 40] := 67; fStartState[ 41] := 68; fStartState[ 42] := 81; fStartState[ 43] := 75; 
fStartState[ 44] := 70; fStartState[ 45] := 77; fStartState[ 46] := 26; fStartState[ 47] :=  3; 
fStartState[ 48] := 41; fStartState[ 49] := 21; fStartState[ 50] := 21; fStartState[ 51] := 21; 
fStartState[ 52] := 21; fStartState[ 53] := 21; fStartState[ 54] := 21; fStartState[ 55] := 21; 
fStartState[ 56] := 21; fStartState[ 57] := 21; fStartState[ 58] := 69; fStartState[ 59] := 110; 
fStartState[ 60] := 40; fStartState[ 61] := 89; fStartState[ 62] := 84; fStartState[ 63] := 99; 
fStartState[ 64] := 112; fStartState[ 65] := 20; fStartState[ 66] := 20; fStartState[ 67] := 20; 
fStartState[ 68] := 20; fStartState[ 69] := 20; fStartState[ 70] := 20; fStartState[ 71] := 20; 
fStartState[ 72] := 20; fStartState[ 73] := 20; fStartState[ 74] := 20; fStartState[ 75] := 20; 
fStartState[ 76] := 20; fStartState[ 77] := 20; fStartState[ 78] := 20; fStartState[ 79] := 20; 
fStartState[ 80] := 20; fStartState[ 81] := 20; fStartState[ 82] := 20; fStartState[ 83] := 20; 
fStartState[ 84] := 20; fStartState[ 85] := 20; fStartState[ 86] := 20; fStartState[ 87] := 20; 
fStartState[ 88] := 20; fStartState[ 89] := 20; fStartState[ 90] := 20; fStartState[ 91] := 73; 
fStartState[ 92] := 65; fStartState[ 93] := 74; fStartState[ 94] := 95; fStartState[ 95] := 20; 
fStartState[ 96] := 112; fStartState[ 97] := 20; fStartState[ 98] := 20; fStartState[ 99] := 20; 
fStartState[100] := 20; fStartState[101] := 20; fStartState[102] := 20; fStartState[103] := 20; 
fStartState[104] := 20; fStartState[105] := 20; fStartState[106] := 20; fStartState[107] := 20; 
fStartState[108] := 20; fStartState[109] := 20; fStartState[110] := 20; fStartState[111] := 20; 
fStartState[112] := 20; fStartState[113] := 20; fStartState[114] := 20; fStartState[115] := 20; 
fStartState[116] := 20; fStartState[117] := 20; fStartState[118] := 20; fStartState[119] := 20; 
fStartState[120] := 20; fStartState[121] := 20; fStartState[122] := 20; fStartState[123] := 71; 
fStartState[124] := 94; fStartState[125] := 72; fStartState[126] := 79; fStartState[127] := 112; 
fStartState[128] := 20; fStartState[129] := 20; fStartState[130] := 20; fStartState[131] := 20; 
fStartState[132] := 20; fStartState[133] := 20; fStartState[134] := 20; fStartState[135] := 20; 
fStartState[136] := 20; fStartState[137] := 20; fStartState[138] := 20; fStartState[139] := 20; 
fStartState[140] := 20; fStartState[141] := 20; fStartState[142] := 20; fStartState[143] := 20; 
fStartState[144] := 20; fStartState[145] := 20; fStartState[146] := 20; fStartState[147] := 20; 
fStartState[148] := 20; fStartState[149] := 20; fStartState[150] := 20; fStartState[151] := 20; 
fStartState[152] := 20; fStartState[153] := 20; fStartState[154] := 20; fStartState[155] := 20; 
fStartState[156] := 20; fStartState[157] := 20; fStartState[158] := 20; fStartState[159] := 20; 
fStartState[160] := 20; fStartState[161] := 20; fStartState[162] := 20; fStartState[163] := 20; 
fStartState[164] := 20; fStartState[165] := 20; fStartState[166] := 20; fStartState[167] := 20; 
fStartState[168] := 20; fStartState[169] := 20; fStartState[170] := 20; fStartState[171] := 20; 
fStartState[172] := 20; fStartState[173] := 20; fStartState[174] := 20; fStartState[175] := 20; 
fStartState[176] := 20; fStartState[177] := 20; fStartState[178] := 20; fStartState[179] := 20; 
fStartState[180] := 20; fStartState[181] := 20; fStartState[182] := 20; fStartState[183] := 20; 
fStartState[184] := 20; fStartState[185] := 20; fStartState[186] := 20; fStartState[187] := 20; 
fStartState[188] := 20; fStartState[189] := 20; fStartState[190] := 20; fStartState[191] := 20; 
fStartState[192] := 20; fStartState[193] := 20; fStartState[194] := 20; fStartState[195] := 20; 
fStartState[196] := 20; fStartState[197] := 20; fStartState[198] := 20; fStartState[199] := 20; 
fStartState[200] := 20; fStartState[201] := 20; fStartState[202] := 20; fStartState[203] := 20; 
fStartState[204] := 20; fStartState[205] := 20; fStartState[206] := 20; fStartState[207] := 20; 
fStartState[208] := 20; fStartState[209] := 20; fStartState[210] := 20; fStartState[211] := 20; 
fStartState[212] := 20; fStartState[213] := 20; fStartState[214] := 20; fStartState[215] := 20; 
fStartState[216] := 20; fStartState[217] := 20; fStartState[218] := 20; fStartState[219] := 20; 
fStartState[220] := 20; fStartState[221] := 20; fStartState[222] := 20; fStartState[223] := 20; 
fStartState[224] := 20; fStartState[225] := 20; fStartState[226] := 20; fStartState[227] := 20; 
fStartState[228] := 20; fStartState[229] := 20; fStartState[230] := 20; fStartState[231] := 20; 
fStartState[232] := 20; fStartState[233] := 20; fStartState[234] := 20; fStartState[235] := 20; 
fStartState[236] := 20; fStartState[237] := 20; fStartState[238] := 20; fStartState[239] := 20; 
fStartState[240] := 20; fStartState[241] := 20; fStartState[242] := 20; fStartState[243] := 20; 
fStartState[244] := 20; fStartState[245] := 20; fStartState[246] := 20; fStartState[247] := 20; 
fStartState[248] := 20; fStartState[249] := 20; fStartState[250] := 20; fStartState[251] := 20; 
fStartState[252] := 20; fStartState[253] := 20; fStartState[254] := 20; fStartState[255] := 20; 
end; {Create}


{ --------------------------------------------------------------------------- }
{ ---- implementation for TJScriptGrammar ---- }

constructor TJScriptGrammar.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TJScriptGrammarScanner.Create;
  GetScanner.Owner := self;
FParseTracker := TTracker.Create;
{$IFDEF DEBUG_TOKENS}
    AfterGet := DebugLogToken;
{$ENDIF}
    FLangStr := 'JScript';

  InitSymSet;
end; {Create}

destructor TJScriptGrammar.Destroy;
begin
  Scanner.Free;
FParseTracker.Free;

  inherited;
end; {Destroy}

function TJScriptGrammar.ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'HtmlEncapsulation1 expected';
   2 : Result := 'HtmlEncapsulation2 expected';
   3 : Result := 'HtmlEncapsulation3 expected';
   4 : Result := 'HtmlEncapsulation4 expected';
   5 : Result := '_Identifier expected';
   6 : Result := '_Number expected';
   7 : Result := 'DQuotString expected';
   8 : Result := 'SQuotString expected';
   9 : Result := '"\" expected';
  10 : Result := '"/" expected';
  11 : Result := '"/=" expected';
  12 : Result := '"this" expected';
  13 : Result := '"null" expected';
  14 : Result := '"false" expected';
  15 : Result := '"true" expected';
  16 : Result := '"(" expected';
  17 : Result := '")" expected';
  18 : Result := '"function" expected';
  19 : Result := '"return" expected';
  20 : Result := '"default" expected';
  21 : Result := '"catch" expected';
  22 : Result := '"delete" expected';
  23 : Result := '"then" expected';
  24 : Result := '"for" expected';
  25 : Result := '":" expected';
  26 : Result := '"," expected';
  27 : Result := '"{" expected';
  28 : Result := '"}" expected';
  29 : Result := '"[" expected';
  30 : Result := '"]" expected';
  31 : Result := '"." expected';
  32 : Result := '"new" expected';
  33 : Result := '"++" expected';
  34 : Result := '"--" expected';
  35 : Result := '"void" expected';
  36 : Result := '"typeof" expected';
  37 : Result := '"+" expected';
  38 : Result := '"-" expected';
  39 : Result := '"~" expected';
  40 : Result := '"!" expected';
  41 : Result := '"*" expected';
  42 : Result := '"%" expected';
  43 : Result := '"<<" expected';
  44 : Result := '">>" expected';
  45 : Result := '">>>" expected';
  46 : Result := '"<" expected';
  47 : Result := '">" expected';
  48 : Result := '"<=" expected';
  49 : Result := '">=" expected';
  50 : Result := '"instanceof" expected';
  51 : Result := '"in" expected';
  52 : Result := '"==" expected';
  53 : Result := '"!=" expected';
  54 : Result := '"===" expected';
  55 : Result := '"!==" expected';
  56 : Result := '"|" expected';
  57 : Result := '"^" expected';
  58 : Result := '"&" expected';
  59 : Result := '"||" expected';
  60 : Result := '"&&" expected';
  61 : Result := '"?" expected';
  62 : Result := '"*=" expected';
  63 : Result := '"%=" expected';
  64 : Result := '"+=" expected';
  65 : Result := '"-=" expected';
  66 : Result := '"<<=" expected';
  67 : Result := '">>=" expected';
  68 : Result := '">>>=" expected';
  69 : Result := '"&=" expected';
  70 : Result := '"^=" expected';
  71 : Result := '"|=" expected';
  72 : Result := '"=" expected';
  73 : Result := '"finally" expected';
  74 : Result := '"try" expected';
  75 : Result := '"throw" expected';
  76 : Result := '"break" expected';
  77 : Result := '"continue" expected';
  78 : Result := '"with" expected';
  79 : Result := '"var" expected';
  80 : Result := '";" expected';
  81 : Result := '"while" expected';
  82 : Result := '"do" expected';
  83 : Result := '"case" expected';
  84 : Result := '"switch" expected';
  85 : Result := '"if" expected';
  86 : Result := '"else" expected';
  87 : Result := 'not expected';
  88 : Result := 'invalid Javascript program';
  89 : Result := 'invalid HtmlEncapsulateTag';
  90 : Result := 'invalid Top level statement';
  91 : Result := 'invalid Case guard';
  92 : Result := 'invalid Statement';
  93 : Result := 'invalid Compound assignment';
  94 : Result := 'invalid Unary expression';
  95 : Result := 'invalid Unary expression';
  96 : Result := 'invalid Left side expression';
  97 : Result := 'invalid Left side expression';
  98 : Result := 'invalid Call expression';
  99 : Result := 'invalid Call expression';
 100 : Result := 'invalid Full new subexpression';
 101 : Result := 'invalid Member operator';
 102 : Result := 'invalid Member operator';
 103 : Result := 'invalid Literal field';
 104 : Result := 'invalid Function expression';
 105 : Result := 'invalid Simple expression';
 106 : Result := 'invalid Primary expression';
 107 : Result := 'invalid String literal';
 108 : Result := 'invalid Regular expression literal';

1000: Result := 'Expected an L value on the left of an assignment expression';
    1001: Result := 'Expected an L value on the left side of the in operator';
    1002: Result := 'Cannot have for loop iterators after for-in binding';
    1003: Result := 'Cannot have multiple variable declarations before for-in binding';
    1004: Result := 'Label expression must be a bare identifier.';
    1005: Result := 'Try statement should be followed by catch / finally.';
    1006: Result := 'functions should only be defined at top level in other functions';
    1007: Result := 'found HTML encapsulation in Javascript, ignored.';
    1008: Result := '"default" used as identifier.';
    1009: Result := '"catch" used as identifier.';
    1010: Result := '"return"used as an identifier.';
    1011: Result := 'switch statement has duplicate labels.';
    1012: Result := 'Unable to continue after previous errors, aborting.';
    1013: Result := '"delete"used as an identifier.';
    1014: Result := '"then"used as an identifier.';
    1015: Result := '"for"used as an identifier.';
    1016: Result := '"return"used as object literal field.';
    1017: Result := '"default" used as object literal field.';
    1018: Result := '"catch" used as object literal field.';
    1019: Result := '"delete"used as an object literal field.';
    1020: Result := '"then"used as an object literal field.';
    1021: Result := '"for"used as an object literal field.';
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := AnsiString('Error: ' + AnsiString(IntToStr(ErrorCode)));
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TJScriptGrammar.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;
  StreamPartRead := -1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TJScriptGrammar.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TJScriptGrammar.GetScanner : TJScriptGrammarScanner;
begin
  Result := Scanner AS TJScriptGrammarScanner;
end; {GetScanner}

function TJScriptGrammar._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TJScriptGrammar._JScriptGrammar;var  Stmts:  TJSBlock;
     Sc:  TJScriptGrammarScanner;

begin
FParseResult  :=  TJSScript.CreateWithTracker(FParseTracker  as  TTracker);
_HtmlEncapsulation;
_TopStatements(Stmts);
//Only  insert  Statements  block  if  it  contains  some
//statements,  so  that  we  can  relibably  detect  the  NULL  document.
if  not  DLItemIsEmpty(@Stmts.ContainedListHead)  then
   InsertStmtTail((FParseResult  as  TJSScript),  Stmts)
else
   Stmts.Free;  //FParseResult  has  no  children.

_HtmlEncapsulation;
if (fCurrentInputSymbol = _lessSym) then begin
Get;
//Trailing  HTML  in  inline  script:  </script>
Sc  :=  (Scanner  as  TJScriptGrammarScanner);
StreamPartRead  :=  Sc.BufferPosition;

end else if (fCurrentInputSymbol = EOFSYMB) then begin
Get;
end else begin SynError(88);
end;
end;

procedure TJScriptGrammar._HtmlEncapsulation;begin
while (fCurrentInputSymbol = HtmlEncapsulation1Sym) OR
 (fCurrentInputSymbol = HtmlEncapsulation2Sym) OR
 (fCurrentInputSymbol = HtmlEncapsulation3Sym) OR
 (fCurrentInputSymbol = HtmlEncapsulation4Sym) do begin
_HtmlEncapsulateTag;
ParseWarning(1007,  '');
end;
end;

procedure TJScriptGrammar._HtmlEncapsulateTag;begin
if (fCurrentInputSymbol = HtmlEncapsulation1Sym) then begin
Get;
end else if (fCurrentInputSymbol = HtmlEncapsulation2Sym) then begin
Get;
end else if (fCurrentInputSymbol = HtmlEncapsulation3Sym) then begin
Get;
end else if (fCurrentInputSymbol = HtmlEncapsulation4Sym) then begin
Get;
end else begin SynError(89);
end;
end;

procedure TJScriptGrammar._TopStatement (out  S:TJSStatement);begin
S  :=  nil;
if (fCurrentInputSymbol = functionSym) then begin
_FunctionDefinition(S);
end else if _In(symSet[1], fCurrentInputSymbol) then begin
_Statement_Full(S);
end else begin SynError(90);
end;
end;

procedure TJScriptGrammar._TopStatements (out  B:  TJSBlock);var  S:  TJSStatement;
begin
B  :=  TJSBlock.CreateWithTracker(FParseTracker  as  TTracker);
B.BlockType  :=  btTopOrFunction;

while _In(symSet[1], fCurrentInputSymbol) do begin
_TopStatement(S);
InsertStmtTail(B,  S);
end;
end;

procedure TJScriptGrammar._FormalParametersAndBody (var  F:TJSFunction);var  P:  TJSExprList;  var  B:  TJSBlock;
begin
Expect(_lparenSym);
_FormalParameters(P);
InsertExprListTail(F,  P);
Expect(_rparenSym);
Expect(_lbraceSym);
_TopStatements(B);
InsertStmtTail(F,  B,  false);
B.BlockType  :=  btTopOrFunction;
Expect(_rbraceSym);
end;

procedure TJScriptGrammar._FormalParameters (out  P:TJSExprList);var  E:  TJSExpr;
begin
P  :=  TJSExprList.CreateWithTracker(FParseTracker  as  TTracker);
P.ListType  :=  eltFormalParameters;
if (fCurrentInputSymbol = _IdentifierSym) then begin
_FormalParameter(E);
InsertExprTail(P,  E);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_FormalParameter(E);
InsertExprTail(P,  E);
end;
end;
end;

procedure TJScriptGrammar._FormalParameter (out  E:TJSExpr);var  I:  TJSIdentifier;
begin
_Identifier(I);
E  :=  I;
end;

procedure TJScriptGrammar._FunctionDefinition (out  F:TJSStatement);var  FD:  TJSFunction;
begin
Expect(functionSym);
_NamedFunctionDecl(FD);
F  :=  FD;
end;

procedure TJScriptGrammar._EmptyStatement (out  S:  TJSStatement);begin
Expect(_semicolonSym);
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stEmpty;
end;

procedure TJScriptGrammar._OptionalSemicolon;begin
if (fCurrentInputSymbol = _semicolonSym) then begin
Get;
end;
end;

procedure TJScriptGrammar._ExpressionOrLabelStatement_Full (out  S:TJSStatement);var  LVALStart:  boolean;  E:  TJSExpr;  S2:TJSStatement;
begin
LValStart  :=  true;
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stExpressionStatement;

_Expression_Initial_AllowIn(E,  LVALStart);
InsertExprTail(S,  E);
if (fCurrentInputSymbol = _colonSym) then begin
Get;
S.StatType  :=  stLabelStatement;
if  not  (E  is  TJSIdentifier)  then  SynError(1004);
_Statement_Full(S2);
InsertStmtTail(S,  S2,  false);
end;
end;

procedure TJScriptGrammar._VariableDefinition (out  S:TJSStatement);var  EL:  TJSExprList;
begin
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stVarDeclStatement;

Expect(varSym);
_VariableDeclarationList_AllowIn(EL);
InsertExprListTail(S,  EL);
end;

procedure TJScriptGrammar._VariableDeclarationList_AllowIn (out  EL:  TJSExprList);var  VD:TJSExpr;
begin
EL  :=  TJSExprList.CreateWithTracker(FParseTracker  as  TTracker);
EL.ListType  :=  eltVarDecls;
_VariableDeclaration_AllowIn(VD);
InsertExprTail(EL,  VD);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_VariableDeclaration_AllowIn(VD);
InsertExprTail(EL,  VD);
end;
end;

procedure TJScriptGrammar._VariableDeclaration_NoIn (out  VD:  TJSExpr);var  I:  TJSIdentifier;  Init:  TJSExpr;
begin
VD  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
VD.ExprType  :=  etVarDecl;
_Identifier(I);
InsertExprTail(VD,  I);
_VariableInitializer_NoIn(Init);
if  Assigned(Init)  then
   InsertExprTail(VD,  Init);
end;

procedure TJScriptGrammar._VariableDeclaration_AllowIn (out  VD:  TJSExpr);var  I:  TJSIdentifier;  Init:  TJSExpr;
begin
VD  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
VD.ExprType  :=  etVarDecl;
_Identifier(I);
InsertExprTail(VD,  I);
_VariableInitializer_AllowIn(Init);
if  Assigned(Init)  then
   InsertExprTail(VD,  Init);
end;

procedure TJScriptGrammar._VariableInitializer_NoIn (out  Init:  TJSExpr);var  LVALStart:  boolean;
begin
LValStart  :=  true;  Init  :=  nil;
if (fCurrentInputSymbol = _equalSym) then begin
Get;
_AssignmentExpression_Normal_NoIn(Init,  LVALStart);
end;
end;

procedure TJScriptGrammar._VariableInitializer_AllowIn (out  Init:  TJSExpr);var  LVALStart:  boolean;
begin
LValStart  :=  true;  Init  :=  nil;
if (fCurrentInputSymbol = _equalSym) then begin
Get;
_AssignmentExpression_Normal_AllowIn(Init,  LVALStart);
end;
end;

procedure TJScriptGrammar._IfStatement_Full (out  S:TJSStatement);var  LVALStart:  boolean;
     E:  TJsExpr;
     IfStmt:  TJSStatement;
     ElseStmt:  TJSStatement;

begin
LValStart  :=  true;
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stIfStatement;

Expect(ifSym);
_ParenthesizedExpression(E,  LVALStart);
InsertExprTail(S,  E);
_Statement_Full(IfStmt);
InsertStmtTail(S,  IfStmt,  false);
if (fCurrentInputSymbol = elseSym) then begin
Get;
_Statement_Full(ElseStmt);
InsertStmtTail(S,  ElseStmt,  false);
end;
end;

procedure TJScriptGrammar._SwitchStatement (out  S:  TJSStatement);var  LVALStart:  boolean;  E:  TJSExpr;

begin
LValStart  :=  true;
S  :=  TJSSwitchStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stSwitchStatement;

Expect(switchSym);
_ParenthesizedExpression(E,  LVALStart);
InsertExprTail(S,  E);
Expect(_lbraceSym);
_CaseGroups(S);
Expect(_rbraceSym);
end;

procedure TJScriptGrammar._CaseGroups (var  S:  TJSStatement);var  CG:  TJSTagGroup;
begin
while (fCurrentInputSymbol = defaultSym) OR
 (fCurrentInputSymbol = caseSym) do begin
_CaseGroup(CG);
InsertTagGroupTail(S,  CG,  false);
end;
if  not  (S  as  TJSSwitchStatement).CheckNoDupDefaults  then
   SynError(1011);

end;

procedure TJScriptGrammar._BlockStatements (out  B:  TJSBlock);var  S:  TJSStatement;
begin
B  :=  TJSBlock.CreateWithTracker(FParseTracker  as  TTracker);

while _In(symSet[1], fCurrentInputSymbol) do begin
_Statement_Full(S);
InsertStmtTail(B,  S);
end;
end;

procedure TJScriptGrammar._CaseGroup (out  CG:  TJSTagGroup);var  B:  TJSBlock;
begin
CG  :=  TJSTagGroup.CreateWithTracker(FParseTracker  as  TTracker);
CG.TagGroupType  :=  ttgCaseGroup;
_CaseGuards(CG);
_BlockStatements(B);
B.BlockType  :=  btCaseGroup;
InsertStmtTail(CG,  B,  false);
end;

procedure TJScriptGrammar._CaseGuards (var  CG:  TJSTagGroup);var  GuardExpr:  TJSExpr;
begin
_CaseGuard(GuardExpr);
InsertExprTail(CG,  GuardExpr);
while (fCurrentInputSymbol = defaultSym) OR
 (fCurrentInputSymbol = caseSym) do begin
_CaseGuard(GuardExpr);
InsertExprTail(CG,  GuardExpr);
end;
end;

procedure TJScriptGrammar._CaseGuard (out  G:  TJSExpr);var  LVALStart:  boolean;
begin
LValStart  :=  true;
G  :=  nil;
if (fCurrentInputSymbol = caseSym) then begin
Get;
_Expression_Normal_AllowIn(G,  LVALStart);
end else if (fCurrentInputSymbol = defaultSym) then begin
Get;
G  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
G.ExprType  :=  etDefaultCase;
end else begin SynError(91);
end;
Expect(_colonSym);
end;

procedure TJScriptGrammar._DoStatement (out  S:  TJSStatement);var  LVALStart:  boolean;  E:  TJSExpr;  SRep:  TJSStatement;
begin
LValStart  :=  true;
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stDoStatement;

Expect(doSym);
_Statement_Full(SRep);
Expect(whileSym);
_ParenthesizedExpression(E,  LVALStart);

InsertExprTail(S,  E);
InsertStmtTail(S,SRep,  false);

end;

procedure TJScriptGrammar._WhileStatement_Full (out  S:  TJSStatement);var  LVALStart:  boolean;  E:  TJSExpr;  SRep:  TJSStatement;
begin
LValStart  :=  true;
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stWhileStatement;

Expect(whileSym);
_ParenthesizedExpression(E,  LVALStart);
_Statement_Full(SRep);

InsertExprTail(S,  E);
InsertStmtTail(S,  SRep,  false);

end;

procedure TJScriptGrammar._ForStatement_Full (out  S:  TJSStatement);var  HasInBinding:  boolean;
     E:  TJSExpr;
     EList:  TJSExprList;
     SBody:  TJSStatement;

begin

  S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
  S.StatType  :=  stForStatement;
  EList  :=  TJsExprList.CreateWithTracker(FParseTracker  as  TTracker);
  EList.ListType  :=  eltForInitializers;
  InsertExprListTail(S,  EList);

Expect(forSym);
Expect(_lparenSym);
_ForPossibleInitializers(E,  HasInBinding);
InsertExprTail(EList,  E);
if (fCurrentInputSymbol = _semicolonSym) then begin
Get;
if  HasInBinding  then
   SynError(1002);
_OptionalExpression(E);
if  Assigned(E)  then
  InsertExprTail(EList,  E)
else
begin
   E  :=  TJSSimpleExpr.CreateWithTracker(FParseTracker  as  TTracker);
   E.ExprType  :=  etSimpleExpression;
   (E  as  TJSSimpleExpr).SimpleExprType  :=  setNull;
   InsertExprTail(EList,  E);
end;
Expect(_semicolonSym);
_OptionalExpression(E);
if  Assigned(E)  then
   InsertExprTail(EList,  E)
else
begin
   E  :=  TJSSimpleExpr.CreateWithTracker(FParseTracker  as  TTracker);
   E.ExprType  :=  etSimpleExpression;
   (E  as  TJSSimpleExpr).SimpleExprType  :=  setNull;
   InsertExprTail(EList,  E);
end;
end;
Expect(_rparenSym);
_Statement_Full(SBody);
InsertStmtTail(S,  SBody,  false);
end;

procedure TJScriptGrammar._VariableDeclarationList_NoIn (out  EL:  TJSExprList;  var  JustOne:  boolean);var  VD:TJSExpr;
begin
EL  :=  TJSExprList.CreateWithTracker(FParseTracker  as  TTracker);
EL.ListType  :=  eltVarDecls;
JustOne  :=  true;
_VariableDeclaration_NoIn(VD);
InsertExprTail(EL,  VD);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
JustOne  :=  false;
_VariableDeclaration_NoIn(VD);
InsertExprTail(EL,  VD);
end;
end;

procedure TJScriptGrammar._ForPossibleInitializers (out  E:  TJSExpr;  var  HasInBinding:  boolean);var  LVALStart,JustOne:  boolean;
var  E2,  E3:  TJSExpr;
var  VVList:  TJSExprList;
begin
LValStart  :=  true;
HasInBinding  :=  false;
E  :=  nil;

if _In(symSet[2], fCurrentInputSymbol) then begin
if _In(symSet[3], fCurrentInputSymbol) then begin
_Expression_Normal_NoIn(E2,  LVALStart);
if (fCurrentInputSymbol = inSym) then begin
Get;
if  not  LVALStart  then  SynError(1001);
HasInBinding  :=  true;
LValStart  :=  true;
_Expression_Normal_AllowIn(E3,  LVALStart);

  E  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
  E.ExprType  :=  etInOperator;
  InsertExprTail(E,  E2);
  InsertExprTail(E,  E3);

end;
if  not  Assigned(E)  then  E  :=  E2;
end else begin
Get;
_VariableDeclarationList_NoIn(VVList,  JustOne);
if (fCurrentInputSymbol = inSym) then begin
Get;
if  not  JustOne  then  SynError(1003);
HasInBinding  :=  true;
LValStart  :=  true;

//Pluck  var  decl  out  of  list,  and  dispose  of  list.
E2  :=  RemoveExprHead(VVList);
VVList.Free;
VVList  :=  nil;

_Expression_Normal_AllowIn(E3,  LValStart);
E  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E.ExprType  :=  etVarInDecl;
InsertExprTail(E,  E2);
InsertExprTail(E,  E3);

end;
if  not  Assigned(E)  then
begin
  E  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
  E.ExprType  :=  etVarDecl;
  InsertExprListTail(E,  VVList);
end;

end;
end;

  if  not  Assigned(E)  then
  begin
    E  :=  TJSSimpleExpr.CreateWithTracker(FParseTracker  as  TTracker);
    E.ExprType  :=  etSimpleExpression;
    (E  as  TJSSimpleExpr).SimpleExprType  :=  setNull;
  end;

end;

procedure TJScriptGrammar._Statement_Full (out  S:TJSStatement);var  B:  TJSBlock;
begin
S  :=  nil;
case fCurrentInputSymbol of
  _semicolonSym : begin
_EmptyStatement(S);
    end;
  _IdentifierSym, _NumberSym, DQuotStringSym, SQuotStringSym, _slashSym, _slash_equalSym, thisSym, 
      nullSym, falseSym, trueSym, _lparenSym, deleteSym, _lbrackSym, newSym, _plus_plusSym, 
      _minus_minusSym, voidSym, typeofSym, _plusSym, _minusSym, _tildeSym, _bangSym : begin
_ExpressionOrLabelStatement_Full(S);
_OptionalSemicolon;
    end;
  varSym : begin
_VariableDefinition(S);
_OptionalSemicolon;
    end;
  _lbraceSym : begin
_Block(B);
S  :=  B;
    end;
  ifSym : begin
_IfStatement_Full(S);
    end;
  switchSym : begin
_SwitchStatement(S);
    end;
  doSym : begin
_DoStatement(S);
_OptionalSemicolon;
    end;
  whileSym : begin
_WhileStatement_Full(S);
    end;
  forSym : begin
_ForStatement_Full(S);
    end;
  withSym : begin
_WithStatement_Full(S);
    end;
  continueSym : begin
_ContinueStatement(S);
_OptionalSemicolon;
    end;
  breakSym : begin
_BreakStatement(S);
_OptionalSemicolon;
    end;
  returnSym : begin
_ReturnStatement(S);
_OptionalSemicolon;
    end;
  throwSym : begin
_ThrowStatement(S);
_OptionalSemicolon;
    end;
  trySym : begin
_TryStatement(S);
    end;
  functionSym : begin
_FunctionDefinition(S);
ParseWarning(1006,  '');
    end;
else begin SynError(92);
    end;
end;
end;

procedure TJScriptGrammar._WithStatement_Full (out  S:TJSStatement);var  LVALStart:  boolean;
     E:  TJSExpr;
     SSub:  TJSStatement;
begin
LValStart  :=  true;
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stWithStatement;

Expect(withSym);
_ParenthesizedExpression(E,  LVALStart);
InsertExprTail(S,E);
_Statement_Full(SSub);
InsertStmtTail(S,  SSub,  false);
end;

procedure TJScriptGrammar._ContinueStatement (out  S:TJSStatement);var  I:TJSIdentifier;
begin
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stContinueStatement;

Expect(continueSym);
_OptionalLabel(I);
if  Assigned(I)  then
   InsertExprTail(S,  I);

end;

procedure TJScriptGrammar._BreakStatement (out  S:TJSStatement);var  I:TJSIdentifier;
begin
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stBreakStatement;

Expect(breakSym);
_OptionalLabel(I);
if  Assigned(I)  then
   InsertExprTail(S,  I);

end;

procedure TJScriptGrammar._OptionalLabel (out  I:  TJSIdentifier);begin
I  :=  nil;
if (fCurrentInputSymbol = _IdentifierSym) then begin
_Identifier(I);
end;
end;

procedure TJScriptGrammar._ReturnStatement (out  S:TJSStatement);var  E:TJSExpr;
begin
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stReturnStatement;

Expect(returnSym);
_OptionalExpression(E);
if  Assigned(E)  then
   InsertExprTail(S,E);

end;

procedure TJScriptGrammar._ThrowStatement (out  S:TJSStatement);var  LVALStart:  boolean;
     E:  TJSExpr;

begin
LValStart  :=  true;
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stThrowStatement;

Expect(throwSym);
_Expression_Normal_AllowIn(E,  LVALStart);
InsertExprTail(S,  E);
end;

procedure TJScriptGrammar._TryStatement (out  S:TJSStatement);var  ClauseCount:  integer;
     B:  TJSBlock;
     CC:  TJSTagGroup;

begin
ClauseCount  :=  0;
S  :=  TJSStatement.CreateWithTracker(FParseTracker  as  TTracker);
S.StatType  :=  stThrowStatement;

Expect(trySym);
_Block(B);
B.BlockType  :=  btTry;
InsertStmtTail(S,B);

while (fCurrentInputSymbol = catchSym) do begin
_CatchClause(CC);
Inc(ClauseCount);
InsertTagGroupTail(S,  CC,  false);

end;
if (fCurrentInputSymbol = finallySym) then begin
_FinallyClause(B);
Inc(ClauseCount);
InsertStmtTail(S,  B,  false);

end;
if  ClauseCount  =  0  then  ParseWarning(1005,  '');
end;

procedure TJScriptGrammar._CatchClause (out  CC:  TJSTagGroup);var  E:  TJSIdentifier;  B:TJSBlock;
begin
CC  :=  TJSTagGroup.CreateWithTracker(FParseTracker  as  TTracker);
CC.TagGroupType  :=  ttgCatchBlock;
Expect(catchSym);
Expect(_lparenSym);
_Identifier(E);
InsertExprTail(CC,  E);
Expect(_rparenSym);
_Block(B);
B.BlockType  :=  btCatch;
InsertStmtTail(CC,  B,  false);
end;

procedure TJScriptGrammar._Block (out  B:  TJSBlock);begin
Expect(_lbraceSym);
_BlockStatements(B);
B.BlockType  :=  btExplicit;
Expect(_rbraceSym);
end;

procedure TJScriptGrammar._FinallyClause (out  B:  TJSBlock);begin
Expect(finallySym);
_Block(B);
B.BlockType  :=  btFinally
end;

procedure TJScriptGrammar._Expression_Initial_AllowIn (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  SubLVal:  boolean;  E2,  E3:  TJSExpr;
begin
_AssignmentExpression_Initial_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
SubLVal  :=  true;
_AssignmentExpression_Normal_AllowIn(E2,  SubLVal);

  IsLVAL  :=  false;
  E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
  E3.ExprType  :=  etCommaOperator;
  InsertExprTail(E3,E);
  InsertExprTail(E3,E2);
  E  :=  E3;

end;
end;

procedure TJScriptGrammar._Expression_Normal_NoIn (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  SubLVal:  boolean;  E2,  E3:  TJSExpr;
begin
_AssignmentExpression_Normal_NoIn(E,  IsLVAL);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
SubLVal  :=  true;
_AssignmentExpression_Normal_NoIn(E2,  SubLVal);

   IsLVAL  :=  false;
   E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
   E3.ExprType  :=  etCommaOperator;
   InsertExprTail(E3,E);
   InsertExprTail(E3,E2);
   E  :=  E3;

end;
end;

procedure TJScriptGrammar._OptionalExpression (out  E:  TJSExpr);var  LVALStart:  boolean;
begin
LValStart  :=  true;
E  :=  nil;

if _In(symSet[3], fCurrentInputSymbol) then begin
_Expression_Normal_AllowIn(E,  LVALStart);
end;
end;

procedure TJScriptGrammar._AssignmentExpression_Initial_AllowIn (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
     MS:  TJSMultiAssign;
begin
_ConditionalExpression_Initial_AllowIn(E,  IsLVAL);
if _In(symSet[4], fCurrentInputSymbol) then begin
if _In(symSet[5], fCurrentInputSymbol) then begin
_CompoundAssignment(MS);
E1  :=  MS;
end else begin
Get;
E1  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E1.ExprType  :=  etAssignOperator;
end;
if  not  IsLVAL  then  SynError(1000);
_AssignmentExpression_Normal_AllowIn(E2,IsLVAL);
InsertExprTail(E1,E);
InsertExprTail(E1,E2);
E  :=  E1;

end;
end;

procedure TJScriptGrammar._CompoundAssignment (out  E:TJSMultiAssign);begin
E  :=  TJSMultiAssign.CreateWithTracker(FParseTracker  as  TTracker);
case fCurrentInputSymbol of
  _star_equalSym : begin
Get;
E.AssignmentType  :=  atMulAssign;
    end;
  _slash_equalSym : begin
Get;
E.AssignmentType  :=  atDivAssign;
    end;
  _percent_equalSym : begin
Get;
E.AssignmentType  :=  atModAssign;
    end;
  _plus_equalSym : begin
Get;
E.AssignmentType  :=  atAddAssign;
    end;
  _minus_equalSym : begin
Get;
E.AssignmentType  :=  atSubAssign;
    end;
  _less_less_equalSym : begin
Get;
E.AssignmentType  :=  atShlAssign;
    end;
  _greater_greater_equalSym : begin
Get;
E.AssignmentType  :=  atShrAssign;
    end;
  _greater_greater_greater_equalSym : begin
Get;
E.AssignmentType  :=  atUnsShrAssign;
    end;
  _and_equalSym : begin
Get;
E.AssignmentType  :=  atBitAndAssign;
    end;
  _uparrow_equalSym : begin
Get;
E.AssignmentType  :=  atBitXorAssign;
    end;
  _bar_equalSym : begin
Get;
E.AssignmentType  :=  atBitOrAssign;
    end;
else begin SynError(93);
    end;
end;
end;

procedure TJScriptGrammar._ConditionalExpression_Initial_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  LVAL1,  LVAL2:  boolean;  E1,  E2,  E3:  TJSExpr;
begin
_LogicalOrExpression_Initial_AllowIn(E,  IsLVAL);
if (fCurrentInputSymbol = _querySym) then begin
Get;
LVAL1  :=  true;
_AssignmentExpression_Normal_AllowIn(E1,  LVAL1);
Expect(_colonSym);
LVAL2  :=  true;
_AssignmentExpression_Normal_AllowIn(E2,  LVAL2);
IsLVAL  :=  LVAL1  and  LVAL2;
E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E3.ExprType  :=  etConditionalOperator;
InsertExprTail(E3,E);
InsertExprTail(E3,E1);
InsertExprTail(E3,E2);
E  :=  E3;

end;
end;

procedure TJScriptGrammar._ConditionalExpression_Normal_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  LVAL1,  LVAL2:  boolean;  E1,  E2,  E3:  TJSExpr;
begin
_LogicalOrExpression_Normal_AllowIn(E,  IsLVAL);
if (fCurrentInputSymbol = _querySym) then begin
Get;
LVAL1  :=  true;
_AssignmentExpression_Normal_AllowIn(E1,  LVAL1);
Expect(_colonSym);
LVAL2  :=  true;
_AssignmentExpression_Normal_AllowIn(E2,  LVAL2);
IsLVAL  :=  LVAL1  and  LVAL2;
E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E3.ExprType  :=  etConditionalOperator;
InsertExprTail(E3,E);
InsertExprTail(E3,E1);
InsertExprTail(E3,E2);
E  :=  E3;

end;
end;

procedure TJScriptGrammar._AssignmentExpression_Normal_NoIn (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
     MS:  TJSMultiAssign;
begin
_ConditionalExpression_Normal_NoIn(E,  IsLVAL);
if _In(symSet[4], fCurrentInputSymbol) then begin
if _In(symSet[5], fCurrentInputSymbol) then begin
_CompoundAssignment(MS);
E1  :=  MS;
end else begin
Get;
E1  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E1.ExprType  :=  etAssignOperator;
end;
if  not  IsLVAL  then  SynError(1000);
_AssignmentExpression_Normal_NoIn(E2,  IsLVAL);
InsertExprTail(E1,E);
InsertExprTail(E1,E2);
E  :=  E1;

end;
end;

procedure TJScriptGrammar._ConditionalExpression_Normal_NoIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  LVAL1,  LVAL2:  boolean;  E1,  E2,  E3:  TJSExpr;
begin
_LogicalOrExpression_Normal_NoIn(E,  IsLVAL);
if (fCurrentInputSymbol = _querySym) then begin
Get;
LVAL1  :=  true;
_AssignmentExpression_Normal_NoIn(E1,  LVAL1);
Expect(_colonSym);
LVAL2  :=  true;
_AssignmentExpression_Normal_NoIn(E2,LVAL2);
IsLVAL  :=  LVAL1  and  LVAL2;
E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E3.ExprType  :=  etConditionalOperator;
InsertExprTail(E3,E);
InsertExprTail(E3,E1);
InsertExprTail(E3,E2);
E  :=  E3;

end;
end;

procedure TJScriptGrammar._LogicalAndExpression_Initial_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseOrExpression_Initial_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _and_andSym) do begin
Get;
_BitwiseOrExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSLogicalOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etLogicalOperator;
(E2  as  TJSLogicalOperator).LogicalType  :=  otAnd;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._LogicalOrExpression_Initial_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_LogicalAndExpression_Initial_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _bar_barSym) do begin
Get;
_LogicalAndExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSLogicalOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etLogicalOperator;
(E2  as  TJSLogicalOperator).LogicalType  :=  otOr;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._LogicalAndExpression_Normal_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseOrExpression_Normal_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _and_andSym) do begin
Get;
_BitwiseOrExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSLogicalOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etLogicalOperator;
(E2  as  TJSLogicalOperator).LogicalType  :=  otAnd;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._LogicalOrExpression_Normal_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_LogicalAndExpression_Normal_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _bar_barSym) do begin
Get;
_LogicalAndExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSLogicalOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etLogicalOperator;
(E2  as  TJSLogicalOperator).LogicalType  :=  otOr;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._LogicalAndExpression_Normal_NoIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseOrExpression_Normal_NoIn(E,  IsLVAL);
while (fCurrentInputSymbol = _and_andSym) do begin
Get;
_BitwiseOrExpression_Normal_NoIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSLogicalOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etLogicalOperator;
(E2  as  TJSLogicalOperator).LogicalType  :=  otAnd;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._LogicalOrExpression_Normal_NoIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_LogicalAndExpression_Normal_NoIn(E,  IsLVAL);
while (fCurrentInputSymbol = _bar_barSym) do begin
Get;
_LogicalAndExpression_Normal_NoIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSLogicalOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etLogicalOperator;
(E2  as  TJSLogicalOperator).LogicalType  :=  otOr;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseAndExpression_Initial_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_EqualityExpression_Initial_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _andSym) do begin
Get;
_EqualityExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btAnd;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseAndExpression_Normal_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_EqualityExpression_Normal_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _andSym) do begin
Get;
_EqualityExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btAnd;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseAndExpression_Normal_NoIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_EqualityExpression_Normal_NoIn(E,  IsLVAL);
while (fCurrentInputSymbol = _andSym) do begin
Get;
_EqualityExpression_Normal_NoIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btAnd;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseXorExpression_Initial_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseAndExpression_Initial_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _uparrowSym) do begin
Get;
_BitwiseAndExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btXor;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseOrExpression_Initial_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseXorExpression_Initial_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _barSym) do begin
Get;
_BitwiseXorExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btOr;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseXorExpression_Normal_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseAndExpression_Normal_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _uparrowSym) do begin
Get;
_BitwiseAndExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btXor;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseOrExpression_Normal_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseXorExpression_Normal_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _barSym) do begin
Get;
_BitwiseXorExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btOr;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseXorExpression_Normal_NoIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseAndExpression_Normal_NoIn(E,  IsLVAL);
while (fCurrentInputSymbol = _uparrowSym) do begin
Get;
_BitwiseAndExpression_Normal_NoIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btXor;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._BitwiseOrExpression_Normal_NoIn (out  E:TJSExpr;  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
begin
_BitwiseXorExpression_Normal_NoIn(E,  IsLVAL);
while (fCurrentInputSymbol = _barSym) do begin
Get;
_BitwiseXorExpression_Normal_NoIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSBitwiseOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etBitwiseOperator;
(E2  as  TJSBitwiseOperator).BitwiseType  :=  btOr;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._EqualityExpression_Initial_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  TestType:  TJSEqualityTestType;
begin
_RelationalExpression_Initial_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _equal_equalSym) OR
 (fCurrentInputSymbol = _bang_equalSym) OR
 (fCurrentInputSymbol = _equal_equal_equalSym) OR
 (fCurrentInputSymbol = _bang_equal_equalSym) do begin
if (fCurrentInputSymbol = _equal_equalSym) then begin
Get;
TestType  :=  etEqual;
end else if (fCurrentInputSymbol = _bang_equalSym) then begin
Get;
TestType  :=  etNotEqual;
end else if (fCurrentInputSymbol = _equal_equal_equalSym) then begin
Get;
TestType  :=  etStrictlyEqual;
end else begin
Get;
TestType  :=  etNotStrictlyEqual;
end;
_RelationalExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSEqualityTest.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etEqualityTestOperator;
(E2  as  TJSEqualityTest).EqualityTestType   :=  TestType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._EqualityExpression_Normal_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  TestType:  TJSEqualityTestType;
begin
_RelationalExpression_Normal_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _equal_equalSym) OR
 (fCurrentInputSymbol = _bang_equalSym) OR
 (fCurrentInputSymbol = _equal_equal_equalSym) OR
 (fCurrentInputSymbol = _bang_equal_equalSym) do begin
if (fCurrentInputSymbol = _equal_equalSym) then begin
Get;
TestType  :=  etEqual;
end else if (fCurrentInputSymbol = _bang_equalSym) then begin
Get;
TestType  :=  etNotEqual;
end else if (fCurrentInputSymbol = _equal_equal_equalSym) then begin
Get;
TestType  :=  etStrictlyEqual;
end else begin
Get;
TestType  :=  etNotStrictlyEqual;
end;
_RelationalExpression_Normal_AllowIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSEqualityTest.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etEqualityTestOperator;
(E2  as  TJSEqualityTest).EqualityTestType   :=  TestType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._EqualityExpression_Normal_NoIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  TestType:  TJSEqualityTestType;
begin
_RelationalExpression_Normal_NoIn(E,  IsLVAL);
while (fCurrentInputSymbol = _equal_equalSym) OR
 (fCurrentInputSymbol = _bang_equalSym) OR
 (fCurrentInputSymbol = _equal_equal_equalSym) OR
 (fCurrentInputSymbol = _bang_equal_equalSym) do begin
if (fCurrentInputSymbol = _equal_equalSym) then begin
Get;
TestType  :=  etEqual;
end else if (fCurrentInputSymbol = _bang_equalSym) then begin
Get;
TestType  :=  etNotEqual;
end else if (fCurrentInputSymbol = _equal_equal_equalSym) then begin
Get;
TestType  :=  etStrictlyEqual;
end else begin
Get;
TestType  :=  etNotStrictlyEqual;
end;
_RelationalExpression_Normal_NoIn(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSEqualityTest.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etEqualityTestOperator;
(E2  as  TJSEqualityTest).EqualityTestType  :=  TestType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._RelationalExpression_Normal_NoIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  TestType:  TJSRelationalTestType;
begin
_ShiftExpression_Normal(E,  IsLVAL);
while (fCurrentInputSymbol = _lessSym) OR
 (fCurrentInputSymbol = _greaterSym) OR
 (fCurrentInputSymbol = _less_equalSym) OR
 (fCurrentInputSymbol = _greater_equalSym) OR
 (fCurrentInputSymbol = instanceofSym) do begin
TestType  :=  rtInvalid;
if (fCurrentInputSymbol = _lessSym) then begin
Get;
TestType  :=  rtLessThan;
end else if (fCurrentInputSymbol = _greaterSym) then begin
Get;
TestType  :=  rtGreaterThan;
end else if (fCurrentInputSymbol = _less_equalSym) then begin
Get;
TestType  :=  rtLessThanOrEqual;
end else if (fCurrentInputSymbol = _greater_equalSym) then begin
Get;
TestType  :=  rtGreaterThanOrEqual;
end else begin
Get;
TestType  :=  rtInstanceOf;
end;
_ShiftExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSRelationalTest.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etRelationalOperator;
(E2  as  TJSRelationalTest).RelationalTestType  :=  TestType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._RelationalExpression_Initial_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  TestType:  TJSRelationalTestType;
begin
_ShiftExpression_Initial(E,  IsLVAL);
while _In(symSet[6], fCurrentInputSymbol) do begin
TestType  :=  rtInvalid;
case fCurrentInputSymbol of
  _lessSym : begin
Get;
TestType  :=  rtLessThan;
    end;
  _greaterSym : begin
Get;
TestType  :=  rtGreaterThan;
    end;
  _less_equalSym : begin
Get;
TestType  :=  rtLessThanOrEqual;
    end;
  _greater_equalSym : begin
Get;
TestType  :=  rtGreaterThanOrEqual;
    end;
  instanceofSym : begin
Get;
TestType  :=  rtInstanceOf;
    end;
  inSym : begin
Get;
TestType  :=  rtIn;
    end;
end;
_ShiftExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSRelationalTest.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etRelationalOperator;
(E2  as  TJSRelationalTest).RelationalTestType  :=  TestType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._RelationalExpression_Normal_AllowIn (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  TestType:  TJSRelationalTestType;
begin
_ShiftExpression_Normal(E,  IsLVAL);
while _In(symSet[6], fCurrentInputSymbol) do begin
TestType  :=  rtInvalid;
case fCurrentInputSymbol of
  _lessSym : begin
Get;
TestType  :=  rtLessThan;
    end;
  _greaterSym : begin
Get;
TestType  :=  rtGreaterThan;
    end;
  _less_equalSym : begin
Get;
TestType  :=  rtLessThanOrEqual;
    end;
  _greater_equalSym : begin
Get;
TestType  :=  rtGreaterThanOrEqual;
    end;
  instanceofSym : begin
Get;
TestType  :=  rtInstanceOf;
    end;
  inSym : begin
Get;
TestType  :=  rtIn;
    end;
end;
_ShiftExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSRelationalTest.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etRelationalOperator;
(E2  as  TJSRelationalTest).RelationalTestType  :=  TestType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._ShiftExpression_Initial (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  ShiftType:  TJSShiftType;
begin
_AdditiveExpression_Initial(E,  IsLVAL);
while (fCurrentInputSymbol = _less_lessSym) OR
 (fCurrentInputSymbol = _greater_greaterSym) OR
 (fCurrentInputSymbol = _greater_greater_greaterSym) do begin
if (fCurrentInputSymbol = _less_lessSym) then begin
Get;
ShiftType  :=  stLeft;
end else if (fCurrentInputSymbol = _greater_greaterSym) then begin
Get;
ShiftType  :=  stRight;
end else begin
Get;
ShiftType  :=  stUnsRight;
end;
_AdditiveExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSShiftOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etShiftOperator;
(E2  as  TJSShiftOperator).ShiftType  :=  ShiftType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._ShiftExpression_Normal (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  ShiftType:  TJSShiftType;
begin
_AdditiveExpression_Normal(E,  IsLVAL);
while (fCurrentInputSymbol = _less_lessSym) OR
 (fCurrentInputSymbol = _greater_greaterSym) OR
 (fCurrentInputSymbol = _greater_greater_greaterSym) do begin
if (fCurrentInputSymbol = _less_lessSym) then begin
Get;
ShiftType  :=  stLeft;
end else if (fCurrentInputSymbol = _greater_greaterSym) then begin
Get;
ShiftType  :=  stRight;
end else begin
Get;
ShiftType  :=  stUnsRight;
end;
_AdditiveExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSShiftOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etShiftOperator;
(E2  as  TJSShiftOperator).ShiftType  :=  ShiftType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._AdditiveExpression_Initial (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  ArithType:  TJSArithType;
begin
_MultiplicativeExpression_Initial(E,  IsLVAL);
while (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _minusSym) do begin
if (fCurrentInputSymbol = _plusSym) then begin
Get;
ArithType  :=  atAdd;
end else begin
Get;
ArithType  :=  atSub;
end;
_MultiplicativeExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSArithOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etArithOperator;
(E2  as  TJSArithOperator).ArithType  :=  ArithType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._AdditiveExpression_Normal (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  ArithType:  TJSArithType;
begin
_MultiplicativeExpression_Normal(E,  IsLVAL);
while (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _minusSym) do begin
if (fCurrentInputSymbol = _plusSym) then begin
Get;
ArithType  :=  atAdd;
end else begin
Get;
ArithType  :=  atSub;
end;
_MultiplicativeExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSArithOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etArithOperator;
(E2  as  TJSArithOperator).ArithType  :=  ArithType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._MultiplicativeExpression_Initial (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  ArithType:  TJSArithType;
begin
_UnaryExpression_Initial(E,  IsLVAL);
while (fCurrentInputSymbol = _slashSym) OR
 (fCurrentInputSymbol = _starSym) OR
 (fCurrentInputSymbol = _percentSym) do begin
if (fCurrentInputSymbol = _starSym) then begin
Get;
ArithType  :=  atMul;
end else if (fCurrentInputSymbol = _slashSym) then begin
Get;
ArithType  :=  atDiv;
end else begin
Get;
ArithType  :=  atMod;
end;
_UnaryExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSArithOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etArithOperator;
(E2  as  TJSArithOperator).ArithType  :=  ArithType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._MultiplicativeExpression_Normal (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;  ArithType:  TJSArithType;
begin
_UnaryExpression_Normal(E,  IsLVAL);
while (fCurrentInputSymbol = _slashSym) OR
 (fCurrentInputSymbol = _starSym) OR
 (fCurrentInputSymbol = _percentSym) do begin
if (fCurrentInputSymbol = _starSym) then begin
Get;
ArithType  :=  atMul;
end else if (fCurrentInputSymbol = _slashSym) then begin
Get;
ArithType  :=  atDiv;
end else begin
Get;
ArithType  :=  atMod;
end;
_UnaryExpression_Normal(E1,  IsLVAL);
IsLVAL  :=  false;
E2  :=  TJSArithOperator.CreateWithTracker(FParseTracker  as  TTracker);
E2.ExprType  :=  etArithOperator;
(E2  as  TJSArithOperator).ArithType  :=  ArithType;
InsertExprTail(E2,E);
InsertExprTail(E2,E1);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._UnaryExpression_Initial (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1:  TJSExpr;  UnaryType:  TJSUnaryType;
begin
E  :=  nil;
if _In(symSet[7], fCurrentInputSymbol) then begin
_PostfixExpression_Initial(E,  IsLVAL);
end else if _In(symSet[8], fCurrentInputSymbol) then begin
UnaryType  :=  utInvalid;
case fCurrentInputSymbol of
  deleteSym : begin
Get;
_LeftSideExpression_Normal(E,  IsLVAL);
IsLVAL  :=  false;
UnaryType  :=  utDelete;
    end;
  voidSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
IsLVAL  :=  false;
UnaryType  :=  utVoid;
    end;
  typeofSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
IsLVAL  :=  false;
UnaryType  :=  utTypeof;
    end;
  _plus_plusSym : begin
Get;
_LeftSideExpression_Normal(E,  IsLVAL);
UnaryType  :=  utPreInc;
    end;
  _minus_minusSym : begin
Get;
_LeftSideExpression_Normal(E,  IsLVAL);
UnaryType  :=  utPreDec;
    end;
  _plusSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
UnaryType  :=  utPlus;
    end;
  _minusSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
UnaryType  :=  utMinus;
    end;
  _tildeSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
UnaryType  :=  utBitNot;
    end;
  _bangSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
UnaryType  :=  utLogNot;
    end;
end;
E1  :=  TJSUnaryOperator.CreateWithTracker(FParseTracker  as  TTracker);
E1.ExprType  :=  etUnaryOperator;
(E1  as  TJSUnaryOperator).UnaryType  :=  UnaryType;
InsertExprTail(E1,E);
E  :=  E1;

end else begin SynError(94);
end;
end;

procedure TJScriptGrammar._UnaryExpression_Normal (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1:  TJSExpr;  UnaryType:  TJSUnaryType;
begin
E  :=  nil;
if _In(symSet[9], fCurrentInputSymbol) then begin
_PostfixExpression_Normal(E,  IsLVAL);
end else if _In(symSet[8], fCurrentInputSymbol) then begin
UnaryType  :=  utInvalid;
case fCurrentInputSymbol of
  deleteSym : begin
Get;
_LeftSideExpression_Normal(E,  IsLVAL);
IsLVAL  :=  false;
UnaryType  :=  utDelete;
    end;
  voidSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
IsLVAL  :=  false;
UnaryType  :=  utVoid;
    end;
  typeofSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
IsLVAL  :=  false;
UnaryType  :=  utTypeof;
    end;
  _plus_plusSym : begin
Get;
_LeftSideExpression_Normal(E,  IsLVAL);
UnaryType  :=  utPreInc;
    end;
  _minus_minusSym : begin
Get;
_LeftSideExpression_Normal(E,  IsLVAL);
UnaryType  :=  utPreDec;
    end;
  _plusSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
UnaryType  :=  utPlus;
    end;
  _minusSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
UnaryType  :=  utMinus;
    end;
  _tildeSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
UnaryType  :=  utBitNot;
    end;
  _bangSym : begin
Get;
_UnaryExpression_Normal(E,  IsLVAL);
UnaryType  :=  utLogNot;
    end;
end;
E1  :=  TJSUnaryOperator.CreateWithTracker(FParseTracker  as  TTracker);
E1.ExprType  :=  etUnaryOperator;
(E1  as  TJSUnaryOperator).UnaryType  :=  UnaryType;
InsertExprTail(E1,E);
E  :=  E1;

end else begin SynError(95);
end;
end;

procedure TJScriptGrammar._PostfixExpression_Initial (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1:  TJSExpr;  UnaryType:  TJSUnaryType;
begin
_LeftSideExpression_Initial(E,  IsLVAL);
if (fCurrentInputSymbol = _plus_plusSym) OR
 (fCurrentInputSymbol = _minus_minusSym) then begin
if (fCurrentInputSymbol = _plus_plusSym) then begin
Get;
UnaryType  :=  utPostInc;
end else begin
Get;
UnaryType  :=  utPostDec;
end;
IsLVAL  :=  false;
E1  :=  TJSUnaryOperator.CreateWithTracker(FParseTracker  as  TTracker);
E1.ExprType  :=  etUnaryOperator;
(E1  as  TJSUnaryOperator).UnaryType  :=  UnaryType;
InsertExprTail(E1,E);
E  :=  E1;

end;
end;

procedure TJScriptGrammar._PostfixExpression_Normal (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E1:  TJSExpr;  UnaryType:  TJSUnaryType;
begin
_LeftSideExpression_Normal(E,  IsLVAL);
if (fCurrentInputSymbol = _plus_plusSym) OR
 (fCurrentInputSymbol = _minus_minusSym) then begin
if (fCurrentInputSymbol = _plus_plusSym) then begin
Get;
UnaryType  :=  utPostInc;
end else begin
Get;
UnaryType  :=  utPostDec;
end;
IsLVAL  :=  false;
E1  :=  TJSUnaryOperator.CreateWithTracker(FParseTracker  as  TTracker);
E1.ExprType  :=  etUnaryOperator;
(E1  as  TJSUnaryOperator).UnaryType  :=  UnaryType;
InsertExprTail(E1,E);
E  :=  E1;

end;
end;

procedure TJScriptGrammar._LeftSideExpression_Initial (out  E:TJSExpr;  var  IsLVAL:  boolean);begin
E  :=  nil;
if _In(symSet[7], fCurrentInputSymbol) then begin
_CallExpression_Initial(E,  IsLVAL);
end else if (fCurrentInputSymbol = newSym) then begin
_FullNewExpression(E);
end else begin SynError(96);
end;
end;

procedure TJScriptGrammar._LeftSideExpression_Normal (out  E:TJSExpr;  var  IsLVAL:  boolean);begin
E  :=  nil;
if _In(symSet[9], fCurrentInputSymbol) then begin
_CallExpression_Normal(E,  IsLVAL);
end else if (fCurrentInputSymbol = newSym) then begin
_FullNewExpression(E);
end else begin SynError(97);
end;
end;

procedure TJScriptGrammar._CallExpression_Initial (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E2,  E3:  TJSExpr;  L:  TJSExprList;
begin
E  :=  nil;
if _In(symSet[10], fCurrentInputSymbol) then begin
_PrimaryExpression_Initial(E,  IsLVAL);
end else if (fCurrentInputSymbol = newSym) then begin
_FullNewExpression(E);
end else begin SynError(98);
end;
while (fCurrentInputSymbol = _lparenSym) OR
 (fCurrentInputSymbol = _lbrackSym) OR
 (fCurrentInputSymbol = _pointSym) do begin
if (fCurrentInputSymbol = _lbrackSym) OR
 (fCurrentInputSymbol = _pointSym) then begin
_MemberOperator(E2);
//Member  operator  already  constructed,  in  E2.
//add  existing  expr  to  LHS  of  .  or  [  operator
InsertExprHead(E2,  E);
E  :=  E2;

end else begin
_Arguments(L);
E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E3.ExprType  :=  etCallOperator;
InsertExprTail(E3,E);
InsertExprListTail(E3,L,  false);
E  :=  E3;

end;
IsLVAL  :=  true;
end;
end;

procedure TJScriptGrammar._CallExpression_Normal (out  E:TJSExpr;  var  IsLVAL:  boolean);var  E2,  E3:  TJSExpr;  L:  TJSExprList;
begin
E  :=  nil;
if _In(symSet[11], fCurrentInputSymbol) then begin
_PrimaryExpression_Normal(E,  IsLVAL);
end else if (fCurrentInputSymbol = newSym) then begin
_FullNewExpression(E);
end else begin SynError(99);
end;
while (fCurrentInputSymbol = _lparenSym) OR
 (fCurrentInputSymbol = _lbrackSym) OR
 (fCurrentInputSymbol = _pointSym) do begin
if (fCurrentInputSymbol = _lbrackSym) OR
 (fCurrentInputSymbol = _pointSym) then begin
_MemberOperator(E2);
//Member  operator  already  constructed,  in  E2.
//add  existing  expr  to  LHS  of  .  or  [  operator
InsertExprHead(E2,  E);
E  :=  E2;

end else begin
_Arguments(L);
E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E3.ExprType  :=  etCallOperator;
InsertExprTail(E3,E);
InsertExprListTail(E3,L,  false);
E  :=  E3;

end;
IsLVAL  :=  true;
end;
end;

procedure TJScriptGrammar._FullNewExpression (out  E:  TJSExpr);var  E2,  E3:  TJSExpr;  L:  TJSExprList;
begin
Expect(newSym);
_FullNewSubexpression(E2);
E  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E.ExprType  :=  etNewOperator;
InsertExprTail(E,E2);
if (fCurrentInputSymbol = _lparenSym) then begin
_Arguments(L);
E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E3.ExprType  :=  etCallOperator;
InsertExprTail(E3,E);
InsertExprListTail(E3,L,  false);
E  :=  E3;

end;
end;

procedure TJScriptGrammar._FullNewSubexpression (out  E:  TJSExpr);var  LVALStart:  boolean;  E2:  TJSExpr;
begin
LValStart  :=  true;
E  :=  nil;
if _In(symSet[11], fCurrentInputSymbol) then begin
_PrimaryExpression_Normal(E,  LVALStart);
end else if (fCurrentInputSymbol = newSym) then begin
_FullNewExpression(E);
end else begin SynError(100);
end;
while (fCurrentInputSymbol = _lbrackSym) OR
 (fCurrentInputSymbol = _pointSym) do begin
_MemberOperator(E2);
//Member  operator  already  constructed,  in  E2.
//add  existing  expr  to  LHS  of  .  or  [  operator
InsertExprHead(E2,E);
E  :=  E2;

end;
end;

procedure TJScriptGrammar._MemberOperator (out  E:TJSExpr);var  LVALStart:  boolean;  E2:  TJSExpr;  I:  TJSIdentifier;
begin
if (fCurrentInputSymbol = _lbrackSym) then begin
LValStart  :=  true;
E  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E.ExprType  :=  etArrayAccessOperator;
//Add  RHS  child  here  only.

Get;
_Expression_Normal_AllowIn(E2,LVALStart);
InsertExprTail(E,E2);
Expect(_rbrackSym);
end else if (fCurrentInputSymbol = _pointSym) then begin
LValStart  :=  true;
E  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E.ExprType  :=  etNamedMemberOperator;
//Add  RHS  child  here  only.

Get;
if (fCurrentInputSymbol = _IdentifierSym) then begin
_Identifier(I);
InsertExprTail(E,I);
end else if _In(symSet[12], fCurrentInputSymbol) then begin
//Bit  hacky,  duplicate  identifier  code  for  comp  workaround.
I  :=  TJSIdentifier.CreateWithTracker(FParseTracker  as  TTracker);
I.ExprType  :=  etSimpleExpression;
I.SimpleExprType:=  setIdentifier;
InsertExprTail(E,I);

case fCurrentInputSymbol of
  returnSym : begin
Get;
ParseWarning(1010,  '');  I.Name  :=  LexString;
    end;
  defaultSym : begin
Get;
ParseWarning(1008,  '');   I.Name  :=  LexString;
    end;
  catchSym : begin
Get;
ParseWarning(1009,  '');   I.Name  :=  LexString;
    end;
  deleteSym : begin
Get;
ParseWarning(1013,  '');   I.Name  :=  LexString;
    end;
  thenSym : begin
Get;
ParseWarning(1014,  '');   I.Name  :=  LexString;
    end;
  forSym : begin
Get;
ParseWarning(1015,  '');   I.Name  :=  LexString;
    end;
end;
end else begin SynError(101);
end;
end else begin SynError(102);
end;
end;

procedure TJScriptGrammar._Arguments (out  L:  TJSExprList);begin

  L  :=  TJSExprList.CreateWithTracker(FParseTracker  as  TTracker);
  L.ListType  :=  eltArguments;

Expect(_lparenSym);
if _In(symSet[3], fCurrentInputSymbol) then begin
_ArgumentList(L);
end;
Expect(_rparenSym);
end;

procedure TJScriptGrammar._ArgumentList (var  L:  TJSExprList);var  LValStart:  boolean;  E:TJSExpr;
begin
LValStart  :=  true;
_AssignmentExpression_Normal_AllowIn(E,  LValStart);
InsertExprTail(L,E);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
LValStart  :=  true;
_AssignmentExpression_Normal_AllowIn(E,  LValStart);
InsertExprTail(L,E);
end;
end;

procedure TJScriptGrammar._ElementList (out  L:TJSExprList);var  E:  TJSExpr;  SeenComma:  boolean;
begin

  L  :=  TJSExprList.CreateWithTracker(FParseTracker  as  TTRacker);
  L.ListType  :=  eltArrayElems;
  E  :=  nil;
  SeenComma  :=  false;

if _In(symSet[3], fCurrentInputSymbol) then begin
_LiteralElement(E);
InsertExprTail(L,E);
end;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
SeenComma  :=  true;
if  not  Assigned(E)  then
begin
   E:=  TJSSimpleExpr.CreateWithTracker(FParseTracker  as  TTRacker);
   E.ExprType  :=  etSimpleExpression;
   (E  as  TJSSimpleExpr).SimpleExprType  :=  setNull;
   InsertExprTail(L,E);
end;
E:=  nil;

if _In(symSet[3], fCurrentInputSymbol) then begin
_LiteralElement(E);
InsertExprTail(L,E);
end;
end;
if  SeenComma  and  not  Assigned(E)  then
begin
   E:=  TJSSimpleExpr.CreateWithTracker(FParseTracker  as  TTRacker);
   E.ExprType  :=  etSimpleExpression;
   (E  as  TJSSimpleExpr).SimpleExprType  :=  setNull;
   InsertExprTail(L,E);
end;

end;

procedure TJScriptGrammar._LiteralElement (out  E:  TJSExpr);var  LValStart:  boolean;
begin
LValStart  :=  true;
_AssignmentExpression_Normal_AllowIn(E,  LValStart);
end;

procedure TJScriptGrammar._FieldList (out  L:TJSExprList);var  F:  TJSExpr;
begin
L  :=  TJSExprList.CreateWithTracker(FParseTracker  as  TTracker);
L.ListType  :=  eltObjectFields;

if _In(symSet[13], fCurrentInputSymbol) then begin
_LiteralField(F);
InsertExprTail(L,F);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
if _In(symSet[13], fCurrentInputSymbol) then begin
_LiteralField(F);
InsertExprTail(L,F);
end;
end;
end;
end;

procedure TJScriptGrammar._AssignmentExpression_Normal_AllowIn (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  E1,  E2:  TJSExpr;
     MS:  TJSMultiAssign;
begin
_ConditionalExpression_Normal_AllowIn(E,  IsLVAL);
if _In(symSet[4], fCurrentInputSymbol) then begin
if _In(symSet[5], fCurrentInputSymbol) then begin
_CompoundAssignment(MS);
E1  :=  MS;
end else begin
Get;
E1  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E1.ExprType  :=  etAssignOperator;
end;
if  not  IsLVAL  then  SynError(1000);
_AssignmentExpression_Normal_AllowIn(E2,  IsLVAL);
InsertExprTail(E1,E);
InsertExprTail(E1,E2);
E  :=  E1;

end;
end;

procedure TJScriptGrammar._LiteralField (out  F:  TJSExpr);var  LValStart:  boolean;
     I:  TJSIdentifier;
     S:  TJSString;
     N:  TJSNumber;
     E:  TJSExpr;
begin
LValStart  :=  true;
F  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTRacker);
F.ExprType  :=  etObjectFieldDecl;

if (fCurrentInputSymbol = _IdentifierSym) then begin
_Identifier(I);
InsertExprTail(F,I);
end else if (fCurrentInputSymbol = DQuotStringSym) OR
 (fCurrentInputSymbol = SQuotStringSym) then begin
_StringLiteral(S);
InsertExprTail(F,S);
end else if (fCurrentInputSymbol = _NumberSym) then begin
_Number(N);
InsertExprTail(F,N);
end else if _In(symSet[12], fCurrentInputSymbol) then begin
//Bit  hacky,  duplicate  identifier  code  for  comp  workaround.
I  :=  TJSIdentifier.CreateWithTracker(FParseTracker  as  TTracker);
I.ExprType  :=  etSimpleExpression;
I.SimpleExprType:=  setIdentifier;
InsertExprTail(F,I);

case fCurrentInputSymbol of
  returnSym : begin
Get;
ParseWarning(1016,  '');  I.Name  :=  LexString;
    end;
  defaultSym : begin
Get;
ParseWarning(1017,  '');   I.Name  :=  LexString;
    end;
  catchSym : begin
Get;
ParseWarning(1018,  '');   I.Name  :=  LexString;
    end;
  deleteSym : begin
Get;
ParseWarning(1019,  '');   I.Name  :=  LexString;
    end;
  thenSym : begin
Get;
ParseWarning(1020,  '');   I.Name  :=  LexString;
    end;
  forSym : begin
Get;
ParseWarning(1021,  '');   I.Name  :=  LexString;
    end;
end;
end else begin SynError(103);
end;
Expect(_colonSym);
_AssignmentExpression_Normal_AllowIn(E,  LValStart);
InsertExprTail(F,E);
end;

procedure TJScriptGrammar._NamedFunctionDecl (out  F:TJSFunction);begin
F  :=  TJSFunction.CreateWithTracker(FParseTracker  as  TTracker);
Expect(_IdentifierSym);
F.FuncName  :=  LexString;
_FormalParametersAndBody(F);
end;

procedure TJScriptGrammar._AnonymousFunctionDecl (out  F:TJSFunction);begin
F  :=  TJSFunction.CreateWithTracker(FParseTracker  as  TTracker);
_FormalParametersAndBody(F);
end;

procedure TJScriptGrammar._Expression_Normal_AllowIn (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  SubLVal:  boolean;  E2,  E3:  TJSExpr;
begin
_AssignmentExpression_Normal_AllowIn(E,  IsLVAL);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
SubLVal  :=  true;
_AssignmentExpression_Normal_AllowIn(E2,  SubLVal);

  IsLVAL  :=  false;
  E3  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
  E3.ExprType  :=  etCommaOperator;
  InsertExprTail(E3,E);
  InsertExprTail(E3,E2);
  E  :=  E3;

end;
end;

procedure TJScriptGrammar._ArrayLiteral (out  E:TJSSimpleExpr);var  L:  TJSExprList;
begin
E  :=  TJSSimpleExpr.CreateWithTracker(FParseTracker  as  TTracker);
E.ExprType  :=  etSimpleExpression;
E.SimpleExprType  :=  setArrayLit;
Expect(_lbrackSym);
_ElementList(L);
InsertExprListTail(E,  L);
Expect(_rbrackSym);
end;

procedure TJScriptGrammar._ParenthesizedExpression (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  SubLVal:  boolean;
begin
Expect(_lparenSym);
SubLVal  :=  true;
_Expression_Normal_AllowIn(E,  SubLVal);
if  not  SubLVal  then
   IsLVAL  :=  false;
Expect(_rparenSym);
end;

procedure TJScriptGrammar._PrimaryExpression_Initial (out  E:  TJSExpr;  var  IsLVAL:  boolean);begin
_SimpleExpression(E,  IsLVAL);
end;

procedure TJScriptGrammar._ObjectLiteral (out  E:TJSSImpleExpr);var  L:  TJSExprList;
begin
E  :=  TJSSimpleExpr.CreateWithTracker(FParseTracker  as  TTracker);
E.ExprType  :=  etSimpleExpression;
E.SimpleExprType  :=  setObjLit;
Expect(_lbraceSym);
_FieldList(L);
InsertExprListTail(E,  L);
Expect(_rbraceSym);
end;

procedure TJScriptGrammar._FunctionExpression (out  E:  TJSExpr);var  F:  TJSFunction;
begin
E  :=  TJSExpr.CreateWithTracker(FParseTracker  as  TTracker);
E.ExprType  :=  etFunctionExpression;
Expect(functionSym);
if (fCurrentInputSymbol = _lparenSym) then begin
_AnonymousFunctionDecl(F);
end else if (fCurrentInputSymbol = _IdentifierSym) then begin
_NamedFunctionDecl(F);
end else begin SynError(104);
end;
InsertStmtTail(E,  F);
end;

procedure TJScriptGrammar._SimpleExpression (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  I:  TJSIdentifier;
     S:  TJSString;
     N:  TJSNumber;
     A:  TJSSimpleExpr;

begin
E  :=  nil;
case fCurrentInputSymbol of
  _lparenSym : begin
_ParenthesizedExpression(E,  IsLVAL);
    end;
  thisSym, nullSym, falseSym, trueSym : begin
E  :=  TJSSimpleExpr.CreateWithTracker(FParseTracker  as  TTracker);
if (fCurrentInputSymbol = thisSym) then begin
Get;
(E  as  TJSSimpleExpr).SimpleExprType  :=  setThis;
end else if (fCurrentInputSymbol = nullSym) then begin
Get;
IsLVAL  :=  false;
(E  as  TJSSimpleExpr).SimpleExprType  :=  setNull;
end else if (fCurrentInputSymbol = falseSym) then begin
Get;
IsLVAL  :=  false;
(E  as  TJSSimpleExpr).SimpleExprType  :=  setFalse;
end else begin
Get;
IsLVAL  :=  false;
(E  as  TJSSimpleExpr).SimpleExprType  :=  setTrue;
end;
    end;
  _IdentifierSym : begin
_Identifier(I);
E  :=  I;
    end;
  _NumberSym : begin
_Number(N);
IsLVAL  :=  false;
E  :=  N;

    end;
  DQuotStringSym, SQuotStringSym : begin
_StringLiteral(S);
IsLVAL  :=  false;
E  :=  S;
    end;
  _slashSym, _slash_equalSym : begin
_RegularExpression(S);
IsLVAL  :=  false;
E  :=  S;
    end;
  _lbrackSym : begin
_ArrayLiteral(A);
IsLVAL  :=  false;
E  :=  A;
    end;
else begin SynError(105);
    end;
end;
end;

procedure TJScriptGrammar._PrimaryExpression_Normal (out  E:  TJSExpr;  var  IsLVAL:  boolean);var  O:  TJSSimpleExpr;
begin
E  :=  nil;
if _In(symSet[10], fCurrentInputSymbol) then begin
_SimpleExpression(E,  IsLVAL);
end else if (fCurrentInputSymbol = functionSym) then begin
_FunctionExpression(E);
IsLVAL  :=  false;
end else if (fCurrentInputSymbol = _lbraceSym) then begin
_ObjectLiteral(O);
IsLVAL  :=  false;
E  :=  O;
end else begin SynError(106);
end;
end;

procedure TJScriptGrammar._StringLiteral (out  S:  TJSString);var  SVal:string;
begin
if (fCurrentInputSymbol = SQuotStringSym) then begin
Get;
SVal  :=  LexString;  //TODO  -  check  this.
SVal  :=  SVal.SubString(1,  Length(SVal)  -  2);

end else if (fCurrentInputSymbol = DQuotStringSym) then begin
Get;
SVal  :=  LexString;  //TODO  -  check  this.
SVal  :=  SVal.SubString(1,  Length(SVal)  -  2);

end else begin SynError(107);
end;
S  :=  TJSString.CreateWithTracker(FParseTracker  as  TTracker);
S.ExprType  :=  etSimpleExpression;
S.SimpleExprType  :=  setStringLiteral;
S.StrData  :=  SVal;

end;

procedure TJScriptGrammar._RegularExpression (out  ST:TJSString);var
      Regexp,
      RegexpPrefix,
      RegexpSuffix,
      S:  string;
      StartPos,  CurPos,  Rewind:integer;
begin
StartPos  :=  (Scanner  as  TJScriptGrammarScanner).BufferPosition;

if (fCurrentInputSymbol = _slashSym) then begin
Get;
RegexpPrefix  :=  '';
end else if (fCurrentInputSymbol = _slash_equalSym) then begin
Get;
RegexpPrefix  :=  '=';
end else begin SynError(108);
end;
CurPos  :=  (Scanner  as  TJScriptGrammarScanner).BufferPosition;
Rewind  :=  CurPos  -  StartPos;
RewindLexer(Rewind);
_RegularExpressionBody(Regexp);
Expect(_slashSym);
RegexpSuffix  :=  '/';
if (fCurrentInputSymbol = _IdentifierSym) then begin
_RegularExpressionFlags(S);
RegexpSuffix  :=  RegexpSuffix  +  S;
end;
S  :=  RegexpPrefix  +  Regexp  +  RegexpSuffix;
ST  :=  TJSString.CreateWithTracker(FParseTracker  as  TTracker);
ST.ExprType  :=  etSimpleExpression;
ST.SimpleExprType  :=  setRegExp;
ST.StrData  :=  S;

end;

procedure TJScriptGrammar._RegularExpressionFlags (out  S:string);begin
Expect(_IdentifierSym);
S  :=  LexString;
end;

procedure TJScriptGrammar._RegularExpressionBody (var  Res:string);var  Sc:  TJScriptGrammarScanner;  ClassStr:  string;
begin

Res  :=  '';
Sc  :=  Scanner  as  TJScriptGrammarScanner;
while  (Sc.CurrInputCh  <>  '/')
   and  (Sc.CurrInputCh  <>  _EF)  do
begin
   Res  :=  Res  +  Sc.CurrInputCh;
   if  Sc.CurrInputCh  =  '['  then
   begin
     Sc.NextCh;
     ClassStr  :=  '';
     _RegularExpressionClassChars(ClassStr);
     Res  :=  Res  +  ClassStr;
     Assert(Sc.CurrInputCh  =  ']');
   end
   else  if  Sc.CurrInputCh  =  '\'  then
   begin
     Sc.NextCh;
     ClassStr  :=  '';
     _RegularExpressionEscapeSequence(ClassStr);
     Res  :=  Res  +  ClassStr;
   end
   else
     Sc.NextCh;
end;
//First  thing  get  does  is  advance  to  next  char,
//and  we  need  the  token  stored  in  the  lexer.
Get;
exit;

Expect(_backslashSym);
_RegularExpressionClassChars(ClassStr);
_RegularExpressionEscapeSequence(ClassStr);
end;

procedure TJScriptGrammar._RegularExpressionClassChars (var  Res:  string);var  Sc:  TJScriptGrammarScanner;  TokenStr:  string;
begin

Res  :=  '';
Sc  :=  Scanner  as  TJScriptGrammarScanner;
while  (Sc.CurrInputCh  <>  ']')
   and  (Sc.CurrInputCh  <>  _EF)  do
begin
   Res  :=  Res  +  Sc.CurrInputCh;
   if  Sc.CurrInputCh  =  '\'  then
   begin
     Sc.NextCh;
     TokenStr  :=  '';
     _RegularExpressionEscapeSequence(TokenStr);
     Res  :=  Res  +  TokenStr;
   end
   else
     Sc.NextCh;
end;
exit;

_RegularExpressionEscapeSequence(TokenStr);
end;

procedure TJScriptGrammar._RegularExpressionEscapeSequence (var  Res:  string);var  Sc:  TJScriptGrammarScanner;
begin

Sc  :=  Scanner  as  TJScriptGrammarScanner;
Res  :=  Sc.CurrInputCh;
Sc.NextCh;
exit;

Get;
end;

procedure TJScriptGrammar._Number (out  N:TJSNumber);begin
N  :=  TJSNumber.CreateWithTracker(FParseTracker  as  TTracker);
N.ExprType  :=  etSimpleExpression;
N.SimpleExprType  :=  setNumber;

Expect(_NumberSym);
N.StringRep  :=  LexString;
try
   N.IntValue  :=  StrToInt(N.StringRep);
   N.IntValid  :=  true;
except
   on  E:Exception  do  N.IntValid  :=  false;
end;
try
   N.Int64Value  :=  StrToInt64(N.StringRep);
   N.Int64Valid  :=  true;
except
   on  E:Exception  do  N.Int64Valid  :=  false;
end;
try
   N.FloatValue  :=  StrToFloat(N.StringRep);
   N.FloatValid  :=  true;
except
   on  E:Exception  do  N.FloatValid  :=  false;
end;

end;

procedure TJScriptGrammar._Identifier (out  I:TJSIdentifier);begin
I  :=  TJSIdentifier.CreateWithTracker(FParseTracker  as  TTracker);
I.ExprType  :=  etSimpleExpression;
I.SimpleExprType  :=  setIdentifier;

Expect(_IdentifierSym);
I.Name  :=  LexString;
end;

function TJScriptGrammar.GetBuildDate : TDateTime;
const
  BDate = 42512;
  Hour = 22;
  Min = 50;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TJScriptGrammar.GetVersion : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TJScriptGrammar.GetVersionStr : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TJScriptGrammar.GetVersionInfo : AnsiString;
begin
  Result := 'Comment: Javascript parser.' + #13#10 +
'Author: Martin Harvey' + #13#10 +
'Copyright: (c) Martin Harvey';
end;

procedure TJScriptGrammar.SetVersion(const Value : AnsiString);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TJScriptGrammar.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_JScriptGrammar;
end;  {Parse}

procedure TJScriptGrammar.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 0, 2] := [];
symSet[ 0, 3] := [];
symSet[ 0, 4] := [];
symSet[ 0, 5] := [];
symSet[ 1, 0] := [_IdentifierSym, _NumberSym, DQuotStringSym, 
                    SQuotStringSym, _slashSym, _slash_equalSym, thisSym, 
                    nullSym, falseSym, trueSym];
symSet[ 1, 1] := [_lparenSym-16, functionSym-16, returnSym-16, deleteSym-16, 
                    forSym-16, _lbraceSym-16, _lbrackSym-16];
symSet[ 1, 2] := [newSym-32, _plus_plusSym-32, _minus_minusSym-32, voidSym-32, 
                    typeofSym-32, _plusSym-32, _minusSym-32, _tildeSym-32, 
                    _bangSym-32];
symSet[ 1, 3] := [];
symSet[ 1, 4] := [trySym-64, throwSym-64, breakSym-64, continueSym-64, 
                    withSym-64, varSym-64];
symSet[ 1, 5] := [_semicolonSym-80, whileSym-80, doSym-80, switchSym-80, 
                    ifSym-80];
symSet[ 2, 0] := [_IdentifierSym, _NumberSym, DQuotStringSym, 
                    SQuotStringSym, _slashSym, _slash_equalSym, thisSym, 
                    nullSym, falseSym, trueSym];
symSet[ 2, 1] := [_lparenSym-16, functionSym-16, deleteSym-16, _lbraceSym-16, 
                    _lbrackSym-16];
symSet[ 2, 2] := [newSym-32, _plus_plusSym-32, _minus_minusSym-32, voidSym-32, 
                    typeofSym-32, _plusSym-32, _minusSym-32, _tildeSym-32, 
                    _bangSym-32];
symSet[ 2, 3] := [];
symSet[ 2, 4] := [varSym-64];
symSet[ 2, 5] := [];
symSet[ 3, 0] := [_IdentifierSym, _NumberSym, DQuotStringSym, 
                    SQuotStringSym, _slashSym, _slash_equalSym, thisSym, 
                    nullSym, falseSym, trueSym];
symSet[ 3, 1] := [_lparenSym-16, functionSym-16, deleteSym-16, _lbraceSym-16, 
                    _lbrackSym-16];
symSet[ 3, 2] := [newSym-32, _plus_plusSym-32, _minus_minusSym-32, voidSym-32, 
                    typeofSym-32, _plusSym-32, _minusSym-32, _tildeSym-32, 
                    _bangSym-32];
symSet[ 3, 3] := [];
symSet[ 3, 4] := [];
symSet[ 3, 5] := [];
symSet[ 4, 0] := [_slash_equalSym];
symSet[ 4, 1] := [];
symSet[ 4, 2] := [];
symSet[ 4, 3] := [_star_equalSym-48, _percent_equalSym-48];
symSet[ 4, 4] := [_plus_equalSym-64, _minus_equalSym-64, 
                    _less_less_equalSym-64, _greater_greater_equalSym-64, 
                    _greater_greater_greater_equalSym-64, _and_equalSym-64, 
                    _uparrow_equalSym-64, _bar_equalSym-64, _equalSym-64];
symSet[ 4, 5] := [];
symSet[ 5, 0] := [_slash_equalSym];
symSet[ 5, 1] := [];
symSet[ 5, 2] := [];
symSet[ 5, 3] := [_star_equalSym-48, _percent_equalSym-48];
symSet[ 5, 4] := [_plus_equalSym-64, _minus_equalSym-64, 
                    _less_less_equalSym-64, _greater_greater_equalSym-64, 
                    _greater_greater_greater_equalSym-64, _and_equalSym-64, 
                    _uparrow_equalSym-64, _bar_equalSym-64];
symSet[ 5, 5] := [];
symSet[ 6, 0] := [];
symSet[ 6, 1] := [];
symSet[ 6, 2] := [_lessSym-32, _greaterSym-32];
symSet[ 6, 3] := [_less_equalSym-48, _greater_equalSym-48, instanceofSym-48, 
                    inSym-48];
symSet[ 6, 4] := [];
symSet[ 6, 5] := [];
symSet[ 7, 0] := [_IdentifierSym, _NumberSym, DQuotStringSym, 
                    SQuotStringSym, _slashSym, _slash_equalSym, thisSym, 
                    nullSym, falseSym, trueSym];
symSet[ 7, 1] := [_lparenSym-16, _lbrackSym-16];
symSet[ 7, 2] := [newSym-32];
symSet[ 7, 3] := [];
symSet[ 7, 4] := [];
symSet[ 7, 5] := [];
symSet[ 8, 0] := [];
symSet[ 8, 1] := [deleteSym-16];
symSet[ 8, 2] := [_plus_plusSym-32, _minus_minusSym-32, voidSym-32, 
                    typeofSym-32, _plusSym-32, _minusSym-32, _tildeSym-32, 
                    _bangSym-32];
symSet[ 8, 3] := [];
symSet[ 8, 4] := [];
symSet[ 8, 5] := [];
symSet[ 9, 0] := [_IdentifierSym, _NumberSym, DQuotStringSym, 
                    SQuotStringSym, _slashSym, _slash_equalSym, thisSym, 
                    nullSym, falseSym, trueSym];
symSet[ 9, 1] := [_lparenSym-16, functionSym-16, _lbraceSym-16, _lbrackSym-16];
symSet[ 9, 2] := [newSym-32];
symSet[ 9, 3] := [];
symSet[ 9, 4] := [];
symSet[ 9, 5] := [];
symSet[10, 0] := [_IdentifierSym, _NumberSym, DQuotStringSym, 
                    SQuotStringSym, _slashSym, _slash_equalSym, thisSym, 
                    nullSym, falseSym, trueSym];
symSet[10, 1] := [_lparenSym-16, _lbrackSym-16];
symSet[10, 2] := [];
symSet[10, 3] := [];
symSet[10, 4] := [];
symSet[10, 5] := [];
symSet[11, 0] := [_IdentifierSym, _NumberSym, DQuotStringSym, 
                    SQuotStringSym, _slashSym, _slash_equalSym, thisSym, 
                    nullSym, falseSym, trueSym];
symSet[11, 1] := [_lparenSym-16, functionSym-16, _lbraceSym-16, _lbrackSym-16];
symSet[11, 2] := [];
symSet[11, 3] := [];
symSet[11, 4] := [];
symSet[11, 5] := [];
symSet[12, 0] := [];
symSet[12, 1] := [returnSym-16, defaultSym-16, catchSym-16, deleteSym-16, 
                    thenSym-16, forSym-16];
symSet[12, 2] := [];
symSet[12, 3] := [];
symSet[12, 4] := [];
symSet[12, 5] := [];
symSet[13, 0] := [_IdentifierSym, _NumberSym, DQuotStringSym, 
                    SQuotStringSym];
symSet[13, 1] := [returnSym-16, defaultSym-16, catchSym-16, deleteSym-16, 
                    thenSym-16, forSym-16];
symSet[13, 2] := [];
symSet[13, 3] := [];
symSet[13, 4] := [];
symSet[13, 5] := [];
end; {InitSymSet}

end { JScriptGrammar }.    
