unit CSSGrammar;




{==============================================================================
CSSGrammar
0.0.0.0
Date of Generation: 07/03/2020 19:18
Comment: CSS parser.
Author: Martin Harvey
Copyright: (c) Martin Harvey

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,Trackables,CommonNodes,CSSNodes;



const
maxT = 46;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  ECSSGrammar = class(Exception);
  TCSSGrammar = class;

  TCSSGrammarScanner = class(TCocoRScanner)
  private
    FOwner : TCSSGrammar;
function CharInIgnoreSet(const Ch : AnsiChar) : boolean;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TCSSGrammar read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TCSSGrammarScanner }

  TCSSGrammar = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..12] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : AnsiString;
    function GetVersionStr : AnsiString;
    procedure SetVersion(const Value : AnsiString);
    function GetVersionInfo : AnsiString;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure __function (out A: TCSSAtom);
    procedure _hexcolor (out A: TCSSAtom);
    procedure _bare_term (out A: TCSSAtom);
    procedure _bare_term_qualifiable (out E: TCSSExpr);
    procedure _term (out E: TCSSExpr);
    procedure _unary_operator (out E: TCSSExpr);
    procedure _operator (out E: TCSSExpr);
    procedure _expr (out E: TCSSExpr);
    procedure _funcbody (out B: TCSSFuncBody);
    procedure _pseudo (out S: TCSSSelector);
    procedure _attrib (out S: TCSSSelector);
    procedure _class (out S: TCSSStringSelector);
    procedure _element_name (out S: TCSSStringSelector);
    procedure _simple_selector (out S: TCSSSelector);
    procedure _combinator (out S: TCSSSelector);
    procedure _medium (out Decl: TCSSDeclaration);
    procedure __PERCENTAGE (out A: TCSSAtom);
    procedure __NUMBER (out A: TCSSAtom);
    procedure _selector (out S: TCSSSelector);
    procedure _pseudo_page (out A: TCSSAtom);
    procedure _declaration (out D: TCSSDeclaration);
    procedure _inner_media_decl (out AtDecl: TCSSAtDecl);
    procedure _media_list (out L: TCSSList);
    procedure __URI (out A: TCSSAtom);
    procedure __STRING (out A: TCSSAtom);
    procedure _font (out AtDecl: TCSSAtDecl);
    procedure _page (out AtDecl: TCSSAtDecl);
    procedure _media (out AtDecl: TCSSAtDecl);
    procedure _ruleset (out AtDecl: TCSSAtDecl);
    procedure _import (out AtDecl: TCSSAtDecl);
    procedure _stylesheet (S: TCSSScript);
    procedure _CSSGrammar;

  private
    FParentObject: TObject;

  protected
    {$IFDEF DEBUG_TOKENS}
    procedure DebugLogToken(Sender : TObject; var CurrentInputSymbol : integer);
{$ENDIF}
    procedure AbortParse;
    procedure InsertAtDeclInScript(S: TCSSScript; AtDecl: TCSSAtDecl);

    procedure InsertFuncBodyIntoAtom(A: TCSSAtom; B: TCSSFuncBody);

    procedure InsertExprIntoExpr(E1, E2: TCSSExpr);

    procedure InsertFuncBodyIntoFuncBody(B1, B2: TCSSFuncBody);

    procedure InsertFuncBodyIntoSelector(S: TCSSSelector; B: TCSSFuncBody);
    procedure InsertSelectorIntoSelector(S1, S2: TCSSSelector);

    procedure InsertValIntoDecl(D: TCSSDeclaration; V: TCSSExpr);
    procedure InsertAtDeclIntoDecl(D:TCSSDeclaration; AD: TCSSAtDecl);

    procedure InsertListIntoAtDecl(AD: TCSSAtDecl; L:TCSSList);
    procedure InsertRulesetIntoAtDecl(AD: TCSSAtDecl; RS: TCSSAtDecl);
    procedure InsertAtomIntoAtDecl(AD: TCSSAtDecl; A: TCSSAtom);

    procedure InsertDeclIntoList(L: TCSSList; D: TCSSDeclaration);
    procedure InsertSelectorIntoList(L: TCSSList; S: TCSSSelector);

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString; override;
    procedure Execute; override;
    function GetScanner : TCSSGrammarScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : AnsiString read GetVersionStr;
    property VersionInfo : AnsiString read GetVersionInfo;

  public
    procedure SetLocation(N: TCSSNode);
    procedure ParseWarning(Code: integer; S: string);
    property ParentObject:TObject read FParentObject write FParentObject;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : AnsiString read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TCSSGrammar }

implementation
uses  HTMLParser,HTMLParseEvents,StrUtils,IOUtils,DLList,GlobalLog;



const

  EOFSYMB = 0;  CDOSym = 1;  CDCSym = 2;  INCLUDESSym = 3;  DASHMATCHSym = 4;
  STRINGSym = 5;  URISym = 6;  IDENTSym = 7;  FUNCSym = 8;  EMSSym = 9;
  EXSSym = 10;  LENGTHSym = 11;  RESOLUTIONSym = 12;  ANGLESym = 13;
  TIMESym = 14;  FREQSym = 15;  PERCENTAGESym = 16;  NUMBERSym = 17;
  HASHSym = 18;  IMPORTANT_SYMSym = 19;  SSym = 20;  PAGE_SYMSym = 21;
  MEDIA_SYMSym = 22;  IMPORT_SYMSym = 23;  CHARSET_SYMSym = 24;
  FONT_FACE_SYMSym = 25;  WEBKIT_KEYFRAMES_SYMSym = 26;  KEYFRAMES_SYMSym = 27;
  _lessSym = 28;  _semicolonSym = 29;  _lbraceSym = 30;  _rbraceSym = 31;
  _commaSym = 32;  _lparenSym = 33;  _rparenSym = 34;  _colonSym = 35;
  _plusSym = 36;  _greaterSym = 37;  _tildeSym = 38;  _pointSym = 39;
  _starSym = 40;  _lbrackSym = 41;  _equalSym = 42;  _rbrackSym = 43;
  _slashSym = 44;  _minusSym = 45;  NOSYMB = 46;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
{ Arbitrary code }
{

Copyright © 2020 Martin Harvey <martin_c_harvey@hotmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

}

procedure TCSSGrammar.ParseWarning(Code: integer; S: string);
var
  Sc: TCSSGrammarScanner;
begin
  Sc := (Scanner as TCSSGrammarScanner);
  if Assigned(ParentObject) and (ParentObject is THTMLParseItem) then
  begin
    (ParentObject as THTMLParseItem).EventList.Add(
      TParseEvent.CreateFromParseWarning(
      Sc.NextSymbol.Col, Sc.NextSymbol.Line, Code, ErrorStr(Code, AnsiString(S)) + AnsiString(S), self));
  end;
end;

procedure TCSSGrammar.SetLocation(N: TCSSNode);
begin
  N.Line := (Scanner as TCSSGrammarScanner).CurrentSymbol.Line;
  N.Col := (Scanner as TCSSGrammarScanner).CurrentSymbol.Col;
end;

{$IFDEF DEBUG_TOKENS}
procedure TCSSGrammar.DebugLogToken(Sender : TObject; var CurrentInputSymbol : integer);
var
  LogStr: AnsiString;
  LexStr: AnsiString;
  DbgLexChar: AnsiString;
begin
  LexStr := LexString;
  if Length(LexStr) > 0 then
    DbgLexChar := AnsiString(IntToStr(Byte(LexString[1])) + ' ')
  else
    DbgLexChar := '';

  LogStr := AnsiString(IntToStr(CurrentInputSymbol) + ' : ' + DbgLexChar +  LexString + CHR(13) + CHR(10));
  GLogLog(SV_TRACE, LogStr);
end;

{$ENDIF}

procedure TCSSGrammar.AbortParse;
begin
  raise EParseAbort.Create(ErrorStr(1001, ''),
                (Scanner as TCSSGrammarScanner).NextSymbol.Line,
                (Scanner as TCSSGrammarScanner).NextSymbol.Col);
end;

procedure TCSSGrammar.InsertAtDeclInScript(S: TCSSScript; AtDecl: TCSSAtDecl);
begin
  if not Assigned(S) or not Assigned(AtDecl) then
    AbortParse;
  Assert(S is TCSSScript);
  Assert(AtDecl is TCSSAtDecl);
  DLListInsertTail(@S.ContainedListHead, @AtDecl.SiblingListEntry);
end;

procedure TCSSGrammar.InsertFuncBodyIntoAtom(A: TCSSAtom; B: TCSSFuncBody);
begin
  if not Assigned(A) or not Assigned(B) then
    AbortParse;
  Assert(A is TCSSAtom);
  Assert(B is TCSSFuncBody);
  Assert(A.AtomType = atFunc);
  DLListInsertTail(@A.ContainedListHead, @B.SiblingListEntry);
end;

procedure TCSSGrammar.InsertExprIntoExpr(E1, E2: TCSSExpr);
begin
  if not Assigned(E1) or not Assigned(E2) then
    AbortParse;
  Assert(E1 is TCSSExpr);
  Assert(E2 is TCSSExpr);
  DLListInsertTail(@E1.ContainedListHead, @E2.SiblingListEntry);
end;

procedure TCSSGrammar.InsertFuncBodyIntoFuncBody(B1, B2: TCSSFuncBody);
begin
  if not Assigned(B1) or not Assigned(B2) then
    AbortParse;
  Assert(B1 is TCSSFuncBody);
  Assert(B2 is TCSSFuncBody);
  DLListInsertTail(@B1.ContainedListHead, @B2.SiblingListEntry);
end;

procedure TCSSGrammar.InsertFuncBodyIntoSelector(S: TCSSSelector; B: TCSSFuncBody);
begin
  if not Assigned(S) or not Assigned(B) then
    AbortParse;
  Assert(S is TCSSSelector);
  Assert(B is TCSSFuncBody);
  DLListInsertTail(@S.ContainedListHead, @B.SiblingListEntry);
end;

procedure TCSSGrammar.InsertSelectorIntoSelector(S1, S2: TCSSSelector);
begin
  if not Assigned(S1) or not Assigned(S2) then
    AbortParse;
  Assert(S1 is TCSSSelector);
  Assert(S2 is TCSSSelector);
  DLListInsertTail(@S1.ContainedListHead, @S2.SiblingListEntry);
end;

procedure TCSSGrammar.InsertValIntoDecl(D: TCSSDeclaration; V: TCSSExpr);
begin
  if not Assigned(D) or not Assigned(V) then
    AbortParse;
  Assert(D is TCSSDeclaration);
  Assert(V is TCSSExpr);
  DLListInsertTail(@D.ContainedListHead, @V.SiblingListEntry);
end;

procedure TCSSGrammar.InsertAtDeclIntoDecl(D:TCSSDeclaration; AD: TCSSAtDecl);
begin
  if not Assigned(D) or not Assigned(AD) then
    AbortParse;
  Assert(D is TCSSDeclaration);
  Assert(AD is TCSSAtDecl);
  DLListInsertTail(@D.ContainedListHead, @AD.SiblingListEntry);
end;

procedure TCSSGrammar.InsertListIntoAtDecl(AD: TCSSAtDecl; L:TCSSList);
begin
  if not Assigned(AD) or not Assigned(L) then
    AbortParse;
  Assert(AD is TCSSAtDecl);
  Assert(L is TCSSList);
  DLListInsertTail(@AD.ContainedListHead, @L.SiblingListEntry);
end;

procedure TCSSGrammar.InsertRulesetIntoAtDecl(AD: TCSSAtDecl; RS: TCSSAtDecl);
begin
  if not Assigned(AD) or not Assigned(RS) then
    AbortParse;
  Assert(AD is TCSSAtDecl);
  Assert(RS is TCSSAtDecl);
  DLListInsertTail(@AD.ContainedListHead, @RS.SiblingListEntry);
end;

procedure TCSSGrammar.InsertAtomIntoAtDecl(AD: TCSSAtDecl; A: TCSSAtom);
begin
  if not Assigned(AD) or not Assigned(A) then
    AbortParse;
  Assert(AD is TCSSAtDecl);
  Assert(A is TCSSAtom);
  DLListInsertTail(@AD.ContainedListHead, @A.SiblingListEntry);
end;

procedure TCSSGrammar.InsertDeclIntoList(L: TCSSList; D: TCSSDeclaration);
begin
  if not Assigned(L) or not Assigned(D) then
    AbortParse;
  Assert(L is TCSSList);
  Assert(D is TCSSDeclaration);
  Assert((L.ListType = cltRulesetDeclList) or (L.ListType = cltMediaList));
  DLListInsertTail(@L.ContainedListHead, @D.SiblingListEntry);
end;

procedure TCSSGrammar.InsertSelectorIntoList(L: TCSSList; S: TCSSSelector);
begin
  if not Assigned(L) or not Assigned(S) then
    AbortParse;
  Assert(L is TCSSList);
  Assert(S is TCSSSelector);
  Assert(L.Listtype = cltSelectorList);
  DLListInsertTail(@L.ContainedListHead, @S.SiblingListEntry);
end;



{ --------------------------------------------------------------------------- }
{ ---- implementation for TCSSGrammarScanner ---- }

procedure TCSSGrammarScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TCSSGrammarScanner.Comment : boolean;
var
  level : integer;
  StartCommentCh: AnsiChar;
  oldLineStart : longint;
  CommentStr : AnsiString;
begin
StartCommentCh := CurrInputCh;
  level := 1;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
level := level -  1;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
end;  { Comment }

function TCSSGrammarScanner.CharInIgnoreSet(const Ch : AnsiChar) : boolean;
begin
Result := FALSE;
end; {CharInIgnoreSet}


procedure TCSSGrammarScanner.Get(var sym : integer);
var
  state : integer;
  label __start_get;
 begin   {Get}
__start_get:
if NumEOLInComment > 0 then
begin
  BufferPosition := BufferPosition - 1;
  NumEOLInComment := NumEOLInComment - 1;
  CurrInputCh := _CR;
end;
while CharInIgnoreSet(CurrInputCh) do
  NextCh;
if ((CurrInputCh = '/')) AND Comment then goto __start_get;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if (CurrInputCh = '!') then
begin
state := 2; 
end
else
begin
sym := _lessSym;
exit;
end;
   2: if (CurrInputCh = '-') then
begin
state := 3; 
end
else
begin
  sym := _noSym;
exit;
end;
   3: if (CurrInputCh = '-') then
begin
state := 4; 
end
else
begin
  sym := _noSym;
exit;
end;
   4: begin
sym := CDOSym;
exit;
end;
   5: if (CurrInputCh = '-') then
begin
state := 6; 
end
else
begin
  sym := _noSym;
exit;
end;
   6: if (CurrInputCh = '-') then
begin
state := 7; 
end
else
begin
  sym := _noSym;
exit;
end;
   7: if (CurrInputCh = '>') then
begin
state := 9; 
end
else
begin
  sym := _noSym;
exit;
end;
   8: if (CurrInputCh = '/') then
begin
state := 5; 
end
else
begin
sym := _slashSym;
exit;
end;
   9: begin
sym := CDCSym;
exit;
end;
  10: if (CurrInputCh = '=') then
begin
state := 11; 
end
else
begin
sym := _tildeSym;
exit;
end;
  11: begin
sym := INCLUDESSym;
exit;
end;
  12: if (CurrInputCh = '=') then
begin
state := 13; 
end
else
begin
  sym := _noSym;
exit;
end;
  13: begin
sym := DASHMATCHSym;
exit;
end;
  14: if ((CurrInputCh = '"')) then
begin
state := 20; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  15: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 16; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 14; 
end
else
begin
  sym := _noSym;
exit;
end;
  16: if ((CurrInputCh = '"')) then
begin
state := 20; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 14; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 135; 
end
else if (CurrInputCh = '\') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  17: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 20; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  18: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 19; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 17; 
end
else
begin
  sym := _noSym;
exit;
end;
  19: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 20; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 17; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 139; 
end
else if (CurrInputCh = '\') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  20: begin
sym := STRINGSym;
exit;
end;
  21: if ((CurrInputCh = '"')) then
begin
state := 22; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 143; 
end
else
begin
  sym := _noSym;
exit;
end;
  22: if (CurrInputCh = ')') then
begin
state := 25; 
end
else
begin
  sym := _noSym;
exit;
end;
  23: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 22; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 148; 
end
else
begin
  sym := _noSym;
exit;
end;
  24: if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '(') OR
(CurrInputCh >= '*')) then
begin
 
end
else if (CurrInputCh = ')') then
begin
state := 25; 
end
else
begin
  sym := _noSym;
exit;
end;
  25: begin
sym := URISym;
exit;
end;
  26: begin
sym := FUNCSym;
exit;
end;
  27: if (CurrInputCh = 'm') then
begin
state := 28; 
end
else
begin
  sym := _noSym;
exit;
end;
  28: begin
sym := EMSSym;
exit;
end;
  29: begin
sym := EXSSym;
exit;
end;
  30: if (CurrInputCh = '\') then
begin
state := 31; 
end
else
begin
sym := LENGTHSym;
exit;
end;
  31: if (CurrInputCh = '0') then
begin
state := 32; 
end
else
begin
  sym := _noSym;
exit;
end;
  32: if (CurrInputCh = '/') then
begin
state := 35; 
end
else
begin
  sym := _noSym;
exit;
end;
  33: if (CurrInputCh = 'm') then
begin
state := 30; 
end
else
begin
  sym := _noSym;
exit;
end;
  34: if (CurrInputCh = 'n') then
begin
state := 30; 
end
else
begin
  sym := _noSym;
exit;
end;
  35: begin
sym := LENGTHSym;
exit;
end;
  36: if (CurrInputCh = '\') then
begin
state := 37; 
end
else
begin
sym := RESOLUTIONSym;
exit;
end;
  37: if (CurrInputCh = '0') then
begin
state := 38; 
end
else
begin
  sym := _noSym;
exit;
end;
  38: if (CurrInputCh = '/') then
begin
state := 40; 
end
else
begin
  sym := _noSym;
exit;
end;
  39: if (CurrInputCh = 'x') then
begin
state := 36; 
end
else
begin
  sym := _noSym;
exit;
end;
  40: begin
sym := RESOLUTIONSym;
exit;
end;
  41: if (CurrInputCh = 'g') then
begin
state := 46; 
end
else
begin
  sym := _noSym;
exit;
end;
  42: if (CurrInputCh = 'd') then
begin
state := 46; 
end
else
begin
  sym := _noSym;
exit;
end;
  43: if (CurrInputCh = 'r') then
begin
state := 44; 
end
else
begin
  sym := _noSym;
exit;
end;
  44: if (CurrInputCh = 'a') then
begin
state := 45; 
end
else
begin
  sym := _noSym;
exit;
end;
  45: if (CurrInputCh = 'd') then
begin
state := 46; 
end
else
begin
  sym := _noSym;
exit;
end;
  46: begin
sym := ANGLESym;
exit;
end;
  47: begin
sym := TIMESym;
exit;
end;
  48: if (CurrInputCh = 'h') then
begin
state := 49; 
end
else
begin
  sym := _noSym;
exit;
end;
  49: if (CurrInputCh = 'z') then
begin
state := 51; 
end
else
begin
  sym := _noSym;
exit;
end;
  50: if (CurrInputCh = 'z') then
begin
state := 51; 
end
else
begin
  sym := _noSym;
exit;
end;
  51: begin
sym := FREQSym;
exit;
end;
  52: begin
sym := PERCENTAGESym;
exit;
end;
  53: if (CurrInputCh = '0') then
begin
state := 54; 
end
else
begin
  sym := _noSym;
exit;
end;
  54: if (CurrInputCh = '/') then
begin
state := 55; 
end
else
begin
  sym := _noSym;
exit;
end;
  55: begin
sym := NUMBERSym;
exit;
end;
  56: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 57; 
end
else
begin
sym := HASHSym;
exit;
end;
  57: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 58; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 56; 
end
else
begin
  sym := _noSym;
exit;
end;
  58: if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 56; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 154; 
end
else if (CurrInputCh = '\') then
begin
state := 57; 
end
else
begin
sym := HASHSym;
exit;
end;
  59: if (CurrInputCh = 'i') then
begin
state := 60; 
end
else
begin
  sym := _noSym;
exit;
end;
  60: if (CurrInputCh = 'm') then
begin
state := 61; 
end
else
begin
  sym := _noSym;
exit;
end;
  61: if (CurrInputCh = 'p') then
begin
state := 62; 
end
else
begin
  sym := _noSym;
exit;
end;
  62: if (CurrInputCh = 'o') then
begin
state := 63; 
end
else
begin
  sym := _noSym;
exit;
end;
  63: if (CurrInputCh = 'r') then
begin
state := 64; 
end
else
begin
  sym := _noSym;
exit;
end;
  64: if (CurrInputCh = 't') then
begin
state := 65; 
end
else
begin
  sym := _noSym;
exit;
end;
  65: if (CurrInputCh = 'a') then
begin
state := 66; 
end
else
begin
  sym := _noSym;
exit;
end;
  66: if (CurrInputCh = 'n') then
begin
state := 67; 
end
else
begin
  sym := _noSym;
exit;
end;
  67: if (CurrInputCh = 't') then
begin
state := 68; 
end
else
begin
  sym := _noSym;
exit;
end;
  68: begin
sym := IMPORTANT_SYMSym;
exit;
end;
  69: begin
sym := SSym;
exit;
end;
  70: if (CurrInputCh = 'a') then
begin
state := 71; 
end
else
begin
  sym := _noSym;
exit;
end;
  71: if (CurrInputCh = 'g') then
begin
state := 72; 
end
else
begin
  sym := _noSym;
exit;
end;
  72: if (CurrInputCh = 'e') then
begin
state := 73; 
end
else
begin
  sym := _noSym;
exit;
end;
  73: begin
sym := PAGE_SYMSym;
exit;
end;
  74: if (CurrInputCh = 'e') then
begin
state := 75; 
end
else
begin
  sym := _noSym;
exit;
end;
  75: if (CurrInputCh = 'd') then
begin
state := 76; 
end
else
begin
  sym := _noSym;
exit;
end;
  76: if (CurrInputCh = 'i') then
begin
state := 77; 
end
else
begin
  sym := _noSym;
exit;
end;
  77: if (CurrInputCh = 'a') then
begin
state := 78; 
end
else
begin
  sym := _noSym;
exit;
end;
  78: begin
sym := MEDIA_SYMSym;
exit;
end;
  79: if (CurrInputCh = 'm') then
begin
state := 80; 
end
else
begin
  sym := _noSym;
exit;
end;
  80: if (CurrInputCh = 'p') then
begin
state := 81; 
end
else
begin
  sym := _noSym;
exit;
end;
  81: if (CurrInputCh = 'o') then
begin
state := 82; 
end
else
begin
  sym := _noSym;
exit;
end;
  82: if (CurrInputCh = 'r') then
begin
state := 83; 
end
else
begin
  sym := _noSym;
exit;
end;
  83: if (CurrInputCh = 't') then
begin
state := 84; 
end
else
begin
  sym := _noSym;
exit;
end;
  84: begin
sym := IMPORT_SYMSym;
exit;
end;
  85: if (CurrInputCh = 'h') then
begin
state := 86; 
end
else
begin
  sym := _noSym;
exit;
end;
  86: if (CurrInputCh = 'a') then
begin
state := 87; 
end
else
begin
  sym := _noSym;
exit;
end;
  87: if (CurrInputCh = 'r') then
begin
state := 88; 
end
else
begin
  sym := _noSym;
exit;
end;
  88: if (CurrInputCh = 's') then
begin
state := 89; 
end
else
begin
  sym := _noSym;
exit;
end;
  89: if (CurrInputCh = 'e') then
begin
state := 90; 
end
else
begin
  sym := _noSym;
exit;
end;
  90: if (CurrInputCh = 't') then
begin
state := 91; 
end
else
begin
  sym := _noSym;
exit;
end;
  91: begin
sym := CHARSET_SYMSym;
exit;
end;
  92: if (CurrInputCh = 'o') then
begin
state := 93; 
end
else
begin
  sym := _noSym;
exit;
end;
  93: if (CurrInputCh = 'n') then
begin
state := 94; 
end
else
begin
  sym := _noSym;
exit;
end;
  94: if (CurrInputCh = 't') then
begin
state := 95; 
end
else
begin
  sym := _noSym;
exit;
end;
  95: if (CurrInputCh = '-') then
begin
state := 96; 
end
else
begin
  sym := _noSym;
exit;
end;
  96: if (CurrInputCh = 'f') then
begin
state := 97; 
end
else
begin
  sym := _noSym;
exit;
end;
  97: if (CurrInputCh = 'a') then
begin
state := 98; 
end
else
begin
  sym := _noSym;
exit;
end;
  98: if (CurrInputCh = 'c') then
begin
state := 99; 
end
else
begin
  sym := _noSym;
exit;
end;
  99: if (CurrInputCh = 'e') then
begin
state := 100; 
end
else
begin
  sym := _noSym;
exit;
end;
  100: begin
sym := FONT_FACE_SYMSym;
exit;
end;
  101: if (CurrInputCh = 'w') then
begin
state := 102; 
end
else
begin
  sym := _noSym;
exit;
end;
  102: if (CurrInputCh = 'e') then
begin
state := 103; 
end
else
begin
  sym := _noSym;
exit;
end;
  103: if (CurrInputCh = 'b') then
begin
state := 104; 
end
else
begin
  sym := _noSym;
exit;
end;
  104: if (CurrInputCh = 'k') then
begin
state := 105; 
end
else
begin
  sym := _noSym;
exit;
end;
  105: if (CurrInputCh = 'i') then
begin
state := 106; 
end
else
begin
  sym := _noSym;
exit;
end;
  106: if (CurrInputCh = 't') then
begin
state := 107; 
end
else
begin
  sym := _noSym;
exit;
end;
  107: if (CurrInputCh = '-') then
begin
state := 108; 
end
else
begin
  sym := _noSym;
exit;
end;
  108: if (CurrInputCh = 'k') then
begin
state := 109; 
end
else
begin
  sym := _noSym;
exit;
end;
  109: if (CurrInputCh = 'e') then
begin
state := 110; 
end
else
begin
  sym := _noSym;
exit;
end;
  110: if (CurrInputCh = 'y') then
begin
state := 111; 
end
else
begin
  sym := _noSym;
exit;
end;
  111: if (CurrInputCh = 'f') then
begin
state := 112; 
end
else
begin
  sym := _noSym;
exit;
end;
  112: if (CurrInputCh = 'r') then
begin
state := 113; 
end
else
begin
  sym := _noSym;
exit;
end;
  113: if (CurrInputCh = 'a') then
begin
state := 114; 
end
else
begin
  sym := _noSym;
exit;
end;
  114: if (CurrInputCh = 'm') then
begin
state := 115; 
end
else
begin
  sym := _noSym;
exit;
end;
  115: if (CurrInputCh = 'e') then
begin
state := 116; 
end
else
begin
  sym := _noSym;
exit;
end;
  116: if (CurrInputCh = 's') then
begin
state := 117; 
end
else
begin
  sym := _noSym;
exit;
end;
  117: begin
sym := WEBKIT_KEYFRAMES_SYMSym;
exit;
end;
  118: if (CurrInputCh = 'e') then
begin
state := 119; 
end
else
begin
  sym := _noSym;
exit;
end;
  119: if (CurrInputCh = 'y') then
begin
state := 120; 
end
else
begin
  sym := _noSym;
exit;
end;
  120: if (CurrInputCh = 'f') then
begin
state := 121; 
end
else
begin
  sym := _noSym;
exit;
end;
  121: if (CurrInputCh = 'r') then
begin
state := 122; 
end
else
begin
  sym := _noSym;
exit;
end;
  122: if (CurrInputCh = 'a') then
begin
state := 123; 
end
else
begin
  sym := _noSym;
exit;
end;
  123: if (CurrInputCh = 'm') then
begin
state := 124; 
end
else
begin
  sym := _noSym;
exit;
end;
  124: if (CurrInputCh = 'e') then
begin
state := 125; 
end
else
begin
  sym := _noSym;
exit;
end;
  125: if (CurrInputCh = 's') then
begin
state := 126; 
end
else
begin
  sym := _noSym;
exit;
end;
  126: begin
sym := KEYFRAMES_SYMSym;
exit;
end;
  127: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  128: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = 'e') then
begin
state := 159; 
end
else if (CurrInputCh = 'r') then
begin
state := 160; 
end
else if (CurrInputCh = 'E') then
begin
state := 161; 
end
else if (CurrInputCh = '.') then
begin
state := 162; 
end
else if (CurrInputCh = 'p') then
begin
state := 153; 
end
else if (CurrInputCh = 'c') then
begin
state := 33; 
end
else if (CurrInputCh = 'm') then
begin
state := 163; 
end
else if (CurrInputCh = 'i') then
begin
state := 34; 
end
else if (CurrInputCh = 'd') then
begin
state := 164; 
end
else if (CurrInputCh = 'g') then
begin
state := 43; 
end
else if (CurrInputCh = 's') then
begin
state := 47; 
end
else if (CurrInputCh = 'k') then
begin
state := 48; 
end
else if (CurrInputCh = 'h') then
begin
state := 50; 
end
else if (CurrInputCh = '%') then
begin
state := 52; 
end
else if (CurrInputCh = '\') then
begin
state := 53; 
end
else
begin
sym := NUMBERSym;
exit;
end;
  129: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '-') then
begin
state := 165; 
end
else if (CurrInputCh = '\') then
begin
state := 131; 
end
else
begin
sym := _minusSym;
exit;
end;
  130: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'q') OR
(CurrInputCh >= 's') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = 'r') then
begin
state := 166; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  131: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 167; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 127; 
end
else
begin
  sym := _noSym;
exit;
end;
  132: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 131; 
end
else
begin
sym := _starSym;
exit;
end;
  133: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 168; 
end
else
begin
sym := _pointSym;
exit;
end;
  134: if (CurrInputCh = 'p') then
begin
state := 70; 
end
else if (CurrInputCh = 'm') then
begin
state := 74; 
end
else if (CurrInputCh = 'i') then
begin
state := 79; 
end
else if (CurrInputCh = 'c') then
begin
state := 85; 
end
else if (CurrInputCh = 'f') then
begin
state := 92; 
end
else if (CurrInputCh = '-') then
begin
state := 101; 
end
else if (CurrInputCh = 'k') then
begin
state := 118; 
end
else
begin
  sym := _noSym;
exit;
end;
  135: if ((CurrInputCh = '"')) then
begin
state := 20; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 136; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 14; 
end
else if (CurrInputCh = '\') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  136: if ((CurrInputCh = '"')) then
begin
state := 20; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 137; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 14; 
end
else if (CurrInputCh = '\') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  137: if ((CurrInputCh = '"')) then
begin
state := 20; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 138; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 14; 
end
else if (CurrInputCh = '\') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  138: if ((CurrInputCh = '"')) then
begin
state := 20; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 14; 
end
else if (CurrInputCh = '\') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  139: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 20; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 140; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 17; 
end
else if (CurrInputCh = '\') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  140: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 20; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 141; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 17; 
end
else if (CurrInputCh = '\') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  141: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 20; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 142; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 17; 
end
else if (CurrInputCh = '\') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  142: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 20; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 17; 
end
else if (CurrInputCh = '\') then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  143: if ((CurrInputCh = '"')) then
begin
state := 169; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 21; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 170; 
end
else if (CurrInputCh = '\') then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
  144: if ((CurrInputCh = '"')) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 145; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 21; 
end
else if (CurrInputCh = '\') then
begin
state := 143; 
end
else
begin
  sym := _noSym;
exit;
end;
  145: if ((CurrInputCh = '"')) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 146; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 21; 
end
else if (CurrInputCh = '\') then
begin
state := 143; 
end
else
begin
  sym := _noSym;
exit;
end;
  146: if ((CurrInputCh = '"')) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 147; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 21; 
end
else if (CurrInputCh = '\') then
begin
state := 143; 
end
else
begin
  sym := _noSym;
exit;
end;
  147: if ((CurrInputCh = '"')) then
begin
state := 22; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 21; 
end
else if (CurrInputCh = '\') then
begin
state := 143; 
end
else
begin
  sym := _noSym;
exit;
end;
  148: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 171; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 23; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 172; 
end
else if (CurrInputCh = '\') then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
  149: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 150; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 23; 
end
else if (CurrInputCh = '\') then
begin
state := 148; 
end
else
begin
  sym := _noSym;
exit;
end;
  150: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 151; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 23; 
end
else if (CurrInputCh = '\') then
begin
state := 148; 
end
else
begin
  sym := _noSym;
exit;
end;
  151: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 152; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 23; 
end
else if (CurrInputCh = '\') then
begin
state := 148; 
end
else
begin
  sym := _noSym;
exit;
end;
  152: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 22; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 23; 
end
else if (CurrInputCh = '\') then
begin
state := 148; 
end
else
begin
  sym := _noSym;
exit;
end;
  153: if ((CurrInputCh = 'c') OR
(CurrInputCh = 't') OR
(CurrInputCh = 'x')) then
begin
state := 30; 
end
else
begin
  sym := _noSym;
exit;
end;
  154: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 155; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 56; 
end
else if (CurrInputCh = '\') then
begin
state := 57; 
end
else
begin
sym := HASHSym;
exit;
end;
  155: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 156; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 56; 
end
else if (CurrInputCh = '\') then
begin
state := 57; 
end
else
begin
sym := HASHSym;
exit;
end;
  156: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 157; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 56; 
end
else if (CurrInputCh = '\') then
begin
state := 57; 
end
else
begin
sym := HASHSym;
exit;
end;
  157: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 56; 
end
else if (CurrInputCh = '\') then
begin
state := 57; 
end
else
begin
sym := HASHSym;
exit;
end;
  158: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 176; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 127; 
end
else
begin
  sym := _noSym;
exit;
end;
  159: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 177; 
end
else if (CurrInputCh = 'm') then
begin
state := 173; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 178; 
end
else if (CurrInputCh = 'x') then
begin
state := 174; 
end
else
begin
  sym := _noSym;
exit;
end;
  160: if (CurrInputCh = 'e') then
begin
state := 27; 
end
else if (CurrInputCh = 'a') then
begin
state := 42; 
end
else
begin
  sym := _noSym;
exit;
end;
  161: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 177; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 178; 
end
else
begin
  sym := _noSym;
exit;
end;
  162: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 179; 
end
else
begin
  sym := _noSym;
exit;
end;
  163: if (CurrInputCh = 'm') then
begin
state := 30; 
end
else if (CurrInputCh = 's') then
begin
state := 47; 
end
else
begin
  sym := _noSym;
exit;
end;
  164: if (CurrInputCh = 'p') then
begin
state := 175; 
end
else if (CurrInputCh = 'e') then
begin
state := 41; 
end
else
begin
  sym := _noSym;
exit;
end;
  165: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '>') then
begin
state := 9; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  166: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'k') OR
(CurrInputCh >= 'm') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = 'l') then
begin
state := 180; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  167: if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 181; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  168: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = 'e') then
begin
state := 159; 
end
else if (CurrInputCh = 'r') then
begin
state := 160; 
end
else if (CurrInputCh = 'E') then
begin
state := 161; 
end
else if (CurrInputCh = 'p') then
begin
state := 153; 
end
else if (CurrInputCh = 'c') then
begin
state := 33; 
end
else if (CurrInputCh = 'm') then
begin
state := 163; 
end
else if (CurrInputCh = 'i') then
begin
state := 34; 
end
else if (CurrInputCh = 'd') then
begin
state := 164; 
end
else if (CurrInputCh = 'g') then
begin
state := 43; 
end
else if (CurrInputCh = 's') then
begin
state := 47; 
end
else if (CurrInputCh = 'k') then
begin
state := 48; 
end
else if (CurrInputCh = 'h') then
begin
state := 50; 
end
else if (CurrInputCh = '%') then
begin
state := 52; 
end
else if (CurrInputCh = '\') then
begin
state := 53; 
end
else
begin
sym := NUMBERSym;
exit;
end;
  169: if ((CurrInputCh = '"')) then
begin
state := 22; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '(') OR
(CurrInputCh >= '*') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 21; 
end
else if (CurrInputCh = '\') then
begin
state := 143; 
end
else if (CurrInputCh = ')') then
begin
state := 182; 
end
else
begin
  sym := _noSym;
exit;
end;
  170: if ((CurrInputCh = '"')) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 144; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 21; 
end
else if (CurrInputCh = '\') then
begin
state := 143; 
end
else
begin
  sym := _noSym;
exit;
end;
  171: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 22; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh = '(') OR
(CurrInputCh >= '*') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 23; 
end
else if (CurrInputCh = ')') then
begin
state := 183; 
end
else if (CurrInputCh = '\') then
begin
state := 148; 
end
else
begin
  sym := _noSym;
exit;
end;
  172: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 149; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '/') OR
(CurrInputCh >= ':') AND (CurrInputCh <= '@') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']') AND (CurrInputCh <= '`') OR
(CurrInputCh >= 'g')) then
begin
state := 23; 
end
else if (CurrInputCh = '\') then
begin
state := 148; 
end
else
begin
  sym := _noSym;
exit;
end;
  173: if (CurrInputCh = 's') then
begin
state := 28; 
end
else
begin
sym := EMSSym;
exit;
end;
  174: if (CurrInputCh = 's') then
begin
state := 29; 
end
else
begin
sym := EXSSym;
exit;
end;
  175: if (CurrInputCh = 'i') then
begin
state := 36; 
end
else if (CurrInputCh = 'p') then
begin
state := 39; 
end
else
begin
  sym := _noSym;
exit;
end;
  176: if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 184; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  177: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = 'e') then
begin
state := 185; 
end
else if (CurrInputCh = 'r') then
begin
state := 160; 
end
else if (CurrInputCh = 'p') then
begin
state := 153; 
end
else if (CurrInputCh = 'c') then
begin
state := 33; 
end
else if (CurrInputCh = 'm') then
begin
state := 163; 
end
else if (CurrInputCh = 'i') then
begin
state := 34; 
end
else if (CurrInputCh = 'd') then
begin
state := 164; 
end
else if (CurrInputCh = 'g') then
begin
state := 43; 
end
else if (CurrInputCh = 's') then
begin
state := 47; 
end
else if (CurrInputCh = 'k') then
begin
state := 48; 
end
else if (CurrInputCh = 'h') then
begin
state := 50; 
end
else if (CurrInputCh = '%') then
begin
state := 52; 
end
else if (CurrInputCh = '\') then
begin
state := 53; 
end
else
begin
sym := NUMBERSym;
exit;
end;
  178: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 177; 
end
else
begin
  sym := _noSym;
exit;
end;
  179: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = 'e') then
begin
state := 159; 
end
else if (CurrInputCh = 'r') then
begin
state := 160; 
end
else if (CurrInputCh = 'E') then
begin
state := 161; 
end
else if (CurrInputCh = 'p') then
begin
state := 153; 
end
else if (CurrInputCh = 'c') then
begin
state := 33; 
end
else if (CurrInputCh = 'm') then
begin
state := 163; 
end
else if (CurrInputCh = 'i') then
begin
state := 34; 
end
else if (CurrInputCh = 'd') then
begin
state := 164; 
end
else if (CurrInputCh = 'g') then
begin
state := 43; 
end
else if (CurrInputCh = 's') then
begin
state := 47; 
end
else if (CurrInputCh = 'k') then
begin
state := 48; 
end
else if (CurrInputCh = 'h') then
begin
state := 50; 
end
else if (CurrInputCh = '%') then
begin
state := 52; 
end
else if (CurrInputCh = '\') then
begin
state := 53; 
end
else
begin
sym := NUMBERSym;
exit;
end;
  180: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '(') then
begin
state := 186; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else
begin
sym := IDENTSym;
exit;
end;
  181: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 187; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  182: if ((CurrInputCh = '"')) then
begin
state := 22; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 21; 
end
else if (CurrInputCh = '\') then
begin
state := 143; 
end
else
begin
sym := URISym;
exit;
end;
  183: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 22; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 23; 
end
else if (CurrInputCh = '\') then
begin
state := 148; 
end
else
begin
sym := URISym;
exit;
end;
  184: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 188; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  185: if (CurrInputCh = 'm') then
begin
state := 173; 
end
else if (CurrInputCh = 'x') then
begin
state := 174; 
end
else
begin
  sym := _noSym;
exit;
end;
  186: if ((CurrInputCh = '"')) then
begin
state := 21; 
end
else if ((CurrInputCh = AnsiChar(39))) then
begin
state := 23; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '&') OR
(CurrInputCh = '(') OR
(CurrInputCh >= '*')) then
begin
state := 24; 
end
else
begin
sym := FUNCSym;
exit;
end;
  187: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 189; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  188: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 190; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  189: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 191; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  190: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 192; 
end
else if ((CurrInputCh = '-') OR
(CurrInputCh >= 'G') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'g') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  191: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  192: if ((CurrInputCh = '-') OR
(CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z') OR
(CurrInputCh >= AnsiChar(128))) then
begin
state := 127; 
end
else if (CurrInputCh = '\') then
begin
state := 158; 
end
else if (CurrInputCh = '(') then
begin
state := 26; 
end
else
begin
sym := IDENTSym;
exit;
end;
  193: begin
sym := _semicolonSym;
exit;
end;
  194: begin
sym := _lbraceSym;
exit;
end;
  195: begin
sym := _rbraceSym;
exit;
end;
  196: begin
sym := _commaSym;
exit;
end;
  197: begin
sym := _lparenSym;
exit;
end;
  198: begin
sym := _rparenSym;
exit;
end;
  199: begin
sym := _colonSym;
exit;
end;
  200: begin
sym := _plusSym;
exit;
end;
  201: begin
sym := _greaterSym;
exit;
end;
  202: begin
sym := _lbrackSym;
exit;
end;
  203: begin
sym := _equalSym;
exit;
end;
  204: begin
sym := _rbrackSym;
exit;
end;
  205: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TCSSGrammarScanner.Create;
begin
  inherited;
CurrentCh := CharAt;
fStartState[  0] := 205; fStartState[  1] := 206; fStartState[  2] := 206; fStartState[  3] := 206; 
fStartState[  4] := 206; fStartState[  5] := 206; fStartState[  6] := 206; fStartState[  7] := 206; 
fStartState[  8] := 206; fStartState[  9] := 69; fStartState[ 10] := 69; fStartState[ 11] := 206; 
fStartState[ 12] := 206; fStartState[ 13] := 69; fStartState[ 14] := 206; fStartState[ 15] := 206; 
fStartState[ 16] := 206; fStartState[ 17] := 206; fStartState[ 18] := 206; fStartState[ 19] := 206; 
fStartState[ 20] := 206; fStartState[ 21] := 206; fStartState[ 22] := 206; fStartState[ 23] := 206; 
fStartState[ 24] := 206; fStartState[ 25] := 206; fStartState[ 26] := 206; fStartState[ 27] := 206; 
fStartState[ 28] := 206; fStartState[ 29] := 206; fStartState[ 30] := 206; fStartState[ 31] := 206; 
fStartState[ 32] := 69; fStartState[ 33] := 59; fStartState[ 34] := 14; fStartState[ 35] := 56; 
fStartState[ 36] := 206; fStartState[ 37] := 206; fStartState[ 38] := 206; fStartState[ 39] := 17; 
fStartState[ 40] := 197; fStartState[ 41] := 198; fStartState[ 42] := 132; fStartState[ 43] := 200; 
fStartState[ 44] := 196; fStartState[ 45] := 129; fStartState[ 46] := 133; fStartState[ 47] :=  8; 
fStartState[ 48] := 128; fStartState[ 49] := 128; fStartState[ 50] := 128; fStartState[ 51] := 128; 
fStartState[ 52] := 128; fStartState[ 53] := 128; fStartState[ 54] := 128; fStartState[ 55] := 128; 
fStartState[ 56] := 128; fStartState[ 57] := 128; fStartState[ 58] := 199; fStartState[ 59] := 193; 
fStartState[ 60] :=  1; fStartState[ 61] := 203; fStartState[ 62] := 201; fStartState[ 63] := 206; 
fStartState[ 64] := 134; fStartState[ 65] := 127; fStartState[ 66] := 127; fStartState[ 67] := 127; 
fStartState[ 68] := 127; fStartState[ 69] := 127; fStartState[ 70] := 127; fStartState[ 71] := 127; 
fStartState[ 72] := 127; fStartState[ 73] := 127; fStartState[ 74] := 127; fStartState[ 75] := 127; 
fStartState[ 76] := 127; fStartState[ 77] := 127; fStartState[ 78] := 127; fStartState[ 79] := 127; 
fStartState[ 80] := 127; fStartState[ 81] := 127; fStartState[ 82] := 127; fStartState[ 83] := 127; 
fStartState[ 84] := 127; fStartState[ 85] := 127; fStartState[ 86] := 127; fStartState[ 87] := 127; 
fStartState[ 88] := 127; fStartState[ 89] := 127; fStartState[ 90] := 127; fStartState[ 91] := 202; 
fStartState[ 92] := 131; fStartState[ 93] := 204; fStartState[ 94] := 206; fStartState[ 95] := 127; 
fStartState[ 96] := 206; fStartState[ 97] := 127; fStartState[ 98] := 127; fStartState[ 99] := 127; 
fStartState[100] := 127; fStartState[101] := 127; fStartState[102] := 127; fStartState[103] := 127; 
fStartState[104] := 127; fStartState[105] := 127; fStartState[106] := 127; fStartState[107] := 127; 
fStartState[108] := 127; fStartState[109] := 127; fStartState[110] := 127; fStartState[111] := 127; 
fStartState[112] := 127; fStartState[113] := 127; fStartState[114] := 127; fStartState[115] := 127; 
fStartState[116] := 127; fStartState[117] := 130; fStartState[118] := 127; fStartState[119] := 127; 
fStartState[120] := 127; fStartState[121] := 127; fStartState[122] := 127; fStartState[123] := 194; 
fStartState[124] := 12; fStartState[125] := 195; fStartState[126] := 10; fStartState[127] := 206; 
fStartState[128] := 127; fStartState[129] := 127; fStartState[130] := 127; fStartState[131] := 127; 
fStartState[132] := 127; fStartState[133] := 127; fStartState[134] := 127; fStartState[135] := 127; 
fStartState[136] := 127; fStartState[137] := 127; fStartState[138] := 127; fStartState[139] := 127; 
fStartState[140] := 127; fStartState[141] := 127; fStartState[142] := 127; fStartState[143] := 127; 
fStartState[144] := 127; fStartState[145] := 127; fStartState[146] := 127; fStartState[147] := 127; 
fStartState[148] := 127; fStartState[149] := 127; fStartState[150] := 127; fStartState[151] := 127; 
fStartState[152] := 127; fStartState[153] := 127; fStartState[154] := 127; fStartState[155] := 127; 
fStartState[156] := 127; fStartState[157] := 127; fStartState[158] := 127; fStartState[159] := 127; 
fStartState[160] := 127; fStartState[161] := 127; fStartState[162] := 127; fStartState[163] := 127; 
fStartState[164] := 127; fStartState[165] := 127; fStartState[166] := 127; fStartState[167] := 127; 
fStartState[168] := 127; fStartState[169] := 127; fStartState[170] := 127; fStartState[171] := 127; 
fStartState[172] := 127; fStartState[173] := 127; fStartState[174] := 127; fStartState[175] := 127; 
fStartState[176] := 127; fStartState[177] := 127; fStartState[178] := 127; fStartState[179] := 127; 
fStartState[180] := 127; fStartState[181] := 127; fStartState[182] := 127; fStartState[183] := 127; 
fStartState[184] := 127; fStartState[185] := 127; fStartState[186] := 127; fStartState[187] := 127; 
fStartState[188] := 127; fStartState[189] := 127; fStartState[190] := 127; fStartState[191] := 127; 
fStartState[192] := 127; fStartState[193] := 127; fStartState[194] := 127; fStartState[195] := 127; 
fStartState[196] := 127; fStartState[197] := 127; fStartState[198] := 127; fStartState[199] := 127; 
fStartState[200] := 127; fStartState[201] := 127; fStartState[202] := 127; fStartState[203] := 127; 
fStartState[204] := 127; fStartState[205] := 127; fStartState[206] := 127; fStartState[207] := 127; 
fStartState[208] := 127; fStartState[209] := 127; fStartState[210] := 127; fStartState[211] := 127; 
fStartState[212] := 127; fStartState[213] := 127; fStartState[214] := 127; fStartState[215] := 127; 
fStartState[216] := 127; fStartState[217] := 127; fStartState[218] := 127; fStartState[219] := 127; 
fStartState[220] := 127; fStartState[221] := 127; fStartState[222] := 127; fStartState[223] := 127; 
fStartState[224] := 127; fStartState[225] := 127; fStartState[226] := 127; fStartState[227] := 127; 
fStartState[228] := 127; fStartState[229] := 127; fStartState[230] := 127; fStartState[231] := 127; 
fStartState[232] := 127; fStartState[233] := 127; fStartState[234] := 127; fStartState[235] := 127; 
fStartState[236] := 127; fStartState[237] := 127; fStartState[238] := 127; fStartState[239] := 127; 
fStartState[240] := 127; fStartState[241] := 127; fStartState[242] := 127; fStartState[243] := 127; 
fStartState[244] := 127; fStartState[245] := 127; fStartState[246] := 127; fStartState[247] := 127; 
fStartState[248] := 127; fStartState[249] := 127; fStartState[250] := 127; fStartState[251] := 127; 
fStartState[252] := 127; fStartState[253] := 127; fStartState[254] := 127; fStartState[255] := 127; 
end; {Create}


{ --------------------------------------------------------------------------- }
{ ---- implementation for TCSSGrammar ---- }

constructor TCSSGrammar.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TCSSGrammarScanner.Create;
  GetScanner.Owner := self;
FParseTracker := TTracker.Create;
{$IFDEF DEBUG_TOKENS}
    AfterGet := DebugLogToken;
{$ENDIF}
    FLangStr := 'CSS';

  InitSymSet;
end; {Create}

destructor TCSSGrammar.Destroy;
begin
  Scanner.Free;
FParseTracker.Free;

  inherited;
end; {Destroy}

function TCSSGrammar.ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'CDO expected';
   2 : Result := 'CDC expected';
   3 : Result := 'INCLUDES expected';
   4 : Result := 'DASHMATCH expected';
   5 : Result := 'STRING expected';
   6 : Result := 'URI expected';
   7 : Result := 'IDENT expected';
   8 : Result := 'FUNC expected';
   9 : Result := 'EMS expected';
  10 : Result := 'EXS expected';
  11 : Result := 'LENGTH expected';
  12 : Result := 'RESOLUTION expected';
  13 : Result := 'ANGLE expected';
  14 : Result := 'TIME expected';
  15 : Result := 'FREQ expected';
  16 : Result := 'PERCENTAGE expected';
  17 : Result := 'NUMBER expected';
  18 : Result := 'HASH expected';
  19 : Result := 'IMPORTANT_SYM expected';
  20 : Result := 'S expected';
  21 : Result := 'PAGE_SYM expected';
  22 : Result := 'MEDIA_SYM expected';
  23 : Result := 'IMPORT_SYM expected';
  24 : Result := 'CHARSET_SYM expected';
  25 : Result := 'FONT_FACE_SYM expected';
  26 : Result := 'WEBKIT_KEYFRAMES_SYM expected';
  27 : Result := 'KEYFRAMES_SYM expected';
  28 : Result := '"<" expected';
  29 : Result := '";" expected';
  30 : Result := '"{" expected';
  31 : Result := '"}" expected';
  32 : Result := '"," expected';
  33 : Result := '"(" expected';
  34 : Result := '")" expected';
  35 : Result := '":" expected';
  36 : Result := '"+" expected';
  37 : Result := '">" expected';
  38 : Result := '"~" expected';
  39 : Result := '"." expected';
  40 : Result := '"*" expected';
  41 : Result := '"[" expected';
  42 : Result := '"=" expected';
  43 : Result := '"]" expected';
  44 : Result := '"/" expected';
  45 : Result := '"-" expected';
  46 : Result := 'not expected';
  47 : Result := 'invalid bare_term';
  48 : Result := 'invalid bare_term_qualifiable';
  49 : Result := 'invalid bare_term_qualifiable';
  50 : Result := 'invalid unary_operator';
  51 : Result := 'invalid operator';
  52 : Result := 'invalid attrib';
  53 : Result := 'invalid element_name';
  54 : Result := 'invalid simple_selector';
  55 : Result := 'invalid combinator';
  56 : Result := 'invalid medium';
  57 : Result := 'invalid declaration';
  58 : Result := 'invalid inner_media_decl';
  59 : Result := 'invalid media';
  60 : Result := 'invalid ruleset';
  61 : Result := 'invalid import';
  62 : Result := 'invalid CSSGrammar';

1000: Result := 'Expected the "important" identifier here';
    1001: Result := 'Unable to continue after previous errors, aborting.';
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := AnsiString('Error: ' + AnsiString(IntToStr(ErrorCode)));
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TCSSGrammar.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;
  StreamPartRead := -1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TCSSGrammar.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TCSSGrammar.GetScanner : TCSSGrammarScanner;
begin
  Result := Scanner AS TCSSGrammarScanner;
end; {GetScanner}

function TCSSGrammar._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TCSSGrammar.__function (out  A:  TCSSAtom);var  B:  TCSSFuncBody;
begin
Expect(FUNCSym);
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.AtomType  :=  atFunc;
A.StrData  :=  LexString;
B  :=  nil;

_funcbody(B);
InsertFuncBodyIntoAtom(A,B);
Expect(_rparenSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._hexcolor (out  A:  TCSSAtom);begin
Expect(HASHSym);
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.AtomType  :=  atHexColor;
A.StrData  :=  LexString;

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._bare_term (out  A:  TCSSAtom);begin
if (fCurrentInputSymbol < 16) { prevent range error } AND
 (fCurrentInputSymbol IN [EMSSym, EXSSym, LENGTHSym, RESOLUTIONSym, ANGLESym, 
                    TIMESym, FREQSym])  then begin
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.StrData  :=  LexString;

case fCurrentInputSymbol of
  LENGTHSym : begin
Get;
A.AtomType  :=  atLength;
A.StrData  :=  LexString;

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  EMSSym : begin
Get;
A.AtomType  :=  atEms;
A.StrData  :=  LexString;

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  EXSSym : begin
Get;
A.AtomType  :=  atExs;
A.StrData  :=  LexString;

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  ANGLESym : begin
Get;
A.AtomType  :=  atAngle;
A.StrData  :=  LexString;

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  TIMESym : begin
Get;
A.AtomType  :=  atTime;
A.StrData  :=  LexString;

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  FREQSym : begin
Get;
A.AtomType  :=  atFreq;
A.StrData  :=  LexString;

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  RESOLUTIONSym : begin
Get;
A.AtomType  :=  atResolution;
A.StrData  :=  LexString;

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
end;
end else if _In(symSet[1], fCurrentInputSymbol) then begin
A  :=  nil;
case fCurrentInputSymbol of
  PERCENTAGESym : begin
__PERCENTAGE(A);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  NUMBERSym : begin
__NUMBER(A);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  STRINGSym : begin
__STRING(A);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  URISym : begin
__URI(A);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
    end;
  HASHSym : begin
_hexcolor(A);
    end;
  FUNCSym : begin
__function(A);
    end;
end;
end else begin SynError(47);
end;
end;

procedure TCSSGrammar._bare_term_qualifiable (out  E:  TCSSExpr);var  A:  TCSSAtom;  E2,  E3:  TCSSExpr;
begin
if (fCurrentInputSymbol = IDENTSym) then begin
E3  :=  nil;
Get;
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.AtomType  :=  atIdent;
A.StrData  :=  LexString;
if (fCurrentInputSymbol = _pointSym) then begin
Get;
E2  :=  TCSSExpr.CreateWithTracker(ParseTracker  as  TTracker);
E2.ExprType  :=  cetDotOperator;
_bare_term_qualifiable(E3);
InsertExprIntoExpr(E2,  A);
InsertExprIntoExpr(E2,  E3);
E  :=  E2;
end else if _In(symSet[2], fCurrentInputSymbol) then begin
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
E  :=  A;
end else begin SynError(48);
end;
end else if _In(symSet[3], fCurrentInputSymbol) then begin
_bare_term(A);
E  :=  A;
end else begin SynError(49);
end;
end;

procedure TCSSGrammar._term (out  E:  TCSSExpr);var  E2:  TCSSExpr;
begin
E  :=  nil;  E2  :=  nil;
if (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _minusSym) then begin
_unary_operator(E2);
end;
_bare_term_qualifiable(E);
if  Assigned(E2)  then
begin
   InsertExprIntoExpr(E2,  E);
   E  :=  E2;
end;
end;

procedure TCSSGrammar._unary_operator (out  E:  TCSSExpr);begin
E  :=  TCSSExpr.CreateWithTracker(ParseTracker  as  TTracker);
if (fCurrentInputSymbol = _minusSym) then begin
Get;
E.ExprType  :=  cetPlusOperator;
end else if (fCurrentInputSymbol = _plusSym) then begin
Get;
E.ExprType  :=  cetMinusOperator;
end else begin SynError(50);
end;
end;

procedure TCSSGrammar._operator (out  E:  TCSSExpr);begin
E  :=  TCSSExpr.CreateWithTracker(ParseTracker  as  TTracker);
if (fCurrentInputSymbol = _slashSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
E.ExprType  :=  cetSlashOperator;
end else if (fCurrentInputSymbol = _commaSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
E.ExprType  :=  cetCommaOperator;
end else begin SynError(51);
end;
end;

procedure TCSSGrammar._expr (out  E:  TCSSExpr);var  E2,  E3:  TCSSExpr;
begin
E  :=  nil;  E2  :=  nil;  E3  :=  nil;
_term(E);
while _In(symSet[4], fCurrentInputSymbol) do begin
E2  :=  nil;
if (fCurrentInputSymbol = _commaSym) OR
 (fCurrentInputSymbol = _slashSym) then begin
_operator(E2);
end;
_term(E3);
if  not  Assigned(E2)  then
begin
   E2  :=  TCSSExpr.CreateWithTracker(ParseTracker  as  TTracker);
   E2.ExprType  :=  cetTrailing;
end;
InsertExprIntoExpr(E2,  E);
InsertExprIntoExpr(E2,  E3);
E  :=  E2;

end;
end;

procedure TCSSGrammar._funcbody (out  B:  TCSSFuncBody);var  SubB,  SubB2:  TCSSFuncBody;
begin
B  :=  TCSSFuncBody.CreateWithTracker(ParseTracker  as  TTracker);
B.FuncType  :=  fbtFuncTop;
while _In(symSet[5], fCurrentInputSymbol) do begin
if _In(symSet[6], fCurrentInputSymbol) then begin
Get;
SubB  :=  TCSSFuncBody.CreateWithTracker(ParseTracker  as  TTracker);
SubB.FuncType  :=  fbtFuncText;
SubB.BodyData  :=  LexString;
InsertFuncBodyIntoFuncBody(B,  SubB);

end else if (fCurrentInputSymbol = FUNCSym) then begin
Get;
SubB  :=  TCSSFuncBody.CreateWithTracker(ParseTracker  as  TTracker);
SubB.FuncType  :=  fbtSubFunc;
SubB.SubFuncName  :=  LexString;
InsertFuncBodyIntoFuncBody(B,  SubB);

_funcbody(SubB2);
InsertFuncBodyIntoFuncBody(SubB,  SubB2);
Expect(_rparenSym);
end else begin
SubB  :=  TCSSFuncBody.CreateWithTracker(ParseTracker  as  TTracker);
SubB.FuncType  :=  fbtSubFunc;
InsertFuncBodyIntoFuncBody(B,  SubB);

Get;
_funcbody(SubB2);
InsertFuncBodyIntoFuncBody(SubB,  SubB2);
Expect(_rparenSym);
end;
end;
end;

procedure TCSSGrammar._pseudo (out  S:  TCSSSelector);var  S2:  TCSSStringSelector;  B:  TCSSFuncBody;
begin
S  :=  TCSSSelector.CreateWithTracker(ParseTracker  as  TTracker);
S.SelectorType  :=  cstPseudo;
S2  :=  nil;  B  :=  nil;

Expect(_colonSym);
if (fCurrentInputSymbol = IDENTSym) OR
 (fCurrentInputSymbol = FUNCSym) then begin
if (fCurrentInputSymbol = IDENTSym) then begin
Get;
S2  :=  TCSSStringSelector.CreateWithTracker(ParseTracker  as  TTracker);
S2.SelectorType  :=  cstSimple;
(S2  as  TCSSStringSelector).StringSelectorType  :=  sstIdent;
(S2  as  TCSSStringSelector).StrData  :=  LexString;
end else begin
Get;
S2  :=  TCSSStringSelector.CreateWithTracker(ParseTracker  as  TTracker);
S2.SelectorType  :=  cstSimple;
(S2  as  TCSSStringSelector).StringSelectorType  :=  sstFunc;
(S2  as  TCSSStringSelector).StrData  :=  LexString;
_funcbody(B);
InsertFuncBodyIntoSelector(S2,B);
Expect(_rparenSym);
end;
end;
if  Assigned(S2)  then  InsertSelectorIntoSelector(S,S2);
end;

procedure TCSSGrammar._attrib (out  S:  TCSSSelector);var  S2,  S3,  S4:  TCSSSelector;
begin
S  :=  TCSSSelector.CreateWithTracker(ParseTracker  as  TTracker);
S.SelectorType  :=  cstAttribSelector;
S2  :=  nil;  S3  :=  nil;  S4  :=  nil;

Expect(_lbrackSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
Expect(IDENTSym);
S2  :=  TCSSStringSelector.CreateWithTracker(ParseTracker  as  TTracker);
S2.SelectorType  :=  cstStringSelector;
(S2  as  TCSSStringSelector).StringSelectorType  :=  sstIdent;
(S2  as  TCSSStringSelector).StrData  :=  LexString;
if (fCurrentInputSymbol = _starSym) then begin
Get;
(S2  as  TCSSStringSelector).IdentStarred  :=  true;
end;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if (fCurrentInputSymbol = INCLUDESSym) OR
 (fCurrentInputSymbol = DASHMATCHSym) OR
 (fCurrentInputSymbol = _equalSym) then begin
S3  :=  TCSSSelector.CreateWithTracker(ParseTracker  as  TTRacker);
if (fCurrentInputSymbol = _equalSym) then begin
Get;
S3.SelectorType  :=  cstCombinatorEquals;
end else if (fCurrentInputSymbol = INCLUDESSym) then begin
Get;
S3.SelectorType  :=  cstCombinatorIncludes;
end else begin
Get;
S3.SelectorType  :=  cstCombinatorDashmatch;
end;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
S4  :=  TCSSStringSelector.CreateWithTracker(ParseTracker  as  TTracker);
S4.SelectorType  :=  cstStringSelector;
if (fCurrentInputSymbol = IDENTSym) then begin
Get;
(S4  as  TCSSStringSelector).StringSelectorType  :=  sstIdent;
(S4  as  TCSSStringSelector).StrData  :=  LexString;
end else if (fCurrentInputSymbol = STRINGSym) then begin
Get;
(S4  as  TCSSStringSelector).StringSelectorType  :=  sstString;
(S4  as  TCSSStringSelector).StrData  :=  LexString;
end else begin SynError(52);
end;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
InsertSelectorIntoSelector(S3,  S2);
InsertSelectorIntoSelector(S3,  S4);
S2  :=  S3;
end;
Expect(_rbrackSym);
InsertSelectorIntoSelector(S,  S2);
end;

procedure TCSSGrammar._class (out  S:  TCSSStringSelector);begin
Expect(_pointSym);
Expect(IDENTSym);
S  :=  TCSSStringSelector.CreateWithTracker(ParseTracker  as  TTracker);
S.SelectorType  :=  cstStringSelector;
(S  as  TCSSStringSelector).StringSelectorType  :=  sstClass;
(S  as  TCSSStringSelector).StrData  :=  LexString;
end;

procedure TCSSGrammar._element_name (out  S:  TCSSStringSelector);begin
S  :=  TCSSStringSelector.CreateWithTracker(ParseTracker  as  TTracker);
(S  as  TCSSStringSelector).SelectorType  :=  cstStringSelector;
(S  as  TCSSStringSelector).StringSelectorType  :=  sstIdent;
if (fCurrentInputSymbol = IDENTSym) then begin
Get;
S.StrData  :=  LexString;
end else if (fCurrentInputSymbol = _starSym) then begin
Get;
S.IdentStarred  :=  true;
end else begin SynError(53);
end;
end;

procedure TCSSGrammar._simple_selector (out  S:  TCSSSelector);var  S1:  TCSSSelector;  ST:  TCSSStringSelector;
begin
S  :=  nil;  S1  :=  nil;  ST  :=  nil;
if (fCurrentInputSymbol = IDENTSym) OR
 (fCurrentInputSymbol = _starSym) then begin
_element_name(ST);
S  :=  ST;
end else if (fCurrentInputSymbol = HASHSym) OR
 (fCurrentInputSymbol = _colonSym) OR
 (fCurrentInputSymbol = _pointSym) OR
 (fCurrentInputSymbol = _lbrackSym) then begin
if (fCurrentInputSymbol = HASHSym) then begin
Get;
S  :=  TCSSStringSelector.CreateWithTracker(ParseTracker  as  TTracker);
S.SelectorType  :=  cstStringSelector;
(S  as  TCSSStringSelector).StringSelectorType  :=  sstHash;
(S  as  TCSSStringSelector).StrData  :=  LexString;

end else if (fCurrentInputSymbol = _pointSym) then begin
_class(ST);
S  :=  ST;
end else if (fCurrentInputSymbol = _lbrackSym) then begin
_attrib(S);
end else begin
_pseudo(S);
end;
end else begin SynError(54);
end;
while (fCurrentInputSymbol = HASHSym) OR
 (fCurrentInputSymbol = _colonSym) OR
 (fCurrentInputSymbol = _pointSym) OR
 (fCurrentInputSymbol = _lbrackSym) do begin
if (fCurrentInputSymbol = HASHSym) then begin
Get;
S1  :=  TCSSStringSelector.CreateWithTracker(ParseTracker  as  TTracker);
S1.SelectorType  :=  cstStringSelector;
(S1  as  TCSSStringSelector).StringSelectorType  :=  sstHash;
(S1  as  TCSSStringSelector).StrData  :=  LexString;
if  Assigned(S)  then
   InsertSelectorIntoSelector(S1,S);
S  :=  S1;

end else if (fCurrentInputSymbol = _pointSym) then begin
_class(ST);
S1  :=  ST;
if  Assigned(S)  then
   InsertSelectorIntoSelector(S1,S);
S  :=  S1;
end else if (fCurrentInputSymbol = _lbrackSym) then begin
_attrib(S1);
if  Assigned(S)  then
   InsertSelectorIntoSelector(S1,S);
S  :=  S1;
end else begin
_pseudo(S1);
if  Assigned(S)  then
   InsertSelectorIntoSelector(S1,S);
S  :=  S1;
end;
end;
end;

procedure TCSSGrammar._combinator (out  S:  TCSSSelector);begin
S  :=  TCSSSelector.CreateWithTracker(ParseTracker  as  TTracker);
if (fCurrentInputSymbol = _plusSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
S.SelectorType  :=  cstCombinatorPlus;
end else if (fCurrentInputSymbol = _greaterSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
S.SelectorType  :=  cstCombinatorGreater;
end else if (fCurrentInputSymbol = _tildeSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
S.SelectorType  :=  cstCombinatorTilde;
end else begin SynError(55);
end;
end;

procedure TCSSGrammar._medium (out  Decl:  TCSSDeclaration);var  A:  TCSSAtom;
begin
if (fCurrentInputSymbol = IDENTSym) then begin
Get;

  Decl  :=  TCSSDeclaration.CreateWithTracker(ParseTracker  as  TTracker);
  Decl.DeclType  :=  cdtDecl;
  A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
  A.ExprType  :=  cetAtom;
  A.AtomType  :=  atIdent;
  A.StrData  :=  LexString;
  InsertValIntoDecl(Decl,  A);

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end else if (fCurrentInputSymbol = _lparenSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
_declaration(Decl);
Expect(_rparenSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end else begin SynError(56);
end;
end;

procedure TCSSGrammar.__PERCENTAGE (out  A:  TCSSAtom);begin
Expect(PERCENTAGESym);
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.AtomType  :=  atPercentage;
A.StrData  :=  LexString;

end;

procedure TCSSGrammar.__NUMBER (out  A:  TCSSAtom);begin
Expect(NUMBERSym);
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.AtomType  :=  atNumber;
A.StrData  :=  LexString;

end;

procedure TCSSGrammar._selector (out  S:  TCSSSelector);var  S1,  S2:  TCSSSelector;
begin
S1  :=  nil;  S2  :=  nil;
_simple_selector(S);
if (fCurrentInputSymbol = SSym) OR
 (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _greaterSym) OR
 (fCurrentInputSymbol = _tildeSym) then begin
if (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _greaterSym) OR
 (fCurrentInputSymbol = _tildeSym) then begin
_combinator(S1);
_selector(S2);
InsertSelectorIntoSelector(S1,  S);
InsertSelectorIntoSelector(S1,  S2);
S  :=  S1;
end else begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[7], fCurrentInputSymbol) then begin
if (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _greaterSym) OR
 (fCurrentInputSymbol = _tildeSym) then begin
_combinator(S1);
end;
_selector(S2);
if  Assigned(S1)  then
begin
      InsertSelectorIntoSelector(S1,  S);
      InsertSelectorIntoSelector(S1,  S2);
      S  :=  S1;
end
else
begin
   S1  :=  TCSSSelector.CreateWithTracker(ParseTracker  as  TTracker);
   S1.SelectorType  :=  cstTrailing;
   InsertSelectorIntoSelector(S1,  S);
   InsertSelectorIntoSelector(S1,  S2);
   S  :=  S1;
end;
end;
end;
end;
end;

procedure TCSSGrammar._pseudo_page (out  A:  TCSSAtom);begin
Expect(_colonSym);
Expect(IDENTSym);
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.AtomType  :=  atPseudoPage;
A.StrData  :=  LexString;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._declaration (out  D:  TCSSDeclaration);var  LBL,  Val:  TCSSExpr;
     AtDecl:  TCSSAtDecl;
begin
LBL  :=  nil;  Val  :=  nil;  AtDecl  :=  nil;
D  :=  TCSSDeclaration.CreateWithTracker(ParseTracker  as  TTracker);

if _In(symSet[8], fCurrentInputSymbol) then begin
D.DeclType  :=  cdtDecl;
_expr(Val);
while (fCurrentInputSymbol = _colonSym) do begin
Get;
LBL  :=  Val;
Val  :=  nil;
InsertValIntoDecl(D,  LBL);
//TODO:  check  preceding  expr  is  bare  ident.

while (fCurrentInputSymbol = SSym) do begin
Get;
end;
_expr(Val);
end;
if  Assigned(Val)  then
   InsertValIntoDecl(D,  Val);
if (fCurrentInputSymbol = IMPORTANT_SYMSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
D.HasPriority  :=  true;
end;
end else if (fCurrentInputSymbol = MEDIA_SYMSym) OR
 (fCurrentInputSymbol = WEBKIT_KEYFRAMES_SYMSym) OR
 (fCurrentInputSymbol = KEYFRAMES_SYMSym) then begin
D.DeclType  :=  cdtNestedMedia;
_inner_media_decl(AtDecl);
InsertAtDeclIntoDecl(D,  AtDecl);
end else begin SynError(57);
end;
end;

procedure TCSSGrammar._inner_media_decl (out  AtDecl:  TCSSAtDecl);var  List:  TCSSList;
     Ruleset:  TCSSAtDecl;
     Decl:  TCSSDeclaration;
begin
AtDecl  :=  TCSSAtDecl.CreateWithTracker(ParseTracker  as  TTRacker);
List  :=  nil;  Ruleset  :=  nil;  Decl  :=  nil;
if (fCurrentInputSymbol = MEDIA_SYMSym) then begin
Get;
AtDecl.AtDeclType  :=  catMedia;
end else if (fCurrentInputSymbol = WEBKIT_KEYFRAMES_SYMSym) then begin
Get;
AtDecl.AtDeclType  :=  catWebkitKeyframes;
end else if (fCurrentInputSymbol = KEYFRAMES_SYMSym) then begin
Get;
AtDecl.AtDeclType  :=  catKeyframes;
end else begin SynError(58);
end;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
_media_list(List);
InsertListIntoAtDecl(AtDecl,  List);
Expect(_lbraceSym);
Ruleset  :=  TCSSAtDecl.CreateWithTracker(FParseTracker  as  TTracker);
Ruleset.AtDeclType  :=  catRuleset;
List  :=  TCSSList.CreateWithTracker(ParseTracker  as  TTRacker);
List.ListType  :=  cltMediaList;
InsertListIntoAtDecl(Ruleset,  List);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[9], fCurrentInputSymbol) then begin
_declaration(Decl);
InsertDeclIntoList(List,  Decl);
end;
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[9], fCurrentInputSymbol) then begin
_declaration(Decl);
InsertDeclIntoList(List,  Decl);
end;
end;
InsertRulesetIntoAtDecl(AtDecl,  Ruleset);
Expect(_rbraceSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._media_list (out  L:  TCSSList);var  Decl:  TCSSDeclaration;
begin
L  :=  TCSSList.CreateWithTracker(ParseTracker  as  TTracker);
Decl  :=  nil;
L.ListType  :=  cltMediaList;
_medium(Decl);
InsertDeclIntoList(L,  Decl);
while (fCurrentInputSymbol = IDENTSym) OR
 (fCurrentInputSymbol = SSym) OR
 (fCurrentInputSymbol = _commaSym) OR
 (fCurrentInputSymbol = _lparenSym) do begin
if (fCurrentInputSymbol = _commaSym) then begin
Get;
end;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
_medium(Decl);
InsertDeclIntoList(L,  Decl);
end;
end;

procedure TCSSGrammar.__URI (out  A:  TCSSAtom);begin
Expect(URISym);
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.AtomType  :=  atUrl;
A.StrData  :=  LexString;

end;

procedure TCSSGrammar.__STRING (out  A:  TCSSAtom);begin
Expect(STRINGSym);
A  :=  TCSSAtom.CreateWithTracker(ParseTracker  as  TTracker);
A.ExprType  :=  cetAtom;
A.AtomType  :=  atString;
A.StrData  :=  LexString;

end;

procedure TCSSGrammar._font (out  AtDecl:  TCSSAtDecl);var   List:  TCSSList;
      Decl:  TCSSDeclaration;
begin
AtDecl  :=  TCSSAtDecl.CreateWithTracker(ParseTracker  as  TTRacker);
Decl  :=  nil;
Expect(FONT_FACE_SYMSym);
AtDecl.AtDeclType  :=  catFont;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
List  :=  TCSSList.CreateWithTracker(ParseTracker  as  TTracker);
List.ListType  :=  cltRulesetDeclList;
Expect(_lbraceSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[9], fCurrentInputSymbol) then begin
_declaration(Decl);
InsertDeclIntoList(List,  Decl);
end;
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[9], fCurrentInputSymbol) then begin
_declaration(Decl);
InsertDeclIntoList(List,  Decl);
end;
end;
Expect(_rbraceSym);
InsertListIntoAtDecl(AtDecl,  List);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._page (out  AtDecl:  TCSSAtDecl);var   List:  TCSSList;
      Decl:  TCSSDeclaration;
      A:  TCSSAtom;
begin
AtDecl  :=  TCSSAtDecl.CreateWithTracker(ParseTracker  as  TTRacker);
Decl  :=  nil;  A  :=  nil;

Expect(PAGE_SYMSym);
AtDecl.AtDeclType  :=  catPage;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if (fCurrentInputSymbol = _colonSym) then begin
_pseudo_page(A);
InsertAtomIntoAtDecl(AtDecl,  A);
end;
List  :=  TCSSList.CreateWithTracker(ParseTracker  as  TTracker);
List.ListType  :=  cltRulesetDeclList;
Expect(_lbraceSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[9], fCurrentInputSymbol) then begin
_declaration(Decl);
InsertDeclIntoList(List,  Decl);
end;
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[9], fCurrentInputSymbol) then begin
_declaration(Decl);
InsertDeclIntoList(List,  Decl);
end;
end;
Expect(_rbraceSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._media (out  AtDecl:  TCSSAtDecl);var  List:  TCSSList;
     Ruleset:  TCSSAtDecl;
begin
AtDecl  :=  TCSSAtDecl.CreateWithTracker(ParseTracker  as  TTRacker);
List  :=  nil;  Ruleset  :=  nil;
if (fCurrentInputSymbol = MEDIA_SYMSym) then begin
Get;
AtDecl.AtDeclType  :=  catMedia;
end else if (fCurrentInputSymbol = WEBKIT_KEYFRAMES_SYMSym) then begin
Get;
AtDecl.AtDeclType  :=  catWebkitKeyframes;
end else if (fCurrentInputSymbol = KEYFRAMES_SYMSym) then begin
Get;
AtDecl.AtDeclType  :=  catKeyframes;
end else begin SynError(59);
end;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
_media_list(List);
InsertListIntoAtDecl(AtDecl,  List);
Expect(_lbraceSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
while _In(symSet[10], fCurrentInputSymbol) do begin
_ruleset(Ruleset);
InsertRulesetIntoAtDecl(AtDecl,  Ruleset);
end;
Expect(_rbraceSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._ruleset (out  AtDecl:  TCSSAtDecl);var  List:  TCSSList;
     Sel:  TCSSSelector;
     Atom:  TCSSAtom;
     Decl:  TCSSDeclaration;
begin
AtDecl  :=  TCSSAtDecl.CreateWithTracker(ParseTracker  as  TTRacker);
AtDecl.AtDeclType  :=  catRuleset;
Sel  :=  nil;  Atom  :=  nil;  Decl  :=  nil;
if _In(symSet[11], fCurrentInputSymbol) then begin
List  :=  TCSSList.CreateWithTracker(ParseTracker  as  TTracker);
List.ListType  :=  cltSelectorList;
_selector(Sel);
InsertSelectorIntoList(List,  Sel);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
_selector(Sel);
InsertSelectorIntoList(List,  Sel);
end;
InsertListIntoAtDecl(AtDecl,  List);
end else if (fCurrentInputSymbol = NUMBERSym) then begin
__NUMBER(Atom);
InsertAtomIntoAtDecl(AtDecl,  Atom);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end else if (fCurrentInputSymbol = PERCENTAGESym) then begin
__PERCENTAGE(Atom);
InsertAtomIntoAtDecl(AtDecl,  Atom);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end else begin SynError(60);
end;
List  :=  TCSSList.CreateWithTracker(ParseTracker  as  TTracker);
List.ListType  :=  cltRulesetDeclList;
Expect(_lbraceSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[9], fCurrentInputSymbol) then begin
_declaration(Decl);
InsertDeclIntoList(List,  Decl);
end;
while (fCurrentInputSymbol = _semicolonSym) do begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if _In(symSet[9], fCurrentInputSymbol) then begin
_declaration(Decl);
InsertDeclIntoList(List,  Decl);
end;
end;
Expect(_rbraceSym);
InsertListIntoAtDecl(AtDecl,  List);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._import (out  AtDecl:  TCSSAtDecl);var  List:  TCSSList;
var  Atom:  TCSSAtom;
begin
AtDecl  :=  TCSSAtDecl.CreateWithTracker(ParseTracker  as  TTracker);
List  :=  nil;  Atom  :=  nil;
Expect(IMPORT_SYMSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
AtDecl.AtDeclType  :=  catImport;
if (fCurrentInputSymbol = STRINGSym) then begin
__STRING(Atom);
end else if (fCurrentInputSymbol = URISym) then begin
__URI(Atom);
end else begin SynError(61);
end;
if  Assigned(Atom)  then  InsertAtomIntoAtDecl(AtDecl,  Atom);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
if (fCurrentInputSymbol = IDENTSym) OR
 (fCurrentInputSymbol = _lparenSym) then begin
_media_list(List);
InsertListIntoAtDecl(AtDecl,  List);
end;
Expect(_semicolonSym);
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;

procedure TCSSGrammar._stylesheet (S:  TCSSScript);var  AtDecl:  TCSSAtDecl;
begin
if (fCurrentInputSymbol = CHARSET_SYMSym) then begin
Get;
Expect(SSym);
Expect(STRINGSym);
Expect(_semicolonSym);
end;
while (fCurrentInputSymbol = CDOSym) OR
 (fCurrentInputSymbol = CDCSym) OR
 (fCurrentInputSymbol = SSym) do begin
if (fCurrentInputSymbol = SSym) then begin
Get;
end else if (fCurrentInputSymbol = CDOSym) then begin
Get;
end else begin
Get;
end;
end;
while (fCurrentInputSymbol = IMPORT_SYMSym) do begin
_import(AtDecl);
InsertAtDeclInScript(S,  AtDecl);
while (fCurrentInputSymbol = CDOSym) OR
 (fCurrentInputSymbol = CDCSym) do begin
if (fCurrentInputSymbol = CDOSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end else begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;
end;
end;
while _In(symSet[12], fCurrentInputSymbol) do begin
if _In(symSet[10], fCurrentInputSymbol) then begin
_ruleset(AtDecl);
end else if (fCurrentInputSymbol = MEDIA_SYMSym) OR
 (fCurrentInputSymbol = WEBKIT_KEYFRAMES_SYMSym) OR
 (fCurrentInputSymbol = KEYFRAMES_SYMSym) then begin
_media(AtDecl);
end else if (fCurrentInputSymbol = PAGE_SYMSym) then begin
_page(AtDecl);
end else begin
_font(AtDecl);
end;
InsertAtDeclInScript(S,  AtDecl);
while (fCurrentInputSymbol = CDOSym) OR
 (fCurrentInputSymbol = CDCSym) do begin
if (fCurrentInputSymbol = CDOSym) then begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end else begin
Get;
while (fCurrentInputSymbol = SSym) do begin
Get;
end;
end;
end;
end;
end;

procedure TCSSGrammar._CSSGrammar;var  Sc:  TCSSGrammarScanner;
begin
FParseResult  :=  TCSSScript.CreateWithTracker(
   FParseTracker  as  TTracker);
_stylesheet(FParseResult  as  TCSSScript);
if (fCurrentInputSymbol = _lessSym) then begin
Get;
//Trailing  HTML  in  inline  script:  </script>
Sc  :=  (Scanner  as  TCSSGrammarScanner);
StreamPartRead  :=  Sc.BufferPosition;

end else if (fCurrentInputSymbol = EOFSYMB) then begin
Get;
end else begin SynError(62);
end;
end;

function TCSSGrammar.GetBuildDate : TDateTime;
const
  BDate = 42512;
  Hour = 22;
  Min = 50;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TCSSGrammar.GetVersion : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TCSSGrammar.GetVersionStr : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TCSSGrammar.GetVersionInfo : AnsiString;
begin
  Result := 'Comment: CSS parser.' + #13#10 +
'Author: Martin Harvey' + #13#10 +
'Copyright: (c) Martin Harvey';
end;

procedure TCSSGrammar.SetVersion(const Value : AnsiString);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TCSSGrammar.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_CSSGrammar;
end;  {Parse}

procedure TCSSGrammar.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 0, 2] := [];
symSet[ 1, 0] := [STRINGSym, URISym, FUNCSym];
symSet[ 1, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16];
symSet[ 1, 2] := [];
symSet[ 2, 0] := [STRINGSym, URISym, IDENTSym, FUNCSym, EMSSym, EXSSym, 
                    LENGTHSym, RESOLUTIONSym, ANGLESym, TIMESym, FREQSym];
symSet[ 2, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16, 
                    IMPORTANT_SYMSym-16, SSym-16, _semicolonSym-16, 
                    _rbraceSym-16];
symSet[ 2, 2] := [_commaSym-32, _rparenSym-32, _colonSym-32, _plusSym-32, 
                    _slashSym-32, _minusSym-32];
symSet[ 3, 0] := [STRINGSym, URISym, FUNCSym, EMSSym, EXSSym, LENGTHSym, 
                    RESOLUTIONSym, ANGLESym, TIMESym, FREQSym];
symSet[ 3, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16];
symSet[ 3, 2] := [];
symSet[ 4, 0] := [STRINGSym, URISym, IDENTSym, FUNCSym, EMSSym, EXSSym, 
                    LENGTHSym, RESOLUTIONSym, ANGLESym, TIMESym, FREQSym];
symSet[ 4, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16];
symSet[ 4, 2] := [_commaSym-32, _plusSym-32, _slashSym-32, _minusSym-32];
symSet[ 5, 0] := [CDOSym, CDCSym, INCLUDESSym, DASHMATCHSym, STRINGSym, 
                    URISym, IDENTSym, FUNCSym, EMSSym, EXSSym, LENGTHSym, 
                    RESOLUTIONSym, ANGLESym, TIMESym, FREQSym];
symSet[ 5, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16, 
                    IMPORTANT_SYMSym-16, SSym-16, PAGE_SYMSym-16, 
                    MEDIA_SYMSym-16, IMPORT_SYMSym-16, CHARSET_SYMSym-16, 
                    FONT_FACE_SYMSym-16, WEBKIT_KEYFRAMES_SYMSym-16, 
                    KEYFRAMES_SYMSym-16, _lessSym-16, _semicolonSym-16, 
                    _lbraceSym-16, _rbraceSym-16];
symSet[ 5, 2] := [_commaSym-32, _lparenSym-32, _colonSym-32, _plusSym-32, 
                    _greaterSym-32, _tildeSym-32, _pointSym-32, _starSym-32, 
                    _lbrackSym-32, _equalSym-32, _rbrackSym-32, _slashSym-32, 
                    _minusSym-32, NOSYMB-32];
symSet[ 6, 0] := [CDOSym, CDCSym, INCLUDESSym, DASHMATCHSym, STRINGSym, 
                    URISym, IDENTSym, EMSSym, EXSSym, LENGTHSym, 
                    RESOLUTIONSym, ANGLESym, TIMESym, FREQSym];
symSet[ 6, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16, 
                    IMPORTANT_SYMSym-16, SSym-16, PAGE_SYMSym-16, 
                    MEDIA_SYMSym-16, IMPORT_SYMSym-16, CHARSET_SYMSym-16, 
                    FONT_FACE_SYMSym-16, WEBKIT_KEYFRAMES_SYMSym-16, 
                    KEYFRAMES_SYMSym-16, _lessSym-16, _semicolonSym-16, 
                    _lbraceSym-16, _rbraceSym-16];
symSet[ 6, 2] := [_commaSym-32, _colonSym-32, _plusSym-32, _greaterSym-32, 
                    _tildeSym-32, _pointSym-32, _starSym-32, _lbrackSym-32, 
                    _equalSym-32, _rbrackSym-32, _slashSym-32, _minusSym-32, 
                    NOSYMB-32];
symSet[ 7, 0] := [IDENTSym];
symSet[ 7, 1] := [HASHSym-16];
symSet[ 7, 2] := [_colonSym-32, _plusSym-32, _greaterSym-32, _tildeSym-32, 
                    _pointSym-32, _starSym-32, _lbrackSym-32];
symSet[ 8, 0] := [STRINGSym, URISym, IDENTSym, FUNCSym, EMSSym, EXSSym, 
                    LENGTHSym, RESOLUTIONSym, ANGLESym, TIMESym, FREQSym];
symSet[ 8, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16];
symSet[ 8, 2] := [_plusSym-32, _minusSym-32];
symSet[ 9, 0] := [STRINGSym, URISym, IDENTSym, FUNCSym, EMSSym, EXSSym, 
                    LENGTHSym, RESOLUTIONSym, ANGLESym, TIMESym, FREQSym];
symSet[ 9, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16, MEDIA_SYMSym-16, 
                    WEBKIT_KEYFRAMES_SYMSym-16, KEYFRAMES_SYMSym-16];
symSet[ 9, 2] := [_plusSym-32, _minusSym-32];
symSet[10, 0] := [IDENTSym];
symSet[10, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16];
symSet[10, 2] := [_colonSym-32, _pointSym-32, _starSym-32, _lbrackSym-32];
symSet[11, 0] := [IDENTSym];
symSet[11, 1] := [HASHSym-16];
symSet[11, 2] := [_colonSym-32, _pointSym-32, _starSym-32, _lbrackSym-32];
symSet[12, 0] := [IDENTSym];
symSet[12, 1] := [PERCENTAGESym-16, NUMBERSym-16, HASHSym-16, PAGE_SYMSym-16, 
                    MEDIA_SYMSym-16, FONT_FACE_SYMSym-16, 
                    WEBKIT_KEYFRAMES_SYMSym-16, KEYFRAMES_SYMSym-16];
symSet[12, 2] := [_colonSym-32, _pointSym-32, _starSym-32, _lbrackSym-32];
end; {InitSymSet}

end { CSSGrammar }.    
