unit TrivXML;
{

Copyright © 2020 Martin Harvey <martin_c_harvey@hotmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

}


{==============================================================================
TrivXML
0.0.0.0
Date of Generation: 12/11/2019 14:53
Comment: Parses "Trivial XML" representation of a streamed datastructure.
Author: Martin Harvey
Copyright: (c) Martin Harvey

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,SSIntermediates,Trackables,TrivXMLDefs;



const
maxT = 15;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  ETrivXML = class(Exception);
  TTrivXML = class;

  TTrivXMLScanner = class(TCocoRScanner)
  private
    FOwner : TTrivXML;
function CharInIgnoreSet(const Ch : AnsiChar) : boolean;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TTrivXML read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TTrivXMLScanner }

  TTrivXML = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..0] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : AnsiString;
    function GetVersionStr : AnsiString;
    procedure SetVersion(const Value : AnsiString);
    function GetVersionInfo : AnsiString;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _PropTagEnd;
    procedure _PropContents (Prop: TSSIProperty);
    procedure _PropLongTrail (Prop: TSSIProperty);
    procedure _PropTagStart;
    procedure _PropTrail (Prop: TSSIProperty);
    procedure _PropStart (var Prop: TSSIProperty);
    procedure _PropData (var Prop: TSSIProperty);
    procedure _IDatTagEnd;
    procedure _PropList (var PList: TSSIList);
    procedure _IDatTagPartStart;
    procedure _InstanceDataTagPartStart (var InstData: TSSIInstanceData);
    procedure _InstanceDataWithAttrList (var InstData: TSSIInstanceData);
    procedure _InstanceProperties (InstData: TSSIInstanceData);
    procedure _IDatTagStart;
    procedure _InstanceDataTagStart (var InstData: TSSIInstanceData);
    procedure _InstanceData (var InstData: TSSIInstanceData);
    procedure _Val (var ValDat: TVal);
    procedure _ValStrOnly (var ValDat: TVal);
    procedure _Attr (var AttrDat: TAttr);
    procedure _AttrList (var AttrList: TSSIList);
    procedure _InstTagStart;
    procedure _Instance (var Inst: TSSIInstance);
    procedure _InstsDataEnd;
    procedure _InstDataContents (InstsData: TSSIList);
    procedure _InstsDataStart;
    procedure _InstancesEnd;
    procedure _InstancesContents (Insts: TSSIList);
    procedure _InstancesStart;
    procedure _TXmlEnd;
    procedure _TransEnd;
    procedure _TransContents (var Trans: TSSITransaction);
    procedure _TransStart;
    procedure _TXmlStart;
    procedure _TrivXML;

  private
    function MakeIntVal(var Val: TVal): boolean;
    function MakeIDVal(var Val: TVal): boolean;
    function MakeRealVal(var Val: TVal): boolean;    
    function ApplyAttrsToInstance(Inst: TSSIInstance; Attrs: TSSIList): boolean;
    function ApplyAttrsToProp(Prop: TSSIProperty; Attrs: TSSIList): boolean;
    function ApplyValToProp(Prop: TSSIProperty; const ValDat: TVal): boolean;
    function ApplyPListToProp(Prop:TSSIProperty; PList: TSSIList): boolean;
    function CheckNullPropAllowed(Prop: TSSIProperty):boolean;
    function UnHashString(InString:AnsiString; var ResString:string):boolean;
    function StripQuotes(InString: AnsiString): AnsiString;
    function UnEscapeString(InString:AnsiString):string;
    function UnMimeBlob(InString:AnsiString): TStream;
    procedure CheckTG(HeadLen, TrailLen: integer; TagName: AnsiString);
    procedure CheckTagStart(TagName: AnsiString);
    procedure CheckTagEnd(TagName: AnsiString);
    procedure CheckTagPartStart(TagName: AnsiString);
    procedure SynErrorEx(const errNo : integer; Data: AnsiString);           

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString; override;
    procedure Execute; override;
    function GetScanner : TTrivXMLScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : AnsiString read GetVersionStr;
    property VersionInfo : AnsiString read GetVersionInfo;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : AnsiString read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TTrivXML }

implementation
uses  IdCoderMIME;



const

  EOFSYMB = 0;  TagOpenSym = 1;  TagCloseSym = 2;  TagShortCloseSym = 3;
  TagStartSym = 4;  TagEndSym = 5;  TagPartStartSym = 6;  IDSym = 7;
  IntValSym = 8;  QuotStrValSym = 9;  AposStrValSym = 10;  RealValSym = 11;
  RealVal2Sym = 12;  eqSym = 13;  commaSym = 14;  NOSYMB = 15;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
{$WARNINGS OFF}

const
  S_CTYPE_STR = 'ClassType';
  S_OBJ_ID = 'ObjId';
  S_PROP_NAME = 'Name';
  S_PROP_TYPE = 'Type';
  S_PROP_SUBTYPE = 'Subtype';
  S_MIN_VAL = 'MinVal';
  S_MAX_VAL = 'MaxVal';
  S_MAX_STRLEN = 'MaxStrLen';
  S_STR_ENCODE = 'Encoding';
  S_HASH = '#';

function TTrivXML.MakeIntVal(var Val: TVal): boolean;
begin
  if vtInt in Val.ValTypes then
    result := true
  else if vtStr in Val.ValTypes then
  begin
    try
      Val.IntVal := StrToInt(String(Val.StrVal));
      Val.ValTypes := Val.ValTypes + [vtInt];
      result := true;
    except
      on EConvertError do result := false;
    end;
  end
  else
    result := false;
end;

//MakeInt64Val not required until we have object ID's
//over 2^31, or Int64 types with subranges (minval, maxval

function TTrivXML.MakeIDVal(var Val: TVal): boolean;
var
  Idx: integer;
begin
  if vtID in Val.ValTypes then
    result := true
  else if vtStr in Val.ValTypes then
  begin
    //Now need to check string follows rules for ID.
    //ID DESCRIPTION "Identifier" = letter { (letter | digit) } .
    result := false;
    for Idx := 1 to Length(Val.StrVal) do
    begin
      if (Idx = 1) then
      begin
        if not (Val.StrVal[Idx] in ['a'..'z', 'A'..'Z']) then
          exit;
      end
      else
      begin
        if not (Val.StrVal[Idx] in ['a'..'z', 'A'..'Z', '0'..'9']) then
          exit;
      end;
    end;
    result := true;
    Val.ValTypes := Val.ValTypes + [vtID];
  end
  else
    result := false;
end;

function TTrivXML.MakeRealVal(var Val: TVal): boolean;
begin
  if vtReal in Val.ValTypes then
    result := true
  else if (vtInt in Val.ValTypes) or (vtInt64 in Val.ValTypes) then
  begin
    Val.ValTypes := Val.ValTypes + [vtReal];
    Val.RealVal := Val.IntVal;
    result := true;
  end
  else
    result := false;
end;

function TTrivXML.ApplyAttrsToInstance(Inst: TSSIInstance; Attrs: TSSIList): boolean;
var
  FoundCType: boolean;
  Idx: integer;
  Attr: TAttr;
begin
  result := false;
  FoundCType := false;
  try
    if not (Assigned(Inst) and Assigned(Attrs)) then exit;
    for Idx := 0 to Pred(Attrs.Count) do
    begin
      Attr := TAttr(Attrs.Items[Idx]);
      if not Assigned(Attr) then exit;
      if CompareStr(String(Attr.IdStr), S_CTYPE_STR) = 0 then
      begin
        if FoundCType then exit;
        if not (vtStr in Attr.ValDat.ValTypes) then exit;
        if Length(Attr.ValDat.StrVal) = 0 then exit;
        Inst.ClassTypeString := String(Attr.ValDat.StrVal);
        FoundCType := true;
      end
      else if CompareStr(String(Attr.IdStr), S_OBJ_ID) = 0 then
      begin
        //Ignore object ID's.
      end
      else
        exit;
    end;
  finally
    Attrs.Free;
  end;
  result := FoundCType;
end;

function TTrivXML.ApplyAttrsToProp(Prop: TSSIProperty; Attrs: TSSIList): boolean;
var
  Idx: integer;
  Attr: TAttr;
  FoundName, FoundType, FoundSubType,
  FoundMinVal, FoundMaxVal, FoundMaxLen, FoundStrEncode: boolean;
  Name: AnsiString;
  MType, MTIdx: TSSIMajorType;
  SType, STIdx: TSSIMinorType;
  StrEnc, SEIdx: TSSIStringEncode;
  MinVal, MaxVal: Int64; 
  MaxLen: integer;
begin
  result := false;
  FoundName := false;
  FoundType := false;
  FoundSubType := false;
  FoundMinVal := false;
  FoundMaxVal := false;
  FoundMaxLen := false;
  FoundStrEncode := false;
  MType := Low(MType);
  SType := Low(SType);
  MinVal := 0;
  MaxVal := 0;
  MaxLen := 0;
  try
    if not (Assigned(Prop) and Assigned(Attrs)) then
      exit;
      
    //First, go though all attrs, and convert to values.
    for Idx := 0 to Pred(Attrs.Count) do
    begin
      Attr := TAttr(Attrs.Items[Idx]);
      if not Assigned(Attr) then
        exit;
      if CompareStr(String(Attr.IdStr), S_PROP_NAME) = 0 then
      begin
        if FoundName then exit; 
        if not (vtStr in Attr.ValDat.ValTypes) then exit;
        if Length(Attr.ValDat.StrVal) = 0 then exit;
        Name := Attr.ValDat.StrVal;
        FoundName := true;  
      end
      else if CompareStr(String(Attr.IdStr), S_PROP_TYPE) = 0 then
      begin
        if FoundType then exit;
        if not MakeIDVal(Attr.ValDat) then exit;
        for MTIdx := Low(MTIdx) to High(MTIdx) do
        begin
          if CompareStr(TSSIMajorTypeNames[MTIdx], String(Attr.ValDat.StrVal)) = 0 then
          begin
            FoundType := true;
            MType := MTIdx;
            break;
          end;
        end;
        if not FoundType then exit;      
      end
      else if CompareStr(String(Attr.IdStr), S_PROP_SUBTYPE) = 0 then
      begin
        if FoundSubType then exit;
        if not MakeIDVal(Attr.ValDat) then exit;
        for STIdx := Low(STIdx) to High(STIdx) do
        begin
          if CompareStr(TSSIMinorTypeNames[StIdx], String(Attr.ValDat.StrVal)) = 0 then
          begin
            FoundSubtype := true;
            SType := STIdx;
            break;
          end;
        end;
        if not FoundSubtype then exit;
      end
      else if CompareStr(String(Attr.IdStr), S_MIN_VAL) = 0 then
      begin
        if FoundMinVal then exit;
        if not MakeIntVal(Attr.ValDat) then exit;
        MinVal := Attr.ValDat.IntVal;
        FoundMinVal := true; 
      end
      else if CompareStr(String(Attr.IdStr), S_MAX_VAL) = 0 then
      begin
        if FoundMaxVal then exit;
        if not MakeIntVal(Attr.ValDat) then exit;
        MaxVal := Attr.ValDat.IntVal;
        FoundMaxVal := true;
      end                   
      else if CompareStr(String(Attr.IdStr), S_MAX_STRLEN) = 0 then
      begin
        if FoundMaxLen then exit;
        if not MakeIntVal(Attr.ValDat) then exit;
        if (Attr.ValDat.IntVal < Low(MaxLen)) or (Attr.ValDat.IntVal > High(MaxLen)) then exit;
        MaxLen := Attr.ValDat.IntVal;
        FoundMaxLen := true;
      end
      else if CompareStr(String(Attr.IdStr), S_STR_ENCODE) = 0 then
      begin
        if FoundStrEncode then exit;
        for SEIdx := Low(SEIdx) to High(SEIdx) do
        begin
          if CompareStr(TSSIStringEncodeNames[SEIdx], String(Attr.ValDat.StrVal)) = 0 then
          begin
            FoundStrEncode := true;
            StrEnc := SEIdx;
            break;
          end;
        end;
        if not FoundStrEncode then exit;                
      end
      else exit;
    end;
    
    //Second, take all of those values, consistency check, and apply
    //to property.
    if not FoundName then exit;
    if Length(Name) = 0 then exit;
    Prop.PropData.PropName := String(Name);
    //Check that types and subtypes are in order.
    if not FoundType then exit;
    //Require a subtype for Ord, Float and string - streaming system checks
    //the actual subtype in more detail.
    //However, for other types (int64, rec, array, class) expect no subtype,
    //or subtype = mitNone. 
    if MType in [sMajOrd, sMajFloat, sMajStr] then
    begin
      if not FoundSubType then exit;
    end
    else
    begin
      if SType <> mitNone then exit;
    end;
    Prop.PropData.PropType := MType;
    Prop.PropData.PropSubType := SType; 
    //MaxVal and MinVal ... are optional for ordinals, but if one exists, then
    //both must exist. Not allowed for other types. Not required for Int64.
    
    if MType = sMajOrd then
    begin
      if FoundMinVal <> FoundMaxVal then exit;
      Prop.PropData.LimsApply := FoundMinVal;
      if FoundMinVal then
      begin
        Prop.PropData.MinVal := MinVal;
        Prop.PropData.MaxVal := MaxVal;
      end;
    end
    else
    begin
      if FoundMinVal or FoundMaxVal then exit;
    end;                                        
    
    if MType = sMajStr then
    begin
      if (SType = mitShortString) <> FoundMaxLen then
        exit;
      if FoundMaxLen then
        Prop.PropData.MaxStrLen := MaxLen;
      if FoundStrEncode then
        Prop.PropData.StrRequiredEncode := StrEnc
      else
        Prop.PropData.StrRequiredEncode := scAscii;
    end
    else
    begin
      if FoundMaxLen or FoundStrEncode then exit;
    end;
        
    //All done!
    result := true;
  finally
    Attrs.Free;
  end; 
end;

function TTrivXML.ApplyValToProp(Prop: TSSIProperty; const ValDat: TVal): boolean;
var
  ValDatCopy: TVal;
begin
  result := false;
  if not Assigned(Prop) then exit;
  //Range checking elsewhere, just need to check value is correct basic type.
  case Prop.PropData.PropType of
  sMajOrd:
  begin
    if not ((vtInt in ValDat.ValTypes) or (vtInt64 in ValDat.ValTypes)) then exit;
    Prop.PropData.OrdData := ValDat.IntVal;
  end;
  sMajStr:
  begin
    if not (vtStr in ValDat.ValTypes) then exit;
    if Prop.PropData.StrRequiredEncode = scHashEnc then
    begin
      if not UnHashString(ValDat.StrVal, Prop.PropData.StrData) then
        exit;
    end
    else if Prop.PropData.StrRequiredEncode = scAscii then
      Prop.PropData.StrData := UnEscapeString(ValDat.StrVal)
    else
      exit;
  end;
  sMajBlob:
  begin
    if not (vtStr in ValDat.ValTypes) then exit;
    Assert(not Assigned(Prop.PropData.BlobData));
    Prop.PropData.BlobData := UnMimeBlob(ValDat.StrVal);
    if not Assigned(Prop.PropData.BlobData) then
      exit;
  end;
  sMajFloat:
  begin
    ValDatCopy := ValDat;
    if not MakeRealVal(ValDatCopy) then exit;
    Prop.PropData.FloatData := ValDatCopy.RealVal;
  end;
  sMajClass:
  begin
    if not (vtInt in ValDat.ValTypes) then exit;
    if (ValDat.IntVal < Low(Prop.PropData.ObjId)) or
      (ValDat.IntVal > High(Prop.PropData.ObjId)) then exit;
    Prop.PropData.ObjId := ValDat.IntVal;
  end;
  else
    //Unknown property type.
    //Records and arrays not dealt with here.
    exit;
  end;
  result := true;    
end;

function TTrivXML.ApplyPListToProp(Prop:TSSIProperty; PList: TSSIList): boolean;
begin
  result := false;
  if not (Assigned(Prop) and Assigned(PList)) then exit;
  if not (Prop.PropData.PropType in [sMajRec, sMajArray]) then exit;
  Prop.PropData.Items := PList;
  PList.Parent := Prop;
  result := true;
end;

function TTrivXML.CheckNullPropAllowed(Prop: TSSIProperty):boolean;
begin
  result := Assigned(Prop) and (Prop.PropData.PropType in [sMajRec, sMajArray]);
  if result and not Assigned(Prop.PropData.Items) then
  begin
    Prop.PropData.Items := TSSIList.CreateWithTracker(FParseTracker as TTracker);
    Prop.PropData.Items.Parent := Prop;
  end;
end;
    
function TTrivXML.UnHashString(InString:AnsiString; var ResString:string):boolean;
var
  idx: cardinal;
  Digits: string;
  WC: WideChar;
  NumVal: integer;  
begin
  result := false;  
  ResString := '';               
  idx := 1;
  try
    repeat
      if InString[idx] <> S_HASH then exit; //We need a hash char.
      Inc(Idx);
      Digits := '';
      while (idx <= Length(InString)) and (InString[idx] in ['0'..'9']) do
      begin
        Digits := Digits + InString[idx];
        Inc(Idx);    
      end;
      if Length(Digits) = 0 then exit; //Expect at least one digit.
      NumVal := StrToInt(Digits);
      Assert(SizeOf(WC) = SizeOf(Word));      
      if not ((NumVal >= Low(Word)) and (NumVal <= High(Word))) then exit;
      WC := WideChar(NumVal);
      ResString := ResString + WC;                      
    until idx > Length(InString);
  except
    on EConvertError do exit; 
  end;
  result := true;
end;

function TTrivXML.StripQuotes(InString:AnsiString):AnsiString;
begin
 if (InString[1] in ['''', '"']) then
   Delete(InString, 1 ,1)
 else
   SynError(1008);
 if (InString[Length(InString)] in ['''', '"']) then
   Delete(InString, Length(InString), 1)
 else
   SynError(1008);
 result := InString;
end;

function TTrivXML.UnEscapeString(InString:AnsiString):string;
var
  TempStr: AnsiString;
begin
 TempStr := InString;
 TempStr := AnsiString(StringReplace(String(TempStr), '&apos;', '''', [rfReplaceAll]));
 TempStr := AnsiString(StringReplace(String(TempStr), '&quot;', '"', [rfReplaceAll]));
 TempStr := AnsiString(StringReplace(String(TempStr), '&cr;', #13, [rfReplaceAll]));
 TempStr := AnsiString(StringReplace(String(TempStr), '&lf;', #10, [rfReplaceAll]));
 TempStr := AnsiString(StringReplace(String(TempStr), '&lt;', '<',  [rfReplaceAll]));
 TempStr := AnsiString(StringReplace(String(TempStr), '&gt;', '>',  [rfReplaceAll]));
 result := AnsiString(StringReplace(String(TempStr), '&amp;', '&', [rfReplaceAll]));
end;

function TTrivXML.UnMimeBlob(InString:AnsiString): TStream;
var
  Decoder: TIdDecoderMIME;
begin
  Decoder := TIdDecoderMime.Create(nil);
  try
    result := TMemoryStream.Create;
    try
      Decoder.DecodeStream(InString, result);
    except
      on E: Exception do
      begin
        result.Free;
        result := nil;
      end;
    end;
  finally
    Decoder.Free;
  end;
end;

procedure TTrivXML.SynErrorEx(const errNo : integer; Data: AnsiString);
begin
  if errDist >= minErrDist then
    GetScanner.ScannerError(errNo, GetScanner.NextSymbol, Data, etSyntax);
  errDist := 0;
end; {SynError}

procedure TTrivXML.CheckTG(HeadLen, TrailLen: integer; TagName: AnsiString);
var
  ActualTag: AnsiString;
  OK: boolean;
begin
  OK := false;
  ActualTag := LexString;
  if Length(ActualTag) = Length(TagName) + HeadLen + TrailLen then
  begin
    ActualTag := Copy(ActualTag, Succ(HeadLen), Length(TagName));
    if TagName = ActualTag then
      OK := true; 
  end;
  if not OK then
    SynErrorEx(1007, TagName);
end;

procedure TTrivXML.CheckTagStart(TagName: AnsiString);
begin
  CheckTG(1, 1, TagName);
end;

procedure TTrivXML.CheckTagEnd(TagName: AnsiString);
begin
  CheckTG(2, 1, TagName);
end;

procedure TTrivXML.CheckTagPartStart(TagName: AnsiString);           
begin
  CheckTG(1, 0, TagName);
end;

(* End of Arbitrary Code *)



{ --------------------------------------------------------------------------- }
{ ---- implementation for TTrivXMLScanner ---- }

procedure TTrivXMLScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TTrivXMLScanner.Comment : boolean;
var
  level : integer;
  StartCommentCh: AnsiChar;
  oldLineStart : longint;
  CommentStr : AnsiString;
begin
StartCommentCh := CurrInputCh;
  level := 1;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
Result := false;
if (CurrInputCh = '<') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '!') then
  begin
NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
{GenBody}
while true do
begin
if (CurrInputCh = '!') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '>') then
begin
level := level -  1;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
{/GenBody}
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := StartCommentCh;
Result := false;
end;
end;
end;  { Comment }

function TTrivXMLScanner.CharInIgnoreSet(const Ch : AnsiChar) : boolean;
begin
Result := (Ch = ' ')    OR
((CurrInputCh >= AnsiChar(9)) AND (CurrInputCh <= AnsiChar(10)) OR
(CurrInputCh = AnsiChar(13)) OR
(CurrInputCh = ' '));
end; {CharInIgnoreSet}


procedure TTrivXMLScanner.Get(var sym : integer);
var
  state : integer;
  label __start_get;
 begin   {Get}
__start_get:
while CharInIgnoreSet(CurrInputCh) do
  NextCh;
if ((CurrInputCh = '<')) AND Comment then goto __start_get;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: begin
sym := TagCloseSym;
exit;
end;
   2: if ((CurrInputCh = '>')) then
begin
state := 3; 
end
else
begin
  sym := _noSym;
exit;
end;
   3: begin
sym := TagShortCloseSym;
exit;
end;
   4: begin
sym := TagStartSym;
exit;
end;
   5: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
state := 6; 
end
else
begin
  sym := _noSym;
exit;
end;
   6: if ((CurrInputCh = '>')) then
begin
state := 7; 
end
else if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
   7: begin
sym := TagEndSym;
exit;
end;
   8: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
sym := IDSym;
exit;
end;
   9: if ((CurrInputCh = '"')) then
begin
state := 12; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '%') OR
(CurrInputCh >= '(') AND (CurrInputCh <= ';') OR
(CurrInputCh = '=') OR
(CurrInputCh >= '?')) then
begin
 
end
else if ((CurrInputCh = '&')) then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  10: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
state := 11; 
end
else
begin
  sym := _noSym;
exit;
end;
  11: if ((CurrInputCh = ';')) then
begin
state := 9; 
end
else if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
  12: begin
sym := QuotStrValSym;
exit;
end;
  13: if ((CurrInputCh = AnsiChar(39))) then
begin
state := 16; 
end
else if ((CurrInputCh <= AnsiChar(9)) OR
(CurrInputCh >= AnsiChar(11)) AND (CurrInputCh <= AnsiChar(12)) OR
(CurrInputCh >= AnsiChar(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '%') OR
(CurrInputCh >= '(') AND (CurrInputCh <= ';') OR
(CurrInputCh = '=') OR
(CurrInputCh >= '?')) then
begin
 
end
else if ((CurrInputCh = '&')) then
begin
state := 14; 
end
else
begin
  sym := _noSym;
exit;
end;
  14: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  15: if ((CurrInputCh = ';')) then
begin
state := 13; 
end
else if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
  sym := _noSym;
exit;
end;
  16: begin
sym := AposStrValSym;
exit;
end;
  17: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 19; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 18; 
end
else
begin
  sym := _noSym;
exit;
end;
  18: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 19; 
end
else
begin
  sym := _noSym;
exit;
end;
  19: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else
begin
sym := RealValSym;
exit;
end;
  20: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 21; 
end
else
begin
  sym := _noSym;
exit;
end;
  21: if ((CurrInputCh = 'E')) then
begin
state := 22; 
end
else if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else
begin
sym := RealVal2Sym;
exit;
end;
  22: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 24; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 23; 
end
else
begin
  sym := _noSym;
exit;
end;
  23: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 24; 
end
else
begin
  sym := _noSym;
exit;
end;
  24: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else
begin
sym := RealVal2Sym;
exit;
end;
  25: begin
sym := eqSym;
exit;
end;
  26: begin
sym := commaSym;
exit;
end;
  27: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
state := 30; 
end
else if ((CurrInputCh = '/')) then
begin
state := 5; 
end
else
begin
sym := TagOpenSym;
exit;
end;
  28: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'E')) then
begin
state := 17; 
end
else if ((CurrInputCh = '.')) then
begin
state := 20; 
end
else
begin
sym := IntValSym;
exit;
end;
  29: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 28; 
end
else
begin
  sym := _noSym;
exit;
end;
  30: if ((CurrInputCh = '>')) then
begin
state := 4; 
end
else if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
sym := TagPartStartSym;
exit;
end;
  31: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TTrivXMLScanner.Create;
begin
  inherited;
CurrentCh := CharAt;
fStartState[  0] := 31; fStartState[  1] := 32; fStartState[  2] := 32; fStartState[  3] := 32; 
fStartState[  4] := 32; fStartState[  5] := 32; fStartState[  6] := 32; fStartState[  7] := 32; 
fStartState[  8] := 32; fStartState[  9] := 32; fStartState[ 10] := 32; fStartState[ 11] := 32; 
fStartState[ 12] := 32; fStartState[ 13] := 32; fStartState[ 14] := 32; fStartState[ 15] := 32; 
fStartState[ 16] := 32; fStartState[ 17] := 32; fStartState[ 18] := 32; fStartState[ 19] := 32; 
fStartState[ 20] := 32; fStartState[ 21] := 32; fStartState[ 22] := 32; fStartState[ 23] := 32; 
fStartState[ 24] := 32; fStartState[ 25] := 32; fStartState[ 26] := 32; fStartState[ 27] := 32; 
fStartState[ 28] := 32; fStartState[ 29] := 32; fStartState[ 30] := 32; fStartState[ 31] := 32; 
fStartState[ 32] := 32; fStartState[ 33] := 32; fStartState[ 34] :=  9; fStartState[ 35] := 32; 
fStartState[ 36] := 32; fStartState[ 37] := 32; fStartState[ 38] := 32; fStartState[ 39] := 13; 
fStartState[ 40] := 32; fStartState[ 41] := 32; fStartState[ 42] := 32; fStartState[ 43] := 29; 
fStartState[ 44] := 26; fStartState[ 45] := 29; fStartState[ 46] := 32; fStartState[ 47] :=  2; 
fStartState[ 48] := 28; fStartState[ 49] := 28; fStartState[ 50] := 28; fStartState[ 51] := 28; 
fStartState[ 52] := 28; fStartState[ 53] := 28; fStartState[ 54] := 28; fStartState[ 55] := 28; 
fStartState[ 56] := 28; fStartState[ 57] := 28; fStartState[ 58] := 32; fStartState[ 59] := 32; 
fStartState[ 60] := 27; fStartState[ 61] := 25; fStartState[ 62] :=  1; fStartState[ 63] := 32; 
fStartState[ 64] := 32; fStartState[ 65] :=  8; fStartState[ 66] :=  8; fStartState[ 67] :=  8; 
fStartState[ 68] :=  8; fStartState[ 69] :=  8; fStartState[ 70] :=  8; fStartState[ 71] :=  8; 
fStartState[ 72] :=  8; fStartState[ 73] :=  8; fStartState[ 74] :=  8; fStartState[ 75] :=  8; 
fStartState[ 76] :=  8; fStartState[ 77] :=  8; fStartState[ 78] :=  8; fStartState[ 79] :=  8; 
fStartState[ 80] :=  8; fStartState[ 81] :=  8; fStartState[ 82] :=  8; fStartState[ 83] :=  8; 
fStartState[ 84] :=  8; fStartState[ 85] :=  8; fStartState[ 86] :=  8; fStartState[ 87] :=  8; 
fStartState[ 88] :=  8; fStartState[ 89] :=  8; fStartState[ 90] :=  8; fStartState[ 91] := 32; 
fStartState[ 92] := 32; fStartState[ 93] := 32; fStartState[ 94] := 32; fStartState[ 95] := 32; 
fStartState[ 96] := 32; fStartState[ 97] :=  8; fStartState[ 98] :=  8; fStartState[ 99] :=  8; 
fStartState[100] :=  8; fStartState[101] :=  8; fStartState[102] :=  8; fStartState[103] :=  8; 
fStartState[104] :=  8; fStartState[105] :=  8; fStartState[106] :=  8; fStartState[107] :=  8; 
fStartState[108] :=  8; fStartState[109] :=  8; fStartState[110] :=  8; fStartState[111] :=  8; 
fStartState[112] :=  8; fStartState[113] :=  8; fStartState[114] :=  8; fStartState[115] :=  8; 
fStartState[116] :=  8; fStartState[117] :=  8; fStartState[118] :=  8; fStartState[119] :=  8; 
fStartState[120] :=  8; fStartState[121] :=  8; fStartState[122] :=  8; fStartState[123] := 32; 
fStartState[124] := 32; fStartState[125] := 32; fStartState[126] := 32; fStartState[127] := 32; 
fStartState[128] := 32; fStartState[129] := 32; fStartState[130] := 32; fStartState[131] := 32; 
fStartState[132] := 32; fStartState[133] := 32; fStartState[134] := 32; fStartState[135] := 32; 
fStartState[136] := 32; fStartState[137] := 32; fStartState[138] := 32; fStartState[139] := 32; 
fStartState[140] := 32; fStartState[141] := 32; fStartState[142] := 32; fStartState[143] := 32; 
fStartState[144] := 32; fStartState[145] := 32; fStartState[146] := 32; fStartState[147] := 32; 
fStartState[148] := 32; fStartState[149] := 32; fStartState[150] := 32; fStartState[151] := 32; 
fStartState[152] := 32; fStartState[153] := 32; fStartState[154] := 32; fStartState[155] := 32; 
fStartState[156] := 32; fStartState[157] := 32; fStartState[158] := 32; fStartState[159] := 32; 
fStartState[160] := 32; fStartState[161] := 32; fStartState[162] := 32; fStartState[163] := 32; 
fStartState[164] := 32; fStartState[165] := 32; fStartState[166] := 32; fStartState[167] := 32; 
fStartState[168] := 32; fStartState[169] := 32; fStartState[170] := 32; fStartState[171] := 32; 
fStartState[172] := 32; fStartState[173] := 32; fStartState[174] := 32; fStartState[175] := 32; 
fStartState[176] := 32; fStartState[177] := 32; fStartState[178] := 32; fStartState[179] := 32; 
fStartState[180] := 32; fStartState[181] := 32; fStartState[182] := 32; fStartState[183] := 32; 
fStartState[184] := 32; fStartState[185] := 32; fStartState[186] := 32; fStartState[187] := 32; 
fStartState[188] := 32; fStartState[189] := 32; fStartState[190] := 32; fStartState[191] := 32; 
fStartState[192] := 32; fStartState[193] := 32; fStartState[194] := 32; fStartState[195] := 32; 
fStartState[196] := 32; fStartState[197] := 32; fStartState[198] := 32; fStartState[199] := 32; 
fStartState[200] := 32; fStartState[201] := 32; fStartState[202] := 32; fStartState[203] := 32; 
fStartState[204] := 32; fStartState[205] := 32; fStartState[206] := 32; fStartState[207] := 32; 
fStartState[208] := 32; fStartState[209] := 32; fStartState[210] := 32; fStartState[211] := 32; 
fStartState[212] := 32; fStartState[213] := 32; fStartState[214] := 32; fStartState[215] := 32; 
fStartState[216] := 32; fStartState[217] := 32; fStartState[218] := 32; fStartState[219] := 32; 
fStartState[220] := 32; fStartState[221] := 32; fStartState[222] := 32; fStartState[223] := 32; 
fStartState[224] := 32; fStartState[225] := 32; fStartState[226] := 32; fStartState[227] := 32; 
fStartState[228] := 32; fStartState[229] := 32; fStartState[230] := 32; fStartState[231] := 32; 
fStartState[232] := 32; fStartState[233] := 32; fStartState[234] := 32; fStartState[235] := 32; 
fStartState[236] := 32; fStartState[237] := 32; fStartState[238] := 32; fStartState[239] := 32; 
fStartState[240] := 32; fStartState[241] := 32; fStartState[242] := 32; fStartState[243] := 32; 
fStartState[244] := 32; fStartState[245] := 32; fStartState[246] := 32; fStartState[247] := 32; 
fStartState[248] := 32; fStartState[249] := 32; fStartState[250] := 32; fStartState[251] := 32; 
fStartState[252] := 32; fStartState[253] := 32; fStartState[254] := 32; fStartState[255] := 32; 
end; {Create}


{ --------------------------------------------------------------------------- }
{ ---- implementation for TTrivXML ---- }

constructor TTrivXML.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TTrivXMLScanner.Create;
  GetScanner.Owner := self;
FParseTracker := TTracker.Create;

  InitSymSet;
end; {Create}

destructor TTrivXML.Destroy;
begin
  Scanner.Free;
FParseTracker.Free;

  inherited;
end; {Destroy}

function TTrivXML.ErrorStr(const ErrorCode : integer; const Data : AnsiString) : AnsiString;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := '< expected';
   2 : Result := '> expected';
   3 : Result := '/> expected';
   4 : Result := 'start tag <tag> expected';
   5 : Result := 'end tag </tag> expected';
   6 : Result := 'partial start tag <tag expected';
   7 : Result := 'Identifier expected';
   8 : Result := 'Integer value expected';
   9 : Result := 'string value expected';
  10 : Result := 'string value expected';
  11 : Result := 'Floating point value, no decimal point expected';
  12 : Result := 'Floating point value, with decimal point expected';
  13 : Result := 'eq expected';
  14 : Result := 'comma expected';
  15 : Result := 'not expected';
  16 : Result := 'invalid Property contents';
  17 : Result := 'invalid Property closing tag';
  18 : Result := 'invalid Property closing tag';
  19 : Result := 'invalid Instance data complicatedstart tag';
  20 : Result := 'invalid Instance data with attribute list';
  21 : Result := 'invalid Instance properties and closing tag';
  22 : Result := 'invalid Instance data';
  23 : Result := 'invalid value, expected string, int, real or ID';
  24 : Result := 'invalid escaped string value';

1000: Result := 'Expected ClassType=<string>, ObjId=<integer>';
    1001: Result := 'Expected ObjId=<integer>';
    1002: Result := 'Expected PropName=<name>, Type=<type> [, SubType=<subtype>] [MinVal=<minval>, MaxVal=<maxval>] [MaxStrLen=<maxlen>] [Encoding=<encoding>]';
    1003: Result := 'This type of property must contain some data.';
    1004: Result := 'The property data read from the stream does not match its type or is badly encoded.';
    1005: Result := 'This type of property cannot contain a property list.';
    1006: Result := 'Conversion error converting string to numeric quantity';
    1007: Result := 'Expected tag name: ' + Data;
    1008: Result := 'Bad string quotes';
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := AnsiString('Error: ' + AnsiString(IntToStr(ErrorCode)));
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TTrivXML.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;
  StreamPartRead := -1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TTrivXML.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TTrivXML.GetScanner : TTrivXMLScanner;
begin
  Result := Scanner AS TTrivXMLScanner;
end; {GetScanner}

function TTrivXML._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TTrivXML._PropTagEnd;begin
Expect(TagEndSym);
CheckTagEnd('Property');
end;

procedure TTrivXML._PropContents (Prop:  TSSIProperty);var  ValDat:  TVal;  PList:  TSSIList;
begin
if (fCurrentInputSymbol < 16) { prevent range error } AND
 (fCurrentInputSymbol IN [IDSym, IntValSym, QuotStrValSym, AposStrValSym, 
                    RealValSym, RealVal2Sym])  then begin
_Val(ValDat);
if  not  ApplyValToProp(Prop,  ValDat)  then  SynError(1004);
end else if (fCurrentInputSymbol = TagPartStartSym) then begin
PList  :=  nil;
_PropList(PList);
if  not  ApplyPListToProp(Prop,  PList)  then  SynError(1005);
end else begin SynError(16);
end;
end;

procedure TTrivXML._PropLongTrail (Prop:  TSSIProperty);begin
if (fCurrentInputSymbol < 16) { prevent range error } AND
 (fCurrentInputSymbol IN [TagPartStartSym, IDSym, IntValSym, QuotStrValSym, 
                    AposStrValSym, RealValSym, RealVal2Sym])  then begin
_PropContents(Prop);
_PropTagEnd;
end else if (fCurrentInputSymbol = TagEndSym) then begin
_PropTagEnd;
if  not  CheckNullPropAllowed(Prop)  then
    SynError(1003);
end else begin SynError(17);
end;
end;

procedure TTrivXML._PropTagStart;begin
Expect(TagPartStartSym);
CheckTagPartStart('Property');
end;

procedure TTrivXML._PropTrail (Prop:  TSSIProperty);begin
if (fCurrentInputSymbol = TagCloseSym) then begin
Get;
_PropLongTrail(Prop);
end else if (fCurrentInputSymbol = TagShortCloseSym) then begin
Get;
if  not  CheckNullPropAllowed(Prop)  then
    SynError(1003);
end else begin SynError(18);
end;
end;

procedure TTrivXML._PropStart (var  Prop:  TSSIProperty);var  AttrListDat:  TSSIList;
begin
Prop  :=  TSSIProperty.CreateWithTracker(FParseTracker  as  TTracker);
_PropTagStart;
_AttrList(AttrListDat);
if  not  ApplyAttrsToProp(Prop,  AttrListDat)  then
   SynError(1002);
end;

procedure TTrivXML._PropData (var  Prop:  TSSIProperty);begin
_PropStart(Prop);
_PropTrail(Prop);
end;

procedure TTrivXML._IDatTagEnd;begin
Expect(TagEndSym);
CheckTagEnd('InstData');
end;

procedure TTrivXML._PropList (var  PList:  TSSIList);var  Prop:  TSSIProperty;
begin
if  not  Assigned(PList)  then
   PList  :=  TSSIList.CreateWithTracker(FParseTracker  as  TTracker);
_PropData(Prop);
PList.Add(Prop);
while (fCurrentInputSymbol = TagPartStartSym) do begin
_PropData(Prop);
PList.Add(Prop);
end;
end;

procedure TTrivXML._IDatTagPartStart;begin
Expect(TagPartStartSym);
CheckTagPartStart('InstData');
end;

procedure TTrivXML._InstanceDataTagPartStart (var  InstData:  TSSIInstanceData);begin
_IDatTagPartStart;
if (fCurrentInputSymbol = IDSym) then begin
_InstanceDataWithAttrList(InstData);
end else if (fCurrentInputSymbol = TagShortCloseSym) then begin
Get;
end else begin SynError(19);
end;
end;

procedure TTrivXML._InstanceDataWithAttrList (var  InstData:  TSSIInstanceData);var  AttrListDat:  TSSIList;
begin
_AttrList(AttrListDat);
AttrListDat.Free;  (*  Attribute  checking  code  removed.  *)
if (fCurrentInputSymbol = TagCloseSym) then begin
Get;
_InstanceProperties(InstData);
end else if (fCurrentInputSymbol = TagShortCloseSym) then begin
Get;
end else begin SynError(20);
end;
end;

procedure TTrivXML._InstanceProperties (InstData:  TSSIInstanceData);var  InstProps:  TSSIList;
begin
if (fCurrentInputSymbol = TagPartStartSym) then begin
InstProps  :=  InstData.Properties;
_PropList(InstProps);
_IDatTagEnd;
end else if (fCurrentInputSymbol = TagEndSym) then begin
_IDatTagEnd;
end else begin SynError(21);
end;
end;

procedure TTrivXML._IDatTagStart;begin
Expect(TagStartSym);
CheckTagStart('InstData');
end;

procedure TTrivXML._InstanceDataTagStart (var  InstData:  TSSIInstanceData);begin
_IDatTagStart;
_InstanceProperties(InstData);
end;

procedure TTrivXML._InstanceData (var  InstData:  TSSIInstanceData);begin
InstData  :=  TSSIInstanceData.CreateWithTracker(FParseTracker  as  TTracker);
if (fCurrentInputSymbol = TagStartSym) then begin
_InstanceDataTagStart(InstData);
end else if (fCurrentInputSymbol = TagPartStartSym) then begin
_InstanceDataTagPartStart(InstData);
end else begin SynError(22);
end;
end;

procedure TTrivXML._Val (var  ValDat:  TVal);begin
if (fCurrentInputSymbol = IntValSym) then begin
Get;
ValDat.ValTypes  :=  [];
try
   ValDat.IntVal  :=  StrToInt(String(LexString));
   ValDat.ValTypes  :=  ValDat.ValTypes  +  [VTInt];
   ValDat.ValTypes  :=  ValDat.ValTypes  +  [VTInt64];
except
   on  EConvertError  do
   begin
     try
       ValDat.RealVal  :=  StrToFloat(String(LexString));
       ValDat.ValTypes  :=  ValDat.ValTypes  +  [vtReal];
     except
     end;
     try
       ValDat.IntVal  :=  StrToInt64(String(LexString));
       ValDat.ValTypes  :=  ValDat.ValTypes  +  [VTInt64];
     except
     end;
   end;
end;
if  ValDat.ValTypes  =  []  then
   SynError(1006);

end else if (fCurrentInputSymbol = QuotStrValSym) OR
 (fCurrentInputSymbol = AposStrValSym) then begin
_ValStrOnly(ValDat);
end else if (fCurrentInputSymbol = RealValSym) then begin
Get;
ValDat.ValTypes  :=  [vtReal];
try
   ValDat.RealVal  :=  StrToFloat(String(LexString));
except
   on  EConvertError  do  SynError(1006);
end;

end else if (fCurrentInputSymbol = RealVal2Sym) then begin
Get;
ValDat.ValTypes  :=  [vtReal];
try
  ValDat.RealVal  :=  StrToFloat(String(LexString));
except
  on  EConvertError  do  SynError(1006);
end;

end else if (fCurrentInputSymbol = IDSym) then begin
Get;
ValDat.Valtypes  :=  [vtID];
ValDat.StrVal  :=  LexString;
end else begin SynError(23);
end;
end;

procedure TTrivXML._ValStrOnly (var  ValDat:  TVal);begin
if (fCurrentInputSymbol = QuotStrValSym) then begin
Get;
ValDat.ValTypes  :=  [vtStr];
ValDat.StrVal  :=  StripQuotes(LexString);
end else if (fCurrentInputSymbol = AposStrValSym) then begin
Get;
ValDat.ValTypes  :=  [vtStr];
ValDat.StrVal  :=  StripQuotes(LexString);
end else begin SynError(24);
end;
end;

procedure TTrivXML._Attr (var  AttrDat:  TAttr);begin
AttrDat  :=  TAttr.CreateWithTracker(FParseTracker  as  TTracker);
Expect(IDSym);
AttrDat.IdStr  :=  LexString;
Expect(eqSym);
_ValStrOnly(AttrDat.ValDat);
end;

procedure TTrivXML._AttrList (var  AttrList:  TSSIList);var  AttrDat:  TAttr;
begin
AttrList  :=  TSSIList.CreateWithTracker(FParseTracker  as  TTracker);
_Attr(AttrDat);
AttrList.Add(AttrDat);
while (fCurrentInputSymbol = IDSym) do begin
_Attr(AttrDat);
AttrList.Add(AttrDat);
end;
end;

procedure TTrivXML._InstTagStart;begin
Expect(TagPartStartSym);
CheckTagPartStart('Instance');
end;

procedure TTrivXML._Instance (var  Inst:  TSSIInstance);var  AttrListDat:  TSSIList;
begin
Inst  :=  TSSIInstance.CreateWithTracker(FParseTracker  as  TTracker);
_InstTagStart;
_AttrList(AttrListDat);
if  not  ApplyAttrsToInstance(Inst,  AttrListDat)  then
    SynError(1000);
Expect(TagShortCloseSym);
end;

procedure TTrivXML._InstsDataEnd;begin
Expect(TagEndSym);
CheckTagEnd('InstancesData');
end;

procedure TTrivXML._InstDataContents (InstsData:  TSSIList);var  InstData:  TSSIInstanceData;
begin
_InstanceData(InstData);
InstsData.Add(InstData);
while (fCurrentInputSymbol = TagStartSym) OR
 (fCurrentInputSymbol = TagPartStartSym) do begin
_InstanceData(InstData);
InstsData.Add(InstData);
end;
end;

procedure TTrivXML._InstsDataStart;begin
Expect(TagStartSym);
CheckTagStart('InstancesData');
end;

procedure TTrivXML._InstancesEnd;begin
Expect(TagEndSym);
CheckTagEnd('Instances');
end;

procedure TTrivXML._InstancesContents (Insts:  TSSIList);var  Inst:  TSSIInstance;
begin
_Instance(Inst);
Insts.Add(Inst);
while (fCurrentInputSymbol = TagPartStartSym) do begin
_Instance(Inst);
Insts.Add(Inst);
end;
end;

procedure TTrivXML._InstancesStart;begin
Expect(TagStartSym);
CheckTagStart('Instances');
end;

procedure TTrivXML._TXmlEnd;begin
Expect(TagEndSym);
CheckTagEnd('TrivXML');
end;

procedure TTrivXML._TransEnd;begin
Expect(TagEndSym);
CheckTagEnd('Transaction');
end;

procedure TTrivXML._TransContents (var  Trans:  TSSITransaction);var  Insts,  InstsData:  TSSIList;
begin
Trans  :=  TSSITransaction.CreateWithTracker(FParseTracker  as  TTracker);
Insts  :=  Trans.Instances;
InstsData  :=  Trans.InstancesData;

_InstancesStart;
_InstancesContents(Insts);
_InstancesEnd;
_InstsDataStart;
_InstDataContents(InstsData);
_InstsDataEnd;
end;

procedure TTrivXML._TransStart;begin
Expect(TagStartSym);
CheckTagStart('Transaction');
end;

procedure TTrivXML._TXmlStart;begin
Expect(TagStartSym);
CheckTagStart('TrivXML');
end;

procedure TTrivXML._TrivXML;var  Trans:  TSSITransaction;
begin
_TXmlStart;
_TransStart;
_TransContents(Trans);
FParseResult  :=  Trans;
_TransEnd;
_TXmlEnd;
Expect(EOFSYMB);
end;

function TTrivXML.GetBuildDate : TDateTime;
const
  BDate = 41424;
  Hour = 02;
  Min = 18;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TTrivXML.GetVersion : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TTrivXML.GetVersionStr : AnsiString;
begin
  Result := '0.0.0.0';
end;

function TTrivXML.GetVersionInfo : AnsiString;
begin
  Result := 'Comment: Parses "Trivial XML" representation of a streamed datastructure.' + #13#10 +
'Author: Martin Harvey' + #13#10 +
'Copyright: (c) Martin Harvey';
end;

procedure TTrivXML.SetVersion(const Value : AnsiString);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TTrivXML.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_TrivXML;
end;  {Parse}

procedure TTrivXML.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
end; {InitSymSet}

end { TrivXML }.    
